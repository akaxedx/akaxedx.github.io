<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content="mybatis秋招复习">
<title>数据库相关</title>

<link rel='canonical' href='https://akaxedx.github.io/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/'>

<link rel="stylesheet" href="/scss/style.min.ae5dcca4aba68a55efaf26a3449bc5aadef19e44c13385723d3fd76af6f91881.css"><meta property='og:title' content="数据库相关">
<meta property='og:description' content="mybatis秋招复习">
<meta property='og:url' content='https://akaxedx.github.io/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/'>
<meta property='og:site_name' content='AKAxedx-wfj'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:tag' content='秋招' /><meta property='article:published_time' content='2024-09-02T10:17:38&#43;08:00'/><meta property='article:modified_time' content='2024-09-02T10:17:38&#43;08:00'/><meta property='og:image' content='https://akaxedx.github.io/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/saber.jpg' />
<meta name="twitter:title" content="数据库相关">
<meta name="twitter:description" content="mybatis秋招复习"><meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content='https://akaxedx.github.io/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/saber.jpg' />
    <link rel="shortcut icon" href="/favicon.ico" />

    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/avatar_hu6690453460540257700.png" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
                    <span class="emoji">😍</span>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">AKAxedx-wfj</a></h1>
            <h2 class="site-description">时来天地皆同力，运去英雄不自由</h2>
        </div>
    </header><ol class="menu-social">
            
                <li>
                    <a 
                        href='https://github.com/akaxedx/'
                        target="_blank"
                        title="GitHub"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5" />
</svg>



                        
                    </a>
                </li>
            
        </ol><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>主页</span>
            </a>
        </li>
        
        
        <li >
            <a href='/%E5%85%B3%E4%BA%8E/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>关于</span>
            </a>
        </li>
        
        
        <li >
            <a href='/%E5%BD%92%E6%A1%A3/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>归档</span>
            </a>
        </li>
        
        
        <li >
            <a href='/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>搜索</span>
            </a>
        </li>
        
        
        <li >
            <a href='/%E5%8F%8B%E6%83%85%E9%93%BE%E6%8E%A5/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>



                
                <span>友情链接</span>
            </a>
        </li>
        
        <li class="menu-bottom-section">
            <ol class="menu">

                
                    <li id="dark-mode-toggle">
                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <span>深色模式</span>
                    </li>
                
            </ol>
        </li>
    </ol>
</aside>

    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">目录</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
  <ol>
    <li><a href="#mybatis-的优缺点">Mybatis 的优缺点</a>
      <ol>
        <li><a href="#优点">优点</a></li>
        <li><a href="#缺点">缺点</a></li>
      </ol>
    </li>
    <li><a href="#-和--的区别">#{} 和 ${} 的区别</a></li>
    <li><a href="#索引的基本原理">索引的基本原理</a></li>
    <li><a href="#索引设计的原则">索引设计的原则</a></li>
    <li><a href="#事务的基本特性和隔离级别">事务的基本特性和隔离级别</a>
      <ol>
        <li><a href="#事务基本特性-acid">事务基本特性 ACID</a></li>
        <li><a href="#隔离性的四个隔离级别">隔离性的四个隔离级别</a></li>
      </ol>
    </li>
    <li><a href="#什么是-mvcc">什么是 MVCC</a></li>
    <li><a href="#myisam-和-innodb-的区别">MyISAM 和 InnoDB 的区别</a>
      <ol>
        <li><a href="#myisam">MyISAM</a></li>
        <li><a href="#innodb">InnoDB</a></li>
      </ol>
    </li>
    <li><a href="#explain-语句结果中各个字段分别表示什么">Explain 语句结果中各个字段分别表示什么</a></li>
    <li><a href="#索引覆盖是什么">索引覆盖是什么</a></li>
    <li><a href="#最左前缀原则">最左前缀原则</a></li>
    <li><a href="#innodb-是如何实现事务的">InnoDB 是如何实现事务的</a></li>
    <li><a href="#b-树和-b-树的区别为什么-mysql-使用-b-树">B 树和 B+ 树的区别，为什么 Mysql 使用 B+ 树</a></li>
    <li><a href="#mysql-锁有哪些如何理解">Mysql 锁有哪些，如何理解</a></li>
    <li><a href="#redis-的过期键的删除策略">Redis 的过期键的删除策略</a></li>
    <li><a href="#redis-事务实现">Redis 事务实现</a></li>
    <li><a href="#redis-主从复制的核心原理">Redis 主从复制的核心原理</a></li>
    <li><a href="#redis-有哪些数据结构有哪些应用场景">Redis 有哪些数据结构，有哪些应用场景</a></li>
    <li><a href="#redis-分布式锁底层是如何实现的">Redis 分布式锁底层是如何实现的</a></li>
    <li><a href="#redis-集群策略">Redis 集群策略</a></li>
    <li><a href="#缓存穿透缓存击穿缓存雪崩分别是什么">缓存穿透，缓存击穿，缓存雪崩分别是什么</a></li>
    <li><a href="#redis-和-mysql-如何保证数据一致">Redis 和 Mysql 如何保证数据一致</a></li>
    <li><a href="#redis-持久化机制">Redis 持久化机制</a>
      <ol>
        <li><a href="#rdb">RDB</a></li>
        <li><a href="#aof">AOF</a></li>
      </ol>
    </li>
    <li><a href="#redis-单线程为什么这么快">Redis 单线程为什么这么快</a></li>
  </ol>
</nav>
        </div>
    </section>

            
        
    </aside>


            <main class="main full-width">
    <article class="has-image main-article">
    <header class="article-header">
        <div class="article-image">
            <a href="/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/">
                <img src="/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/saber_hu13534768285976523167.jpg"
                        srcset="/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/saber_hu13534768285976523167.jpg 800w, /p/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/saber_hu4471581961825435897.jpg 1600w"
                        width="800" 
                        height="485" 
                        loading="lazy"
                        alt="Featured image of post 数据库相关" />
                
            </a>
        </div>
    

    <div class="article-details">
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/">数据库相关</a>
        </h2>
    
        
        <h3 class="article-subtitle">
            mybatis秋招复习
        </h3>
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">2024-09-02</time>
            </div>
        

        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <h1 id="数据库相关">数据库相关
</h1><h2 id="mybatis-的优缺点">Mybatis 的优缺点
</h2><h3 id="优点">优点
</h3><ul>
<li>基于 SQL 语言编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL 写在 XML 里，基础 SQL 与程序代码的耦合，便于统一管理；提供 XML 标签，支持编写动态 SQL 语句，并可重用</li>
<li>与 JDBC 相比，减少了 50% 以上的代码量，消除了 JDBC 大量冗余的代码，不需要手动开关连接</li>
<li>很好的与各种数据库兼容（因为 Mybatis 使用 JDBC 来连接数据库，所以只要 JDBC 支持的数据库 Mybatis 都支持）</li>
<li>能够与 Spring 很好的集成</li>
<li>提供映射标签，支持对象与数据库的 ORM 字段关系映射；提供对象关系映射标签，支持对象关系组件维护</li>
</ul>
<h3 id="缺点">缺点
</h3><ul>
<li>SQL 语句的编写工作量大，尤其当字段多、关联表多时，对开发人员编写 SQL 语句的功底有一定要求</li>
<li>SQL 语句依赖于数据库，导致数据库移植性差，不能随意更换数据库</li>
</ul>
<h2 id="-和--的区别">#{} 和 ${} 的区别
</h2><p>#{} 是预编译处理、是占位符，${} 是字符串替换、是拼接符</p>
<p>Mybatis 在处理 #{} 时，会将 SQL 中的 #{} 替换为 ? ，调用 PreparedStatement 来赋值</p>
<p>Mybatis 在处理 ${} 时，会将 SQL 中的 ${} 替换成变量的值，调用 Statement 来赋值</p>
<p>使用 #{} 可以有效地防止 SQL 注入，提高系统安全性</p>
<h2 id="索引的基本原理">索引的基本原理
</h2><p>索引用来快速地寻找那些具有特定值的记录，如果没有索引，一般来说执行查询时遍历整张表</p>
<p>索引的原理：就是把无序的数据编程有序的查询</p>
<ul>
<li>把创建了索引的列的内容进行排序</li>
<li>对排序结果生成倒排表</li>
<li>在倒排表内容上拼上数据地址链</li>
<li>在查询时先拿到倒排表内容，再取出数据的地址链，从而拿到具体数据</li>
</ul>
<h2 id="索引设计的原则">索引设计的原则
</h2><p>查询更快，占用空间更小</p>
<ul>
<li>适合索引的列时出现再 where 子句中的列，或者连接子句中指定的列</li>
<li>基数较小的类，索引效果较差，没必要在此列建立索引</li>
<li>使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间，如果搜索词超过索引前缀长度，则使用索引排除不匹配的行，然后检查其余行是否可能匹配</li>
<li>不要过度索引，索引需要额外的磁盘空间，并降低写操作的性能。再修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个事件就会越长。所以只要保持需要的索引有利于查询即可</li>
<li>定义有外键的数据列一定要建立索引</li>
<li>更新频繁字段不适合创建索引</li>
<li>若是不能有效区分数据的列不适合做索引列（如性别）</li>
<li>尽量的扩展索引，不要新建索引，比如表中已经有 a 的索引，现在要加  (a,b) 的 索引，那么只需要修改原来的索引即可</li>
<li>对于哪些查询中很少涉及的列，重复值比较多的列不要建立索引</li>
<li>对于定义为 text、image 和 bit 的数据类型的列不要建立索引</li>
</ul>
<h2 id="事务的基本特性和隔离级别">事务的基本特性和隔离级别
</h2><h3 id="事务基本特性-acid">事务基本特性 ACID
</h3><p><strong>原子性</strong> 指的是一个事务中的操作要么全部成功，要么全部失败</p>
<p><strong>一致性</strong> 指的是数据库总是从一个一致性的状态转换到另一个一致性的状态。比如 A 转账给 B 100 元，假设 A 只有 90 元，支付之前我们数据库里的数据都是符合约束的，但是如果事务执行成功，数据库数据就破坏约束了，因此事务不能成功</p>
<p><strong>隔离性</strong> 指的是一个事务的修改再最终提交前，对其他事务是不可见的</p>
<p><strong>持久性</strong> 指的是一旦事务提交，所做的修改就会永久保存到数据库中</p>
<h3 id="隔离性的四个隔离级别">隔离性的四个隔离级别
</h3><ul>
<li>read uncommit 读未提交，可能会读到其他事务未提交的数据，也叫做脏读，用户本来应该读取到 id = 1的用户 age 应该是 10，结果读到了其他事务还没有提交的事务，结果读取结果 age = 20，这就是脏读</li>
<li>read commit 读已提交，两次读取结果不一致，也叫不可重复读，不可重复读解决了脏读的问题，他只会读取已经提交的事务。用户开启事务读取 id = 1的用户，查询到 age = 10，再次读取发现结果未 20，在同一个事务里同一个查询读取到不同的结果叫做不可重复读</li>
<li>repeatable read 可重复读，mysql 默认级别，每次读取结果都一样，但是可能产生幻读</li>
<li>serializable 串行，一般是不会使用的，他会给每一行读取的数据加锁，会导致大量超时和锁竞争的问题</li>
</ul>
<h2 id="什么是-mvcc">什么是 MVCC
</h2><p>多版本并发控制，指的是在使用 READ COMMITTD、REPEATABLE READ 这两种隔离级别的事务在执行普通 SELECT 操作时访问记录的版本链的过程。可以使用不同事务的读-写、写-读操作并发执行，从而提升系统性能。READ COMMITTD、REPEATABLE READ 这两个隔离级别的一个很大的不同是：生成 ReadView 的时机不同，READ COMMITTD 在每一次进行普通 SELECT 操作前都会生成一个 ReadView，而 REPEATABLE READ 只在第一次进行普通 SELECT 操作前生成一个 ReadView，之后的查询操作都重复使用这个 ReadView</p>
<h2 id="myisam-和-innodb-的区别">MyISAM 和 InnoDB 的区别
</h2><h3 id="myisam">MyISAM
</h3><ul>
<li>不支持事务，但是每次查询都是原子的</li>
<li>支持表级锁，每次操作对整个表加锁</li>
<li>存储表的总行数</li>
<li>一个 MyISAM 表有三个文件：索引文件，表结构文件，数据文件</li>
<li>采用非聚集索引，索引文件的数据域存储指向数据文件的指针。辅索引与主索引基本一致，但是辅索引不用保证唯一性</li>
</ul>
<h3 id="innodb">InnoDB
</h3><ul>
<li>支持 ACID 的事务</li>
<li>支持事务的四种隔离级别</li>
<li>支持行级锁以及外键约束，因此可以支持写并发</li>
<li>不存储行总数</li>
<li>一个 InnoDB 引擎存储在一个文件空间（共享表空间，表大小不受操作系统控制，一个表可能分布在多个文件中），也可能未多个（设置为独立表空间，表大小受操作系统文件大小限制，一般为 2G），受操作系统文件大小的限制</li>
<li>主键索引采用聚集索引（索引的数据域存储数据文件本身），辅索引的数据域存储主键的值；因此从辅索引查找数据，需要先通过辅索引找到主键值，再访问辅索引；最好使用自增主键，防止插入数据时，为维持 B+ 树结构，文件的大调整</li>
</ul>
<h2 id="explain-语句结果中各个字段分别表示什么">Explain 语句结果中各个字段分别表示什么
</h2><div class="table-wrapper"><table>
  <thead>
      <tr>
          <th>列名</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>id</td>
          <td>查询语句中每出现一个 SELECT 关键字，MySQL 就会为它分配一个唯一的 id 值，某些子查询会被优化为 join 查询，那么出现的 id 会一样</td>
      </tr>
      <tr>
          <td>select_type</td>
          <td>SELECT 关键字对应的那个查询类型</td>
      </tr>
      <tr>
          <td>table</td>
          <td>表名</td>
      </tr>
      <tr>
          <td>partitions</td>
          <td>匹配的分区信息</td>
      </tr>
      <tr>
          <td>type</td>
          <td>针对单表的查询方式（全表扫描、索引）</td>
      </tr>
      <tr>
          <td>possible_keys</td>
          <td>可能用到的索引</td>
      </tr>
      <tr>
          <td>key</td>
          <td>实际上使用的索引</td>
      </tr>
      <tr>
          <td>ken_len</td>
          <td>实际上使用的索引长度</td>
      </tr>
      <tr>
          <td>ref</td>
          <td>当使用索引列等值查询时，与索引列进行等值匹配的对象信息</td>
      </tr>
      <tr>
          <td>rows</td>
          <td>预估的需要读取的记录条数</td>
      </tr>
      <tr>
          <td>filterte</td>
          <td>某个表经过 搜索条件过滤后剩余记录条数的百分比</td>
      </tr>
      <tr>
          <td>Extra</td>
          <td>一些额外的信息，比如排列</td>
      </tr>
  </tbody>
</table></div>
<h2 id="索引覆盖是什么">索引覆盖是什么
</h2><p>索引覆盖就是一个 SQL 再执行时，可以利用索引来快速查找，并且此 SQL 所要查询的字段在当前索引对应的字段中都包含了，那么就表示此 SQL 走完索引后不用回表了，所需要的字段都在当前索引的叶子节点上存在，可以直接作为结果返回</p>
<h2 id="最左前缀原则">最左前缀原则
</h2><p>当一个 SQL 想要利用索引时，就一定要提供该索引锁对应的字段中最左边的字段，也iu是排在最前面的字段，比如针对 a,b,c 三个字段建立了一个联合索引，那么在写以恶搞 SQL 时就一定要提供 a 字段的条件，这样才能用到联合索引，这是由于建立 a,b,c 三个字段的联合索引时，底层的 B+ 树时按照 a,b,c 三个字段从左往右去比较大小进行排序的，所以如果想要利用 B+ 树进行快速查找也得符合这个规则</p>
<h2 id="innodb-是如何实现事务的">InnoDB 是如何实现事务的
</h2><p>InnoDB 通过 Buffer Pool，LogBuffer，Redo Log，Undo Log 来实现事务，以一个 update 语句为例</p>
<ul>
<li>InnoDB 在收到一个 update 后，会先根据条件找到数据所在的也，并将该页缓存在 Buffer Pool 中</li>
<li>执行 update 语句，修改 Buffer Pool 重点数据，也就是内存中的数据</li>
<li>针对 update 语句生成一个 RedoLog 对象，并存入 LogBuffer 中</li>
<li>针对 update 语句生成 undolog 日志，用于事务回滚</li>
<li>如果事务提交，那么把 RedoLog 对象进行持久化，后续还有其他机制将 Buffer Pool 中所修改的数据页持久化到磁盘中</li>
<li>如果事务回滚，那么利用 undolog 日志进行回滚</li>
</ul>
<h2 id="b-树和-b-树的区别为什么-mysql-使用-b-树">B 树和 B+ 树的区别，为什么 Mysql 使用 B+ 树
</h2><p>B 树的特点</p>
<ul>
<li>节点排序</li>
<li>一个节点可以存放多个元素</li>
</ul>
<p>B+ 树的特点</p>
<ul>
<li>拥有 B 树的特点</li>
<li>叶子节点之间有指针</li>
<li>非叶子节点上的元素在叶子节点上都冗余了，也就是叶子节点中存储了所有的元素，并且排好序</li>
</ul>
<p>Mysql 索引使用的是 B+ 树，因为索引是用来加快查询的，而 B+ 树通过对数据进行 排序所以是可以提高查询速度的，然后通过一个节点中可以存储多个元素，从而可以使 B+ 树的高度不会太高，在 Mysql 中一个 InnoDB 页就是一个 B+ 树节点，一个 InnoDB 页默认 16kb，所以一般情况下一棵两层的 B+ 树可以存 2000万行左右的数据，然后利用 B+ 树叶子节点存储了所有数据并进行了排序，并且叶子几点之间有指针，可以很好的支持全表扫描，范围查找等 SQL</p>
<h2 id="mysql-锁有哪些如何理解">Mysql 锁有哪些，如何理解
</h2><ul>
<li>
<p>按粒度分类</p>
<ul>
<li>行锁：锁某行数据，锁粒度最小，并发度高</li>
<li>表锁：锁整张表，锁粒度最大，并发度低</li>
<li>间隙锁：锁的是一个区间</li>
</ul>
</li>
<li>
<p>按读写分</p>
<ul>
<li>共享锁：读锁，一个事务给某行数据加了读锁，其他事务可以读，但不能写</li>
<li>排他锁：写锁，一个事务给某行数据加了写锁，其他事务不能读不能写</li>
</ul>
</li>
<li>
<p>按实现方式</p>
<ul>
<li>乐观锁：不会真正去锁某行记录，通过一个版本号来实现</li>
<li>乐观锁：上面的行锁、表锁都是悲观锁</li>
</ul>
</li>
</ul>
<p>在事务的隔离级别实现中，就需要利用锁来解决幻读</p>
<h2 id="redis-的过期键的删除策略">Redis 的过期键的删除策略
</h2><p>Redis 是 key-value 数据库，我们可以设置 Redis 中缓存的 key 的过期时间。Redis 的过期策略就是指当 Redis 中缓存的 key 过期了，Redis 如何处理</p>
<ul>
<li>惰性过期：只有当访问一个 key 时，才会判断该 key 是否已经过期，过期则清除。该策略可以最大化节省 CPU 资源，对内存不友好，极端情况下可能出现大量的过期 key 没有再次被访问，从而不会被清除，占用大量内存</li>
<li>定时过期（Redis 没使用）：实时监控过期时间，对内存友好，对 CPU 不友好</li>
<li>定期过期：每隔一段时间，会扫描一定数量的数据库的 expires 字典中一定数量的 key，并清除其中已经过期的 key。该策略是前两者的折中方案。通过调整定时扫描的 时间间隔和每次扫描的限定耗时，可以在不同情况下使得 CPU 和内存资源达到最优的平衡效果</li>
</ul>
<h2 id="redis-事务实现">Redis 事务实现
</h2><ul>
<li>事务开始
<ul>
<li>MULTI 命令的执行，标志着一个事务的开始。MULTI 命令会将客户端状态的 flags 属性中的 REDIS_MULTI 标识打开、</li>
</ul>
</li>
<li>命令入队
<ul>
<li>当一个客户端切换到事务状态之后，服务器会根据这个客户端发送来的命令来执行不同的操作。如果客户端发送的命令为 MULTI、EXEC、WATCh、DISCARD 中的一个，立即执行这个命令，否则将命令放入一个事务队列里，然后向客户端返回 QUEUED 回复
<ul>
<li>如果客户端发送的命令为 EXEC、DISCARD、WATCh、MULTI 四个命令中的一个，那么服务器立即执行这个命令</li>
<li>如果发送到是其他命令，服务器并不立即执行这个命令。首先检查命令格式是否正确，如果不正确，服务器会在客户端状态（redisClient）的 flags 属性关闭 REDIS_MULTI 标识，并返回错误信息给客户端。如果正确，将这个命令放入一个事务队列里，然后返回 QUEUED 回复</li>
</ul>
</li>
<li>事务队列是按照 FIFO 的方式保存入队命令</li>
</ul>
</li>
<li>事务执行
<ul>
<li>客户端发送 EXEC 命令，服务器执行 EXEC 命令逻辑
<ul>
<li>如果客户端状态的 flags 属性不包含 REDIS_MULTI 标识，或者包含 REDIS_DIRTY_CAS 或者 REDIS_DIRTY_EXEC 标识，那么就直接取消事务的执行</li>
<li>否则客户端处于事务状态（flags 有 REDIS_MULTI标识），服务器会遍历客户端的事务队列，然后执行事务队列中的所有命令，最后将返回结果全部返给客户端</li>
</ul>
</li>
<li>redis 不支持事务回滚机制，但是他会检查每一个事务中的命令是否错误</li>
<li>redis 事务不支持检查程序员自己逻辑的错误
<ul>
<li>WATCH 命令是一个乐观锁，可以为 Redis 事务提供 check-and-set （CAS）行为。可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到 EXEC 命令</li>
<li>MULTI 命令用于开启一个事务，它总是返回 OK。MuLTI 执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当 EXEC 被调用时，所有队列中的命令才会被执行</li>
<li>EXEC：执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。当操作被打断时，返回空值 nil</li>
<li>通过调用 DISCARD，客户端可以清空事务队列，并放弃执行事务，并且客户端会从事务状态退出</li>
<li>UNWATCH 命令可以取消 WATCH 对所有 key 的监控</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="redis-主从复制的核心原理">Redis 主从复制的核心原理
</h2><p>通过执行 slaveof 命令或设置 slaveof 选项，让一个人服务器去复制另一个服务器的数据。主数据库可以进行读写操作，当昔日操作导致数据变化时会自动将数据同步给从数据库。而从数据库一般是只读的，并接受主数据库同步过来的数据。一个主数据库可以拥有多个从数据库，而一个从数据库只能拥有一个主数据库</p>
<ul>
<li>全量复制
<ul>
<li>主节点通过 bgsave 命令 fork 子进程进行 RDB 持久化，该过程是非常消耗 CPU、内存（页表复制）、硬盘 IO 的</li>
<li>主节点通过网络将 RDB 文件发送给从节点，对主从节点的带宽都会带来很大的消耗</li>
<li>从节点清空老数据、载入新 RDB 文件的过程是阻塞的，无法响应客户端的命令；如果从节点执行 bgrewriteaof，也会带来额外的消耗</li>
</ul>
</li>
<li>部分复制
<ul>
<li>复制偏移量：执行复制的双方，主从节点，分别会维护一个复制偏移量 offset</li>
<li>复制积压缓冲区：主节点内部维护了一个固定长度、先进先出 （FIFO）队列作为复制积压缓冲区，当主从节点 offset 的差距过大超过缓冲区长度时，将无法执行部分复制，只能执行全量复制</li>
<li>服务运行 ID（runid）：每个 Redis 节点都有其运行 ID，yunxing ID 由节点在启动时自动生成，主节点会将自己运行ID 发送给从节点，从节点会将主节点的运行 ID 存起来。从节点 Redis 断开重连的时候，就是根据运行 ID 来判断同步的进度：
<ul>
<li>如果从节点保存的 runid 与主节点现在的 runid 相同，说明主从节点之前同步过，主从节点会继续尝试使用部分复制（到底能不呢部分复制还要看 offset 和复制积压缓冲区的情况）；</li>
<li>如果从节点保的 runid 与主节点现在的 runid 不同，说明从节点在断线前同步的 Redis 节点并不是当前的主节点，只能进行全量复制</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>过程原理：</p>
<p><img src="/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6.PNG"
	width="1227"
	height="746"
	srcset="/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6_hu9464399913091991059.PNG 480w, /p/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6_hu12076227166413969524.PNG 1024w"
	loading="lazy"
	
		alt="原理图解"
	
	
		class="gallery-image" 
		data-flex-grow="164"
		data-flex-basis="394px"
	
></p>
<h2 id="redis-有哪些数据结构有哪些应用场景">Redis 有哪些数据结构，有哪些应用场景
</h2><ul>
<li>字符串：可以用来做最简单的数据，可以缓存某个简单的字符串，也可以缓存某个 json 格式的字符串，Redis 分布式锁就利用了这种数据结构，还包括可以实现计数器、Session 共享、分布式 ID</li>
<li>哈希表：可以用来存储一些 key-value 对，更适合用来存储对象</li>
<li>列表：Redis 的列表通过命令的组合，既可以当作栈，也可以当作队列来使用，可以用来缓存类似微信公众号、微博等消息流数据</li>
<li>集合：和列表类似，也可以存储多个元素，但是不能重复，集合可以进行交集、并集、差集等操作，从而可以实现类似，我和某人共同关注的人、朋友圈点赞等功能</li>
<li>有序集合：集合是无序的，有序集合可以设置顺序，可以实现排行版功能</li>
</ul>
<h2 id="redis-分布式锁底层是如何实现的">Redis 分布式锁底层是如何实现的
</h2><ul>
<li>首先利用 setnx 来保证：如果 key 不存在才能获取到锁，如果 key 存在，则获取不到锁</li>
<li>然后还要利用 lua 脚本来保证多个 redis 操作的原子性</li>
<li>同时还要考虑到锁过期，所需要额外的一个看门狗定时任务来监听锁是否需要续约</li>
<li>同时还要考虑到 redis 节点挂掉后的情况，所以需要采用红锁的方式来同时向 N/2+1 个节点申请锁，都申请到了才证明获取锁成功，这样就算其中某个 redis 节点挂掉了，锁也不能被其他客户端获取到</li>
</ul>
<h2 id="redis-集群策略">Redis 集群策略
</h2><p>Redis 提供了三种集群策略</p>
<ul>
<li>主从模式：这种模式比较简单，主库可以读写，并且会和从库进行数据同步，这种模式下，客户端直接连接主库或者某个从库，但是当主库或者从库宕机后，客户端需要手动修改 IP，另外，这种模式也比较男进行扩容，整个集群所能存储的数据受到某台机器的内存容量，所以不可能支持特大数据量</li>
<li>哨兵模式：这种模式在主从的基础上新增了哨兵节点，但主库节点宕机后，哨兵会发现主库节点宕机，然后在从库中选择一个库作为新发主库，另外哨兵也可以做集群，从而可以保证当某一个哨兵接待你宕机后，还有其他哨兵节点可以继续工作，这种模式可以比较好的保证 Redis 集群的高可用，但是仍然不能很好的解决 Redis 的容量上限问题</li>
<li>Cluster 模式：Cluster 模式是用的比较多的模式，它支持多主多从，这种模式会按照 key 进行槽位的分配，可以使得不同的 key 分散到不同的主节点上，利用这种模式可以使得整个集群支持更大达到数据容量，同时每个主节点可以拥有自己的多个从节点，如果该主节点宕机，会从他的从节点选举一个新的主节点</li>
</ul>
<p>对于这三种模式，如果 Redis 要存的数据量不大，可以选择哨兵模式，如果 Redis 要存的数据量大，并且需要持续的扩容，那么选择 Cluster 模式</p>
<h2 id="缓存穿透缓存击穿缓存雪崩分别是什么">缓存穿透，缓存击穿，缓存雪崩分别是什么
</h2><p>缓存中存放的大多都是热点数据，目的就是防止请求可以直接从缓存中获取到数据，而不用访问 Mysql</p>
<ul>
<li>缓存雪崩：如果缓存中某一时刻大批热点数据同时过期，那么就可能导致大量请求直接访问 Mysql 了，解决办法就是在过期时间增加一点随机值，另外如果搭建一个高可用的 Redis 集群也是防止缓存雪崩的有效手段</li>
<li>缓存击穿：和缓存雪崩类似，缓存雪崩使大批热点数据失效，而缓存击穿是指某一个热点 key 突然失效，也导致了大量请求直接访问 Mysql 数据库，这就是缓存击穿，解决方案就是考虑这个热点 key 不设过期时间</li>
<li>缓存穿透：假如某一时刻访问 Redis 的大量 key 都不存在 Redis 中（如黑客故意伪造的 key），那么也会给数据库造成压力，这就是缓存穿透，解决方案是使用布隆过滤器，它的作用就是如果它认为一个 key 不存在，那么这个 key 就肯定不存在，所以可以在缓存之前增加一层布隆过滤器来拦截不存在的 key</li>
</ul>
<h2 id="redis-和-mysql-如何保证数据一致">Redis 和 Mysql 如何保证数据一致
</h2><ul>
<li>先更新 Mysql 再更新 Redis，如果更新 Redis 失败，可能仍然不一致</li>
<li>先删除 Redis 缓存数据，再更新 Mysql，再此查询的时候将数据加到缓存中，这种方案能解决第一个问题，但是在高并发下性能较低，而且仍然会出现数据不一致的问题，比如线程1删除了 Redis 缓存数据，正在更新 Mysql，此时另外一个查询再查询，就会把 Mysql 中的老数据又插到 Redis 中</li>
<li>延时双删，先删除 Redis 缓存数据，再更新 Mysql，延迟几百毫秒再删除 Redis 缓存数据，这样就算在更新 Mysql 时，有其他线程读了 Mysql，把老数据读到了 Redis 中，那么也会被删除，保证数据一致性</li>
</ul>
<h2 id="redis-持久化机制">Redis 持久化机制
</h2><h3 id="rdb">RDB
</h3><p>快照文件，二进制写进磁盘</p>
<p>手动触发：</p>
<ul>
<li>save 命令，使 Redis 处于阻塞状态，直到 RDB 持久化完成，才会响应其他客户端发来的命令，所以在生产环境一定要慎用</li>
<li>bgsave 命令，fork 出一个子进程执行持久化，主进程只在 fork 过程中有短暂的阻塞，子进程创建之后，主进程就可以响应客户端请求了</li>
</ul>
<p>自动触发：</p>
<ul>
<li>save m n：在 m 秒内，如果有 n 个键发生改变，则自动触发持久化，通过 bgsave 执行，如果设置多个，只要满足其一就会触发，配置文件有默认配置（可以注释掉）</li>
<li>flushall：用于清空 Redis 所有的数据库，flushdb 清空当前 Redis 所在数据库（默认是0号数据库），会清空 RDB 文件，同时也会生成 dump.rdb、内容为空</li>
<li>主从同步：全量同步时会自动触发 bgsave 命令。生成 rdb 发送给从节点</li>
</ul>
<p>优点：</p>
<ul>
<li>整个 Redis 只包含一个文件 dump.rdb，方便持久化</li>
<li>容灾性好，方便备份</li>
<li>性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以时 IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 Redis 高性能</li>
<li>相对于数据集大时，比 AOF 的启动效率更高</li>
</ul>
<p>缺点：</p>
<ul>
<li>数据安全低。RDB 是间隔一段时间进行持久化，如果持久化之间 Redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候</li>
<li>由于 RDB 是通过 fork 子进程来协助完成数据持久化工作的，因此，如果当数据集较大时可能会导致整个服务器停止服务几百毫秒，甚至一秒钟，会占用 CPU</li>
</ul>
<h3 id="aof">AOF
</h3><p>以日志形式记录服务器所处理的每一个写、删除操作，以文本方式记录，可以打开文件看到详细的操作记录</p>
<ul>
<li>所有的写命令会追加到 AOF 缓冲中</li>
<li>AOF 缓冲区根据对应的策略向硬盘进行同步操作</li>
<li>随着 AOF 文件越来越大，需要定期对 AOF 文件进行重写，达到压缩的目的</li>
<li>当 Redis 重启时，可以加载 AOF 文件进行数据恢复</li>
</ul>
<p>同步策略：</p>
<ul>
<li>每秒同步：异步完成，效率非常高，一旦系统出现宕机现象，那么这一秒钟之内修改的数据将会丢失</li>
<li>每修改同步：同步持久化，每次发生的数据变化都会被记录到磁盘中，最多丢失一条</li>
<li>不同步：由操作系统控制，可能丢失较多数据</li>
</ul>
<p>优点：</p>
<ul>
<li>数据安全</li>
<li>通过 append 模式写文件，即使中途服务器宕机也不会劈坏已经存在的内容，可以通过 redis-check-aof 工具解决数据一致性的问题</li>
<li>AOF 机制的 rewrite 模式。定期对 AOF 文件进行重写，以达到压缩的目的</li>
</ul>
<p>缺点：</p>
<ul>
<li>AOF 文件比 RDB 文件大，恢复速度慢</li>
<li>数据集大的时候，比 RDB 启动效率低</li>
<li>运行效率没有 RDB 高</li>
</ul>
<h2 id="redis-单线程为什么这么快">Redis 单线程为什么这么快
</h2><p>Redis 基于 Reactor 模式开发了网络事件处理器、文件事件处理器 file event handler。它是单线程的，所以 Redis 才叫做单线程的模型</p>

</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/%E7%A7%8B%E6%8B%9B/">秋招</a>
        
    </section>


    </footer>


    
</article>

    

    

     
    
        
    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
        2024 AKAxedx
    </section>
    
    <section class="powerby">
        
            知识学爆，鸿运齐天 <br/>
        使用 <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> 构建 <br />
        主题 <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.26.0">Stack</a></b> 由 <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a> 设计
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
