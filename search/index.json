[{"content":"开端 闲来无事，在b站加了一个群，群里有个有意思的机器人\n很有意思，在b站上搜索发现，springboot 是可以整合一些开源的框架完成这种操作，在使用后发现，目前的qq机器人框架都已经停止维护，登录协议已经无法使用，而且qq封禁力度大，很多机器人账号活不过几天，风险太大，就在准备放弃时，竟然发现！！！\n视频链接：https://www.bilibili.com/video/BV1Rp4y1J7kh/?spm_id_from=333.337.search-card.all.click\u0026amp;vd_source=63e472546bd25b2f0e56091098e6b110\n转折 qq开放平台在2024年5月份将qq官方机器人开放给个人使用，这简直让人太兴奋了，马不停蹄注册并开始使用\n在这里，我们可以创建机器人，填写一些奇奇怪怪不重要的信息就可以开始进行开发了\n准备工作 首页 无服务器 在我们没有服务器的情况下，我们可以通过配置沙箱进行开发，里面有很多现成的插件供我们使用和配置，这里不再过多赘述，具体设置可以看 这个链接\n有服务器 作为一个拥有自己服务器的高端人士（用的最便宜最垃圾的服务器），我们当然要自己去开发有意思的功能，怎么能用别人的呢，我们开发的功能只是自己使用，并不会发布这个机器人（主要是ai太贵，发布出去用的人多了，钱包hold不住，自己玩玩拉倒）\n沙箱配置 在沙箱配置中，指定机器人生效的群聊，群聊只能选择一个（在具体的使用过程中发现，先指定一个群聊，在群聊中把机器人加入群聊，然后再重新指定群聊，先前加入机器人的群聊机器人不会消失，卡个bug可以让很多群都能使用这个机器人哦）\n开发设置 我们在这里重置token并记录token值\n配置我们服务器的 IP 地址\n回调配置等暂时没有用到，回头再说，先把机器人搭起来\n正式开发 我们使用 QQ 机器人的 Python sdk\n1 pip install qq-botpy 注意 python 版本要在 3.8 以上哦\n预览整个结构\n超级简单\n整合的功能 KIMI 的大模型能力 先去看看 kimi 的 api 文档\n1 2 3 4 5 6 7 8 9 10 11 curl https://api.moonshot.cn/v1/chat/completions \\ -H \u0026#34;Content-Type: application/json\u0026#34; \\ -H \u0026#34;Authorization: Bearer $MOONSHOT_API_KEY\u0026#34; \\ -d \u0026#39;{ \u0026#34;model\u0026#34;: \u0026#34;moonshot-v1-8k\u0026#34;, \u0026#34;messages\u0026#34;: [ {\u0026#34;role\u0026#34;: \u0026#34;system\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;你是 Kimi，由 Moonshot AI 提供的人工智能助手，你更擅长中文和英文的对话。你会为用户提供安全，有帮助，准确的回答。同时，你会拒绝一切涉及恐怖主义，种族歧视，黄色暴力等问题的回答。Moonshot AI 为专有名词，不可翻译成其他语言。\u0026#34;}, {\u0026#34;role\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;你好，我叫李雷，1+1等于多少？\u0026#34;} ], \u0026#34;temperature\u0026#34;: 0.3 }\u0026#39; 简单封装一下（文件名：nature_ai.py）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import requests from botpy import logging import time _log = logging.get_logger() apiKey = \u0026#39;你自己的apiKey\u0026#39; headers = { \u0026#34;ai\u0026#34;:{ \u0026#39;User-Agent\u0026#39;: \u0026#39;Apifox/1.0.0 (https://apifox.com)\u0026#39;, \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39;, \u0026#39;Authorization\u0026#39;: f\u0026#39;Bearer {apiKey}\u0026#39; } } urls = { \u0026#34;ai\u0026#34;:\u0026#34;https://api.moonshot.cn/v1/chat/completions\u0026#34; } def post_to_ai(context): header = headers.get(\u0026#39;ai\u0026#39;) data = { \u0026#34;model\u0026#34;: \u0026#34;moonshot-v1-8k\u0026#34;, \u0026#34;messages\u0026#34;: [ {\u0026#34;role\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;content\u0026#34;: context} ] } base_url = urls.get(\u0026#39;ai\u0026#39;) replay = requests.post(base_url, headers=header, json=data).json() return replay 睿声 AI 的 mp3 生成功能 这个 AI 可厉害了，能输出雷军语音呢（笑）\n看看睿声 AI 的 api 文档\n由于资金问题，我挑选了这两条（好多不给用，呜呜呜~~~~）\n看看 curl\n1 2 3 4 5 6 7 8 9 10 11 12 curl --location --request POST \u0026#39;https://v1.reecho.cn/api/tts/generate\u0026#39; \\ --header \u0026#39;User-Agent: Apifox/1.0.0 (https://apifox.com)\u0026#39; \\ --header \u0026#39;Content-Type: application/json\u0026#39; \\ --header \u0026#39;Authorization: Bearer ????????\u0026#39; \\ --data-raw \u0026#39;{ \u0026#34;contents\u0026#34;: [ { \u0026#34;voiceId\u0026#34;: \u0026#34;雷军id\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;大家好，我是雷军\u0026#34; } ] }\u0026#39; 1 2 3 curl --location --request GET \u0026#39;https://v1.reecho.cn/api/tts/generate/?limit\u0026amp;offset\u0026amp;status\u0026amp;stream\u0026#39; \\ --header \u0026#39;User-Agent: Apifox/1.0.0 (https://apifox.com)\u0026#39; \\ --header \u0026#39;Authorization: Bearer ????????\u0026#39; voiceId 是自己添加的语音模型，可在自己的控制台复制\n？写自己的 API KEY\n看看响应\n1 2 3 4 { \u0026#34;status\u0026#34;: 403, \u0026#34;message\u0026#34;: \u0026#34;Insufficient Credit, Please recharge first. 余额不足,请前往增值商店充值.\u0026#34; } 额。。。\n重新来\n1 2 3 4 5 6 7 8 9 10 11 { \u0026#34;status\u0026#34;: 200, \u0026#34;message\u0026#34;: \u0026#34;OK\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;fe8eccdc-41d7-4c5e-a45f-f6744ba59699\u0026#34;, \u0026#34;userId\u0026#34;: \u0026#34;f84e43a0-9ec0-4ff6-942f-354024350246\u0026#34;, \u0026#34;status\u0026#34;: \u0026#34;pending\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;reecho-neural-voice-001\u0026#34;, \u0026#34;metadata\u0026#34;: { ...... ...... 好长，但是我们要的是这个 id\n拿到id\n请求一下 get\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 { \u0026#34;status\u0026#34;: 200, \u0026#34;message\u0026#34;: \u0026#34;OK\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;fe8eccdc-41d7-4c5e-a45f-f6744ba59699\u0026#34;, \u0026#34;userId\u0026#34;: \u0026#34;f84e43a0-9ec0-4ff6-942f-354024350246\u0026#34;, \u0026#34;status\u0026#34;: \u0026#34;generated\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;reecho-neural-voice-001\u0026#34;, \u0026#34;metadata\u0026#34;: { \u0026#34;contents\u0026#34;: [ { \u0026#34;voiceId\u0026#34;: \u0026#34;market:167b4212-c032-4f42-98fa-15293584aa51\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;大家好，我是雷军\u0026#34;, \u0026#34;audio\u0026#34;: \u0026#34;https://voc-public-storage.reecho.cn/generate/fe8eccdc-41d7-4c5e-a45f-f6744ba59699/fe8eccdc-41d7-4c5e-a45f-f6744ba59699-0-0yivct.mp3\u0026#34;, \u0026#34;duration\u0026#34;: 2.5861, \u0026#34;generatedAt\u0026#34;: \u0026#34;2024-11-03T14:18:19.745Z\u0026#34; } ..... ..... 更长了，但是没关系，我们拿到了 MP3 地址\n太好了，简单封装一下（voice_ai.py）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 import requests from botpy import logging import time _log = logging.get_logger() voiceIdMap = { \u0026#34;lei/\u0026#34;:\u0026#34;167b4212-c032-4f42-98fa-15293584aa51\u0026#34;, \u0026#34;sun/\u0026#34;:\u0026#34;69623557-9b41-46b0-96b6-7e38705d8074\u0026#34; } voiceApiKey = \u0026#39;？？？？？？？？\u0026#39; headers = { \u0026#34;mp3\u0026#34;:{ \u0026#39;User-Agent\u0026#39;: \u0026#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36\u0026#39;, \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39; }, \u0026#34;voice_ai\u0026#34;:{ \u0026#39;User-Agent\u0026#39;: \u0026#39;Apifox/1.0.0 (https://apifox.com)\u0026#39;, \u0026#39;Authorization\u0026#39;: f\u0026#39;Bearer {voiceApiKey}\u0026#39;, \u0026#39;Accept\u0026#39;: \u0026#39;*/*\u0026#39;, \u0026#39;Host\u0026#39;: \u0026#39;v1.reecho.cn\u0026#39;, \u0026#39;Connection\u0026#39;: \u0026#39;keep-alive\u0026#39; } } urls = { \u0026#34;voice_ai_get_id\u0026#34;:\u0026#34;https://v1.reecho.cn/api/tts/generate\u0026#34;, \u0026#34;voice_ai_get_mp3_url\u0026#34;:\u0026#34;https://v1.reecho.cn/api/tts/generate/\u0026#34; } def download_mp3(mp3_url) : header = headers.get(\u0026#39;mp3\u0026#39;) res = requests.get(mp3_url, stream=True, headers=header) while res.status_code != 200: res = requests.get(mp3_url, stream=True, headers=header) _log.info(\u0026#34;重试\u0026#34;) return res def voice_ai_get_id(context, pre): base_url = urls.get(\u0026#39;voice_ai_get_id\u0026#39;) header = headers.get(\u0026#39;voice_ai\u0026#39;) data = { \u0026#34;contents\u0026#34;: [ { \u0026#34;voiceId\u0026#34;: voiceIdMap.get(pre), \u0026#34;text\u0026#34;: context } ] } id_info = requests.post(base_url, headers=header,json=data).json() return id_info def voice_ai_get_mp3_url(id_info): _log.info(id_info) param_value = id_info.get(\u0026#39;data\u0026#39;).get(\u0026#39;id\u0026#39;) base_url = urls.get(\u0026#39;voice_ai_get_mp3_url\u0026#39;) + param_value header = headers.get(\u0026#39;voice_ai\u0026#39;) response = requests.get(base_url, headers=header).json() while response.get(\u0026#39;data\u0026#39;).get(\u0026#39;status\u0026#39;) != \u0026#39;generated\u0026#39; : time.sleep(5) response = requests.get(base_url, headers=header).json() mp3_url = response.get(\u0026#39;data\u0026#39;).get(\u0026#39;metadata\u0026#39;).get(\u0026#39;contents\u0026#39;)[0].get(\u0026#39;audio\u0026#39;) return mp3_url 写博客的时候才发现，原来两个 url 是同一个，草率了，不过问题不大\n这里有个细节，我们的 MP3 需要下载下来，因为 qq 支持的语音文件是 silk 格式，我们需要转码后再用 nginx 将资源暴露出去，获取新的 silk 的url\n最后的运行文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 # -*- coding: utf-8 -*- import os import botpy from botpy import logging from botpy.message import C2CMessage, GroupMessage import utils.requests_utils.voice_ai as v_utils import utils.requests_utils.nature_ai as a_utils import hashlib import utils.mp3_utils.mp3 as mp3 host = \u0026#39;http://服务器ip地址/\u0026#39; _log = logging.get_logger() rootHome = \u0026#39;/home/download/\u0026#39; class MyClient(botpy.Client): async def on_ready(self): _log.info(f\u0026#34;robot 「{self.robot.name}」 on_ready!\u0026#34;) async def on_c2c_message_create(self, message: C2CMessage): # 雷军语音 if message.content.startswith(\u0026#39; #雷军语音 \u0026#39;) or message.content.startswith(\u0026#39; #孙狗语音 \u0026#39;): hash_object = hashlib.sha256(message.content[6:].encode()) hash_hex = hash_object.hexdigest() pre = \u0026#39;\u0026#39; if message.content.startswith(\u0026#39; #雷军语音 \u0026#39;): pre = \u0026#39;lei/\u0026#39; elif message.content.startswith(\u0026#39; #孙狗语音 \u0026#39;): pre = \u0026#39;sun/\u0026#39; leiHome = rootHome + pre filename = leiHome + hash_hex if not os.path.exists(filename + \u0026#39;.mp3\u0026#39;) : context = message.content[6:] if len(context) == 0: await message._api.post_c2c_message( openid=message.author.user_openid, msg_type=0, msg_id=message.id, content=\u0026#34;请输入语音内容\u0026#34;) return # 异步执行任务，获取对应任务 id id_info = v_utils.voice_ai_get_id(context,pre) # 获取任务结束后的 MP3 地址 mp3_url = v_utils.voice_ai_get_mp3_url(id_info) # 下载对应 MP3 mp3.downloadMp3(mp3_url, filename) mp3.convert_to_silk(filename + \u0026#39;.mp3\u0026#39;, leiHome) _log.info(leiHome) new_url = host + pre + hash_hex + \u0026#39;.silk\u0026#39; _log.info(f\u0026#39;new url: {new_url}\u0026#39;) uploadMedia = await message._api.post_c2c_file( openid=message.author.user_openid, file_type=3, # 文件类型要对应上，具体支持的类型见方法说明 url=new_url # 文件Url ) _log.info(\u0026#39;上传成功\u0026#39;) await message._api.post_c2c_message( openid=message.author.user_openid, msg_type=7, # 7表示富媒体类型 msg_id=message.id, media=uploadMedia ) # ai else: user_message = message.content replay = a_utils.post_to_ai(user_message) await message._api.post_c2c_message( openid=message.author.user_openid, msg_type=0, msg_id=message.id, content=f\u0026#34;{replay.get(\u0026#39;choices\u0026#39;)[0].get(\u0026#39;message\u0026#39;).get(\u0026#39;content\u0026#39;)}\u0026#34; ) async def on_group_at_message_create(self, message: GroupMessage): # ai if message.content.startswith(\u0026#39; #雷军语音 \u0026#39;) or message.content.startswith(\u0026#39; #孙狗语音 \u0026#39;): _log.info(\u0026#34;进来了\u0026#34;) hash_object = hashlib.sha256(message.content[6:].encode()) hash_hex = hash_object.hexdigest() pre = \u0026#39;\u0026#39; if message.content.startswith(\u0026#39; #雷军语音 \u0026#39;): pre = \u0026#39;lei/\u0026#39; elif message.content.startswith(\u0026#39; #孙狗语音 \u0026#39;): pre = \u0026#39;sun/\u0026#39; leiHome = rootHome + pre filename = leiHome + hash_hex if not os.path.exists(filename + \u0026#39;.mp3\u0026#39;): context = message.content[6:] if len(context) == 0: await message._api.post_c2c_message( openid=message.author.user_openid, msg_type=0, msg_id=message.id, content=\u0026#34;请输入语音内容\u0026#34;) return # 异步执行任务，获取对应任务 id id_info = v_utils.voice_ai_get_id(context, pre) # 获取任务结束后的 MP3 地址 mp3_url = v_utils.voice_ai_get_mp3_url(id_info) # 下载对应 MP3 mp3.downloadMp3(mp3_url, filename) mp3.convert_to_silk(filename + \u0026#39;.mp3\u0026#39;, leiHome) new_url = host + pre + hash_hex + \u0026#39;.silk\u0026#39; _log.info(f\u0026#39;new url: {new_url}\u0026#39;) uploadMedia = await message._api.post_group_file( group_openid=message.group_openid, file_type=3, # 文件类型要对应上，具体支持的类型见方法说明 url=new_url # 文件Url ) _log.info(\u0026#39;上传成功\u0026#39;) await message._api.post_group_message( group_openid=message.group_openid, msg_type=7, # 7表示富媒体类型 msg_id=message.id, media=uploadMedia ) else: user_message = message.content replay = a_utils.post_to_ai(user_message) messageResult = await message._api.post_group_message( group_openid=message.group_openid, msg_type=0, msg_id=message.id, content=f\u0026#34;{replay.get(\u0026#39;choices\u0026#39;)[0].get(\u0026#39;message\u0026#39;).get(\u0026#39;content\u0026#39;)}\u0026#34;) _log.info(messageResult) if __name__ == \u0026#34;__main__\u0026#34;: # 通过预设置的类型，设置需要监听的事件通道 # intents = botpy.Intents.none() # intents.public_messages=True # 通过kwargs，设置需要监听的事件通道 intents = botpy.Intents(public_messages=True) client = MyClient(intents=intents) client.run(appid=\u0026#39;????\u0026#39;, secret=\u0026#39;????\u0026#39;) 最后的 appid 和 secret 都是机器人的参数，我们一开始拿到的那几个\n这里的具体内容不再介绍，都是 QQ 机器人 的 SDK\n文件类型啥的都可以在方法中找到注释\n贴上 github 地址：https://github.com/tencent-connect/botpy\n到此为止，我们实现了雷军语音的生成和 AI 问答的qq机器人，实在是太厉害了吧^_^\n展示 ","date":"2024-11-03T21:20:55+08:00","image":"https://akaxedx.github.io/p/qq%E5%AE%98%E6%96%B9%E6%9C%BA%E5%99%A8%E4%BA%BA/zoe_hu4603846773094741746.jpg","permalink":"https://akaxedx.github.io/p/qq%E5%AE%98%E6%96%B9%E6%9C%BA%E5%99%A8%E4%BA%BA/","title":"QQ官方机器人"},{"content":"面试题刷题记录 操作系统 什么是用户态和内核态 用户态是内核态是操作系统种的两种运行模式，他们描述了不同的权限级别和访问方式\n用户态 在用户态下，程序只能访问有限的资源和功能，如内存，寄存器等 用户态下的程序不能直接操作系统核心部分，例如对硬件的直接访问 大多数应用程序在用户态下运行，包括常见的软件如浏览器、文字处理器等 内核态 在内核态下，操作系统的核心部分，如调度程序、内存管理器等，在内核态下运行 用户态和内核态之间的切换由操作系统控制，通常发生在系统调用、中端或异常处理等情况下。当一个程序需要访问操作系统提供的服务或者请求更高权限时，会触发从用户态到内核态的切换，这种切换的开销相对较高，因为涉及到保存和恢复进程的状态\n进程之间的通信方式 无名管道：管道是一种单向通信方式，用在父进程和子进程之间或者同一主机上不同进程之间传递数据 命名管道：与匿名管道类似，但具有一个在文件系统种有名的路径，允许不相关的进程之间进行通信 消息队列：消息队列允许一个进程向另一个进程发送消息，消息在队列种按顺序存储，并且接收方可以按需接收 共享内存：共享内存允许多个进程访问同一块内存区域，从而实现快速的数据交换。但需要注意同步问题，以避免竞态条件和数据一致性问题 信号量：信号量是一种同步原语， 用于管理对共享资源的访问。它可以用于实现进程的互斥访问和同步操作 套接字：套接字允许在网络上的不同主机上的进程进行通信，是实现网络通信的基础 文件：进程可以通过读写文件来进行通信，这种方式通常用于进程之间的间接通信，例如使用临时文件或者共享文件 可以根据不同场景选取不同的通信方式\n进程有哪几种状态 就绪态：进程已经准备好运行，但还未被调度执行。通常是因为等待 CPU 时间片而处于等待状态 运行态：进程正在 CPU 上执行指令，处于活跃状态 阻塞态：进程因为某些原因（如等待 I/O 完成，等待某个事件发生等）暂时无法执行，进入阻塞状态，直到条件满足后才能重更新进入就绪态 创建态：进程正在被创建，操作系统正在为其分配资源 终止态：进程已经执行完毕，或者被操作系统提前终止，处于结束状态。在结束后，操作系统会回收其占用的资源 进程的调度算法 进程调度算法种类 先来先服务：非抢占式调度算法，桉树徐进行调度，短作业等待时间会由与前面长作业过长导致过长 短作业优先服务：根据进程的执行时间长度来进行调度。执行时间最短的进程优先被调度，所以可能导致“长作业饥饿”问题 最短剩余时间优先：按剩余运行时间的顺序进行调度，因为 CPU 时间片非常短暂（毫秒），一个任务不会立刻被执行完毕，因此当由一个新作业到达时，将整个运行时间和当进程的剩余时间进行比较，如果新进程需要的时间更少，就挂起当前运行的进程，优先运行新进程 时间片轮转调度算法：所有进程按先来先服务排成队列，CPU 时间片优先给队首进程，执行一个时间片，时间片用完，时钟中断，改队首进程停止，送到队尾，此时第二个进程被送到队首，但是时间片大小的控制十分重要 优先级调度：每个进程分配日一个优先级，优先级调度算法 多级反馈队列：时间片轮转 + 优先级调度，多个队列时间片大小不同，每个队列的优先级也不同，可以根据实际情况进行调整 进程调用函数 fork() 创建一个新的进程，新进程时调用进程的副本（子进程），并行执行。子进程复制了父进程的内存空间、代码段、数据段等内容 exec() 系列函数 （execvp，execlp 等） 加载并执行一个新的程序文件，替换当前进程的地址空间和代码段为新程序的地址空间和代码段。常用于在一个进程中执行另一个程序 wait() 或 waitpid() 父进程调用 wait() 或 waitpid() 函数来等待子进程的终止，并获取子进程的终止状态，返回值：成功时返回终止的子进程 ID，失败时返回 -1 exit() 终止当前进程的执行，释放进程所占用的资源，并返回退出状态给父进程。参数：可以指定一个退出状态码，用于告知父进程当前进程的执行情况 kill() 向指定的进程发送信号，用于终止进程、改变进程的行为等，参数：需要指定要发送的信号及接收信号的进程 ID signal() 为当前进程安装信号处理器，用于处理接收到的各种信号，参数：指定信号的类型以及信号处理函数 这些进程调用函数为操作系统提供了对进程的创建、执行、控制和终止等基本操作的支持，使得操作系统能够有效地管理进程，并实现进程之间的通信和协作\n什么是软中断，什么是硬中断 软中断 是由软件或 CPU 指令生成的中断。软中断是由操作系统或者应用程序通过特殊的软件指令来触发的，例如系统调用（syscall）硬中断处理那些短时间就可以完成的工作，而将那些处理时间比较长的工作，放到中断之后来完成，也就是软中断\n硬中断 硬中断是由硬件设备（比如网卡、硬盘）发出的中断信号，用于通知 CPU 发生了某个事件，需要处理。当外部设备需要 CPU 的注意时，它会发送一个硬件中断信号给 CPU，CPU 会停止当前执行的程序，转而执行与该中断相关的 中断处理程序\n区别 引发对象：硬中断是由外设引发的，软中断是执行中断指令产生的，无需外部施加中断请求信号 提供中断信号：硬中断的中断信号是由中断控制器提供的，软中断的中断信号是由指令直接指出，无需使用中断控制器 耗时：硬中断处理程序要确保它能快速地完成任务，这样程序执行时才不会等待较长时间，称为上半部。软中断处理硬中断未完成的工作是一种推后执行的机制，属于下半部 什么是分段，什么是分页 MMU 将虚拟地址翻译为物理地址的主要机制其中两种就是分段和分页\n分段 将逻辑地址空间分为若干个不同长度的段，每个段代表程序中的一个逻辑单元，例如代码段，数据段，堆栈段。分段机制下的虚拟地址是两部分构成：段号和段内偏移量 分页 分页将逻辑地址空间和物理内存空间划分为固定大小的页，通常为连续 2 的幂大小，如 2 kb，4 MB。分页机制下的虚拟地址由两部分组成：页号和页内偏移量 区别 都是非连续内存管理的方式 都是将虚拟地址映射到物理地址的机制不同 分段会有外部内存碎片片 分页是从内存利用率的角度进行考虑，分段是从用户角度进行考虑，用于数据保护 分页的大小固定，由操作系统决定，分段大小不确定，由用户程序决定 常用的 Linux 命令 ls：列出目录中的文件和子目录 cd：切换当前工作目录 pwd：显示当前工作目录的路径 mkdir：创建新文件夹 rm：删除文件或目录 cp：复制文件或目录 mv：移动文件或目录 cat：连接文件并打印到标准输出 grep：在文件中搜索指定模式 nano / vim：文件编辑器 chmod：修改文件权限 chown：修改文件的所有者和所属组 tar：打包和解包文件 gzip 或 gunzip：压缩和解压缩文件 top：显示系统中正在运行的进程和系统资源的使用情况 ps：显示当前运行的进程 kill：终止进程 ifconfig / ip：配置网络接口信息 ping：测试与另一个主机的网络连接 ssh：通过安全的远程连接协议登录到远程主机 I/O 到底是什么 input 和 output 的缩写，即输入/输出\n我们关注的 I/O 其实指的是磁盘 I/O，读取本地文件的时候，要将磁盘的数据拷贝到内存中，修改本地文件时，需要把修改后的数据拷贝到磁盘中\n网络 I/O 指的是网卡与内存之间的输入输出，当网上的数据到来时，网卡需要将数据拷贝到内存中，当要发送数据给网络上的其他人时，需要将数据从内存拷贝到网卡里\n为什么都要和内存交互呢\n我们的指令最终是由 CPU 执行的，究其原因是 CPU 与内存交互的速度远高于 CPU 和这些外部设备直接交互的速度。因此都和内存交互，当然假设没有内存， 让 CPU 直接和外部设备交互，也是 I/O\nDMA DMA 是一种用于高效数据传输的技术，它允许外围设备（如硬盘，网络接口，声卡等）直接与系统内存进行数据交换，而无需经过 CPU 的干预。DMA 在提高数据传输效率、降低 CPU 负载方面起到了关键作用\nDMA 工作原理 在没有 DMA 的情况下，数据传输通常依赖于 CPU 来中转数据。这意味着每次从设备向内存传输数据时，数据首先要通过 CPU，然后再写入内存，反之亦然，这种方式效率较低，因为 CPU 需要参与每次数据传输，可能导致性能瓶颈\nDMA 技术通过引入一个独立的 DMA 控制器来解决这个问题，DMA 控制器可以直接控制数据从设备到内存（或从内存到设备）的传输，无需 CPU 的参与这种方式极大地减少了 CPU 的负载，使其能够专注于其他任务\nDMA 的主要步骤 配置 DMA 控制器：CPU 首先需要将 DMA 传输任务配置给 DMA 控制器，包括源地址、目标地址、传输的字节数等参数 启动 DMA 传输：一旦配置完成，DMA 控制器接管传输任务，并开始将数据直接从源设备搬运到目标内存位置，或从内存搬运到设备 传输完成：当 DMA 控制器完成传输后，它通常会通过中断通知 CPU，表示数据传输已经成功，传输过程中，CPU 几乎不用介入 DMA 的优势 降低 CPU 负载：DMA 使得 CPU 不必参与每次数据传输，从而减少了 CPU 的工作负担，使其能够执行更多的计算任务或处理其他高优先级任务 提高数据传输效率：由于数据再设备和内存之间直接传输，避免了 CPU 作为中间人的瓶颈，从而提高了整体数据传输速率 并行处理：DMA 允许数据传输与 CPU 执行其他人物并行进行，从而提高了系统的并行处理能力和总体性能 DMA 的类型 DMA 有很多类型，适用于不同应用场景\n单通道 DMA：这种类型的 DMA 控制器一次只能处理一个数据传输任务 多通道 DMA：支持同时处理多个数据传输任务，每个通道可以配置不同的源和目标地址 突发模式 DMA：DMA 控制器在传输数据时会一次传输多个字节的数据，称为“突发”，这减少了 DMA 对系统总线的占用时间 循环模式 DMA：允许在多个缓冲区之间循环传输数据，常用于音频和视频数据流的连续处理 DMA 的应用 DMA 广泛应用于需要大量数据传输的场景中，特别是在需要高效利用资源的情况下\n磁盘 I/O：硬盘读取或写入数据时使用 DMA 可以减少 CPU 的干预，提高磁盘 I/O 的速度 网络传输：网络接口卡（NIC）通过 DMA 直接将接收到的数据写入内存，或从内存中读取数据并发送出去 音视频处理：在音频、视频数据流传输过程中，DMA 能够保证数据的连续性，避免数据丢失或传输延迟 为什么网络 I/O 会被阻塞 数据传输速度不均衡：在网络通信中，发送方和接收方的数据传输速度可能不一致。当发送方发送数据快于接收方处理数据的速度时，接收方的缓冲区可能会慢，导致发送方的 I/O 操作被阻塞，直到接收方处理完数据 网络阻塞：当网络中的流量过大或网络传输带宽不足时，会导致网络拥塞。在拥塞的情况下，数据包的传输可能会延迟或丢失，导致发送方的 I/O 操作被阻塞 阻塞式 I/O 操作：在一些传统的网络编程模型中，例如阻塞式 I/O ，当进行网络读取或写入操作时，程序会一直等待直到数据就绪或发送完成。这种模型下，I/O 操作时同步阻塞的，会导致程序在等待数据的过程中被阻塞 低效的处理方式：当程序在处理 I/O 操作时，可能存在一些低效的处理方式，例如使用循环轮询来检查数据的就绪状态。这种方式会导致 CPU 资源浪费，并且在等待数据就绪时会导致 I/O 操作阻塞 网络延迟：数据在网络中传输需要一定的时间，称为网络延迟。当数据在传输过程中受到延迟，程序可能会在等待数据返回时被阻塞 解决方案\n多线程处理：使用多线程可以在进行网络通信时不阻塞主线程，从而提高程序的并发性能。通过将网络 I/O 操作放在单独的线程中进行，可以避免主线程被阻塞 非阻塞 I/O （NIO）：使用非阻塞 I/O 技术，程序可以在进行网络通信时立即返回，而不必等待数据返回。通过轮询或事件驱动方式，程序可以检查是否有数据可用，从而实现异步的通信网络 异步 I/O （AIO）：异步 I/O 允许程序在进行网络通信时不必等待数据的返回，而是通过回调或事件通知的方式在数据到达时进行处理。这种方式可以提高程序的并发性能和响应速度 使用缓存和流控制：使用缓存可以减少对网络的频繁访问，提高了数据的读取和写入效率。同时，合理地使用流控制机制可以调整数据的传输速率，避免网络拥塞和阻塞 同步和异步的区别 同步和异步指的是：当前线程是否需要等待方法调用执行完毕\n比如搬 100 个石头\n同步指的是调用这个方法，你的线程需要等待这 100 个石头搬完 异步指的是调用这个方法，立马就直接返回，不必等候这 100 个石头，然后利用回调或者事件通知的方式得到石头已经搬完的结果 阻塞和非阻塞的区别 阻塞和非阻塞指的是：当前接口数据还未准备就绪时，线程是否被阻塞挂起\n区别在于有没有让出 CPU\n什么是 BIO、NIO、AIO BIO、NIO、AIO 都是 Java 的 IO 模型\nBIO 是传统的 IO 模型，在读写数据时会阻塞线程，适用于 并发不高 的场景\nNIO 是 Java 的新 IO 模型，它在读写数据时不会阻塞线程，而是通过轮询的方式检查是否有数据可读写，适用于 并发量较高 的场景\nAIO 是 JDK 7 开始引入的新 IO 模型，它的读写方式于 NIO 相似，但在读写数据时，不需要自己手动轮询是否有数据可读写，交由系统完成\n","date":"2024-10-10T17:15:57+08:00","image":"https://akaxedx.github.io/p/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/zoe_hu6461440272994704320.jpg","permalink":"https://akaxedx.github.io/p/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/","title":"面试刷题记录"},{"content":"","date":"2024-10-02T14:55:50+08:00","image":"https://akaxedx.github.io/p/juc-%E9%9D%A2%E8%AF%95%E9%A2%98/Cache_37c8ac0d46ec4b3f_hu16652789058116888037.jpg","permalink":"https://akaxedx.github.io/p/juc-%E9%9D%A2%E8%AF%95%E9%A2%98/","title":"JUC 面试题"},{"content":"JVM 详解 JVM 内存管理 在之前，我们了解了 JVM 的大致运作原理以及相关特性，这一章，我们首先会从内存管理说起。\n在传统的 C/C++ 开发中，我们经常通过使用申请内存的方式来创建对象或是存放某些数据，但是这样也带来了一些额外的问题，我们要在何时释放这些内存，怎么才能使得内存的使用最高效，因此，内存管理是一个非常严肃的问题。\n比如我们就可以通过 C 语言动态申请内存，并用于存放数据：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; int main(){ //动态申请4个int大小的内存空间 int* memory =malloc(sizeof(int) * 4); //修改第一个int空间的值 memory[0] = 10; //修改第二个int空间的值 memory[1] =2; //遍历内存区域中所有的值 for (int i= 0;i \u0026lt; 4;i++){ printf(\u0026#34;%d \u0026#34;, memory[i]); } //释放指针所指向的内存区域 free(memory); //最后将指针赋值为NULL memory = NULL; } 而在 Java 中，这种操作实际上是不允许的，Java 只支持直接使用基本数据类型和对象类型，至于内存到底如何分配，并不是由我们来处理，而是 JVM 帮助我们进行控制，这样就帮助我们节省很多内存上的工作，虽然带来了很大的便利，但是，一旦出现内存问题，我们就无法像 C/C++ 那样对所管理的内存进行合理地处理，因为所有的内存操作都是由 JVM 在进行，只有了解了 JVM 的内存管理机制，我们才能够在出现内存相关问题时找到解决方案。\n内存区域划分 既然要管理内存，那么肯定不会是杂乱无章的，JVM 对内存的管理采用的是分区治理，不同的内存区域有着各自的职责所在，在虚拟机运行时，内存区域如下划分：\n我们可以看到，内存区域一共分为5个区域，其中方法区和堆是所有线程共享的区域，随着虚拟机的创建而创建，虚拟机的结束而销毁，而虚拟机栈、本地方法栈、程序计数器都是线程之间相互隔离的，每个线程都有一个自己的区域，并且线程启动时会自动创建，结束之后会自动销毁。内存划分完成之后，我们的 JVM 执行引擎和本地库接口，也就是 Java 程序开始运行之后就会根据分区合理地使用对应区域的内存了。\n大致划分 程序计数器 首先我们来介绍一下程序计数器，它和我们的传统 8086 CPU 中 PC 寄存器的工作差不多，因为 JVM 虚拟机目的就是实现物理机那样的程序执行。在 8086 CPU 中，PC 作为程序计数器，负责储存内存地址，该地址指向下一条即将执行的指令，每解释执行完一条指令，PC 寄存器的值就会自动被更新为下一条指令的地址，进入下一个指令周期时，就会根据当前地址所指向的指令，进行执行。\n而 JVM 中的程序计数器可以看做是当前线程所执行字节码的行号指示器，而行号正好就指的是某一条指令，字节码解释器在工作时也会改变这个值，来指定下一条即将执行的指令。\n因为 Java 的多线程也是依靠时间片轮转算法进行的，因此一个 CPU 同一时间也只会处理一个线程，当某个线程的时间片消耗完成后，会自动切换到下一个线程继续执行，而当前线程的执行位置会被保存到当前线程的程序计数器中，当下次轮转到此线程时，又继续根据之前的执行位置继续向下执行。\n程序计数器因为只需要记录很少的信息，所以只占用很少一部分内存。\n虚拟机栈 虚拟机栈就是一个非常关键的部分，看名字就知道它是一个栈结构，每个方法被执行的时候，Java 虚拟机都会同步创建一个栈帧(其实就是栈里面的一个元素)，栈帧中包括了当前方法的一些信息，比如局部变量表、操作数栈、动态链接、方法出口等。\n其中局部变量表就是我们方法中的局部变量，之前我们也进行过演示，实际上局部变量表在class文件中就已经定义好了，操作数栈就是我们之前字节码执行时使用到的栈结构；每个栈帧还保存了一个可以指向当前方法所在类的运行时常量池、目的是：当前方法中如果需要调用其他方法的时候，能够从运行时常量池中找到对应的符号引用，然后将符号引用转换为直接引用，然后就能直接调用对应方法，这就是动态链接（我们还没讲到常量池，暂时记住即可，建议之后再回顾一下），最后是方法出口，也就是方法该如何结束,是抛出异常还是正常返回。\n可能听起来有点懵逼，这里我们来模拟一下整个虚拟机栈的运作流程，我们先编写一个测试类:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class Main { public static void main(String[] args){ int res = a(); System.out.println(res); } public static int a(){ return b(); } public static int b(){ return c(); } public static int c(){ int a= 10; int b = 20; return a + b; } } 当我们的主方法执行后，会依次执行三个方法a() -\u0026gt; b() -\u0026gt; c() -\u0026gt;返回 ，我们首先来观察一下反编译之后的结果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 { public Main(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.\u0026#34;\u0026lt;init\u0026gt;\u0026#34;:()V 4: return LineNumberTable: line 1: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this LMain; public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=2, args_size=1 0: invokestatic #7 // Method a:()I 3: istore_1 4: getstatic #13 // Field java/lang/System.out:Ljava/io/PrintStream; 7: iload_1 8: invokevirtual #19 // Method java/io/PrintStream.println:(I)V 11: return LineNumberTable: line 4: 0 line 5: 4 line 6: 11 LocalVariableTable: Start Length Slot Name Signature 0 12 0 args [Ljava/lang/String; 4 8 1 res I public static int a(); descriptor: ()I flags: ACC_PUBLIC, ACC_STATIC Code: stack=1, locals=0, args_size=0 0: invokestatic #25 // Method b:()I 3: ireturn LineNumberTable: line 8: 0 public static int b(); descriptor: ()I flags: ACC_PUBLIC, ACC_STATIC Code: stack=1, locals=0, args_size=0 0: invokestatic #28 // Method c:()I 3: ireturn LineNumberTable: line 11: 0 public static int c(); descriptor: ()I flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=2, args_size=0 0: bipush 10 2: istore_0 3: bipush 20 5: istore_1 6: iload_0 7: iload_1 8: iadd 9: ireturn LineNumberTable: line 14: 0 line 15: 3 line 16: 6 LocalVariableTable: Start Length Slot Name Signature 3 7 0 a I 6 4 1 b I } 可以看到在编译之后，我们整个方法的最大操作数栈深度、局部变量表都是已经确定好的，当我们程序开始执行时，会根据这些信息封装为对应的栈帧，我们从 main 方法开始看起：\n接着我们继续往下，到了0: invokestatic\t#7\t// Method a:()I 时，需要调用方法 a()，这时当前方法就不会继续向下运行了，而是去执行方法 a() ，那么同样的，将此方法也入栈，注意是放入到栈顶位置， main 方法的栈帧会被压下去:\n这时，进入方法a之后，又继而进入到方法b，最后在进入c，因此，到达方法c的时候，我们的虚拟机栈变成了：\n现在我们依次执行方法 c 中的指令，最后返回 a+b 的结果，在方法 c 返回之后，也就代表方法 c 已经执行结束了，栈帧 4会自动出栈，这时栈帧 3 就得到了上一栈帧返回的结果，并继续执行，但是由于紧接着马上就返回，所以继续重复栈帧 4 的操作，此时栈帧 3 也出栈并继续将结果交给下一个栈帧 2 ，最后栈帧 2 再将结果返回给栈帧 1，然后栈帧 1 就可以继续向下运行了，最后输出结果。\n本地方法栈 本地方法栈与虚拟机栈作用差不多，但是它是为本地方法准备的，这里不多做介绍。\n堆 堆是整个 Java 应用程序共享的区域，也是整个虚拟机最大的一块内存空间，而此区域的职责就是存放和管理对象和数组，而我们马上要提到的垃圾回收机制也是主要作用于这一部分内存区域。\n方法区 方法区也是整个 Java 应用程序共享的区域，它用于存储所有的类信息、常量、静态变量、动态编译缓存等数据，可以大致分为两个部分，一个是类信息表，一个是运行时常量池。方法区也是我们要重点介绍的部分。\n首先类信息表中存放的是当前应用程序加载的所有类信息，包括类的版本、字段、方法、接口等信息，同时会将编译时生成的常量池数据全部存放到运行时常量池中。当然，常量也并不是只能从类信息中获取，在程序运行时，也有可能会有新的常量进入到常量池。\n其实我们的 String 类正是利用了常量池进行优化，这里我们编写一个测试用例:\n1 2 3 4 5 6 public static void main(Stringl] args){ String str1 = new String(\u0026#34;abc\u0026#34;); String str2 = new String(\u0026#34;abc\u0026#34;); System.out.println(str1== str2); System.out.println(str1.equals(str2)); } 得到的结果也是显而易见的，由于 str1 和 str2 是单独创建的两个对象，那么这两个对象实际上会在堆中存放，保存在不同的地址：\n所以当我们使用 == 判断时，得到的结果 false，而使用 equals 时因为比较的是值，所以得到 true 。现在我们来稍微修改一下：\n1 2 3 4 5 6 public static void main(String[] args){ String str1 = \u0026#34;abc\u0026#34;; String str2 = \u0026#34;abc\u0026#34;; System.out.println(str1== str2); System.out.println(str1.equals(str2)); } 现在我们没有使用 new 的形式，而是直接使用双引号创建，那么这时得到的结果就变成了两个 true，这是为什么呢？这其实是因为我们直接使用双引号赋值，会先在常量池中查找是否存在相同的字符串，若存在，则将引用直接指向该字符串;若不存在，则在常量池中生成一个字符串，再将引用指向该字符串:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 Constant pool: #1 = Methodref #2.#3 // java/lang/Object.\u0026#34;\u0026lt;init\u0026gt;\u0026#34;:()V #2 = Class #4 // java/lang/Object #3 = NameAndType #5:#6 // \u0026#34;\u0026lt;init\u0026gt;\u0026#34;:()V #4 = Utf8 java/lang/Object #5 = Utf8 \u0026lt;init\u0026gt; #6 = Utf8 ()V #7 = String #8 // abc #8 = Utf8 abc #9 = Fieldref #10.#11 // java/lang/System.out:Ljava/io/PrintStream; #10 = Class #12 // java/lang/System #11 = NameAndType #13:#14 // out:Ljava/io/PrintStream; #12 = Utf8 java/lang/System #13 = Utf8 out #14 = Utf8 Ljava/io/PrintStream; #15 = Methodref #16.#17 // java/io/PrintStream.println:(Z)V #16 = Class #18 // java/io/PrintStream #17 = NameAndType #19:#20 // println:(Z)V #18 = Utf8 java/io/PrintStream #19 = Utf8 println #20 = Utf8 (Z)V #21 = Methodref #22.#23 // java/lang/String.equals:(Ljava/lang/Object;)Z #22 = Class #24 // java/lang/String #23 = NameAndType #25:#26 // equals:(Ljava/lang/Object;)Z #24 = Utf8 java/lang/String #25 = Utf8 equals #26 = Utf8 (Ljava/lang/Object;)Z #27 = Class #28 // Main #28 = Utf8 Main #29 = Utf8 Code #30 = Utf8 LineNumberTable #31 = Utf8 LocalVariableTable #32 = Utf8 this #33 = Utf8 LMain; #34 = Utf8 main #35 = Utf8 ([Ljava/lang/String;)V #36 = Utf8 args #37 = Utf8 [Ljava/lang/String; #38 = Utf8 str1 #39 = Utf8 Ljava/lang/String; #40 = Utf8 str2 #41 = Utf8 StackMapTable #42 = Class #37 // \u0026#34;[Ljava/lang/String;\u0026#34; #43 = Utf8 SourceFile #44 = Utf8 Main.java 被丢进了常量池\n实际上两次调用Sting类的 intern()方法，和上面的效果差不多，也是第一次调用会将堆中字符串复制并放入常量池中，第二次通过此方法获取字符串时，会查看常量池中是否包含，如果包含那么会直接返回常量池中字符串的地址：\n1 2 3 4 5 6 7 8 public static void main(String[] args){ //不能直接写\u0026#34;abc\u0026#34;，双引号的形式，写了就直接在常量池里面吧abc创好了 String str1 = new String(\u0026#34;ab\u0026#34;)+new String(\u0026#34;c\u0026#34;); String str2 = new String(\u0026#34;ab\u0026#34;)+new String(\u0026#34;c\u0026#34;); System.out.println(str1.inern()== str2.intern()); System.out.println(str1.equals(str2)); } 所以上述结果中得到的依然是两个 true 。在JDK1.7之后，稍微有一些区别，在调用 intern()方法时，当常量池中没有对应的字符串时，不会再进行复制操作，而是将其直接修改为指向当前字符串堆中的的引用：\n1 2 3 4 5 public static void main(String[] args) { // 不能直接写 \u0026#34;abc\u0026#34;，双引号的形式，写了就直接再常量池里面把 abc 创好了 String str1 = new String(\u0026#34;ab\u0026#34;) + new String(\u0026#34;c\u0026#34;); System.out.println(str1.intern() == str1); } 1 2 3 4 5 6 7 public static void main(String[] args) { String str1 = new String(\u0026#34;ab\u0026#34;) + new String(\u0026#34;c\u0026#34;); String str2 = new String(\u0026#34;ab\u0026#34;) + new String(\u0026#34;c\u0026#34;); System.out.println(str1.intern() == str1); System.out.println(str2.intern() == str1); } 所以最后我们会发现，str1.intern()和 str1 都是同一个对象，结果为 true 。\n值得注意的是，在 JDK7 之后，字符串常量池从方法区移动到了堆中。\n最后我们再来进行一个总结，各个内存区域的用途：\n（线程独有）程序计数器：保存当程序的执行位置 （线程独有）虚拟机栈：通过栈帧来维持方法调用顺序，帮助控制程序有序运行 （线程独有）本地方法栈：同上，作用于本地方法 堆：所有的对象和数组都在这里保存 方法区：类信息、即时编译器的代码缓存、运行时常量池。 当然，这些内存区域划分仅仅是概念上的，具体的实现过程我们后面还会提到\n爆内存和爆栈 实际上，在java程序运行时，内存容量不可能是无限制的，当我们的对象创建过多或是数组容量过大时，就会导致我们的堆内存不足以存放更多新的对象或是数组，这时就会出现错误，比如：\n1 2 3 public static void main(stringLl args){ int[] a= new int[Integer.MAX_VALUE]; } 这里我们申请了一个容量为21亿多的int型数组，显然，如此之大的数组不可能放在我们的堆内存中，所以程序运行时就会这样：\n1 2 Exception in thread \u0026#34;main\u0026#34; java.lang.0utOfMemoryError: Requested array size exceeds VM limit at com.test.Main.main(Main.java:5) 这里得到了一个 0ut0fMemoryError 错误，也就是我们常说的内存溢出错误。我们可以通过参数来控制堆内存的最大值和最小值：\n1 -Xms最小值 -Xmx最大值 比如我们现在限制堆内存为固定值 1M 大小，并且在抛出内存溢出异常时保存当前的内存堆转储快照：\n1 2 3 4 5 6 7 8 9 10 11 public class Main { public static void main(String[] args) { List\u0026lt;Test\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); while (true) { list.add(new Test()); } } static class Test{} } 在程序运行之后：\n1 2 3 4 5 6 7 8 9 10 11 java.lang.OutOfMemoryError: Java heap space Dumping heap to java_pid19916.hprof ... Heap dump file created [13463121 bytes in 0.029 secs] Exception in thread \u0026#34;main\u0026#34; java.lang.OutOfMemoryError: Java heap space at java.util.Arrays.copyOf(Arrays.java:3210) at java.util.Arrays.copyOf(Arrays.java:3181) at java.util.ArrayList.grow(ArrayList.java:267) at java.util.ArrayList.ensureExplicitCapacity(ArrayList.java:241) at java.util.ArrayList.ensureCapacityInternal(ArrayList.java:233) at java.util.ArrayList.add(ArrayList.java:464) at org.example.Main.main(Main.java:11) 可以看到错误出现原因正是 Java heap space，也就是堆内存满了，并且根据我们设定的 VM 参数，堆内存保存了快照信息。我们可以在 IDEA 内置的 Profiler 中进行查看:\n可以很明显地看到，在创建了 360146 个 Test 对象之后，堆内存蚌住了，于是就抛出了内存溢出错误。\n我们接着来看栈溢出，我们知道，虚拟机栈会在方法调用时插入栈帧，那么，设想如果出现无限递归的情况呢？\n1 2 3 4 5 6 7 8 9 10 public class Main { public static void main(String[] args) { test(); } public static void test() { test(); } } 这很明显是一个永无休止的程序，并且会不断继续向下调用 test() 方法本身，那么按照我们之前的逻辑推导，无限地插入栈帧，一定会将虚拟机栈塞满，所以，当栈的深度已经不足以插入栈帧时，就会这样：\n1 2 3 4 5 6 7 Exception in thread \u0026#34;main\u0026#34; java.lang.StackOverflowError at org.example.Main.test(Main.java:13) at org.example.Main.test(Main.java:13) at org.example.Main.test(Main.java:13) at org.example.Main.test(Main.java:13) at org.example.Main.test(Main.java:13) ...... 这也是我们常说的栈溢出，它和堆溢出比较类似，也是由于容纳不下才导致的，我们可以使用 -Xss 来设定栈容量。\n申请堆外内存 除了堆内存可以存放对象数据以外，我们也可以申请堆外内存(直接内存)，也就是不受 JVM 管控的内存区域，这部分区域的内存需要我们自行去申请和释放，实际上本质就是 JVM 通过 C/C++ 调用 malloc 函数申请的内存，当然得我们自己去释放了。不过虽然是直接内存，不会受到堆内存容量限制，但是依然会受到本机最大内存的限制，所以还是有可能抛出 0ut0fMemoryError 异常。 这里我们需要提到一个堆外内存操作类：Unsafe，就像它的名字一样，虽然 Java 提供堆外内存的操作类，但是实际上它是不安全的，只有你完全了解底层原理并且能够合理控制堆外内存，才能安全地使用堆外内存\n注意这个类不让我们new，也没有直接获取方式（压根就没想让我们用）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public final class Unsafe { private static native void registerNatives(); static { registerNatives(); sun.reflect.Reflection.registerMethodsToFilter(Unsafe.class, \u0026#34;getUnsafe\u0026#34;); } private Unsafe() {} private static final Unsafe theUnsafe = new Unsafe(); @CallerSensitive public static Unsafe getUnsafe() { Class\u0026lt;?\u0026gt; caller = Reflection.getCallerClass(); if (!VM.isSystemDomainLoader(caller.getClassLoader())) throw new SecurityException(\u0026#34;Unsafe\u0026#34;); // 不是 JDK 的类，不让用 return theUnsafe; } ... 所以这里通过反射搞出来\n1 2 3 4 5 public static void main(String[] args) throws IllegalAccessException { Field unsafeField = Unsafe.class.getDeclaredFields()[0]; unsafeField.setAccessible(true); Unsafe unsafe = (Unsafe) unsafeField.get(null); } 成功拿到 Unsafe 类之后，我们就可以开始申请堆外内存了，比如我们现在想要申请一个 int 大小的内存空间，并在此空间中存放一个 int 类型的数据：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class Main { public static void main(String[] args) throws IllegalAccessException { Field unsafeField = Unsafe.class.getDeclaredFields()[0]; unsafeField.setAccessible(true); Unsafe unsafe = (Unsafe) unsafeField.get(null); //申请4字节大小的内存空间，并得到对应位置的地址 long address = unsafe.allocateMemory(4); //在对应的地址上设定int的值 unsafe.putInt(address,6666666); //获取对应地址上的Int型数值 System.out.println(unsafe.getInt(address)); //释放申请到的内容 unsafe.freeMemory(address); //由于内存已经释放，这时数据就没了 System.out.println(unsafe.getInt(address)); } } 遗憾的是，这里可能由于 JDK 版本的问题，第二次依然可能拿到 6666666 的值\n我们可以来看一下 allocateMemory 底层是如何调用的，这是一个 native方法，我们来看 C++ 源码\n1 2 3 4 5 6 UNSAFE_ENTRY(jlong,Unsafe_AllocateMemory0(JNIEnv *env, jobject unsafe, jlong size)){ size_t sz=(size_t)size; sz= align_up(sz，HeapWordSize); void* x = os::malloc(sz,mtOther);//这里调用了os::malloc方法 return addr_to_java(x); } UNSAFE_END 接着来看\n1 2 3 4 5 6 7 8 9 10 11 void* os::malloc(size_t size，MEMFLAGS flags){ return os::malloc(size,flags,CALLER_PC); } void* os::malloc(size_t size, MEMFLAGS memflags, const NativeCallStack\u0026amp; stack){ ... u_char* ptr; ptr =(u_char*)::mallgc(alloc_size);//调用C++标准库函数 malloc(size) ... // we do not track guard memory return MemTracker::record_malloc((address)ptr, size, memflags, stack, level); } 所以，我们上面的 Java 代码转换为 C 代码，差不多就是这个意思：\n1 2 3 4 5 6 7 8 9 10 #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; int main() { int* a = malloc(sizeof(int)); *a = 6666666; printf(\u0026#34;%d\\n\u0026#34;, *a); free(a); printf(\u0026#34;%d\\n\u0026#34;, *a); } 所以说，直接内存实际上就是 JVM 申请的一块额外的内存空间，但是它并不在受管控的几种内存空间中，当然这些内存依然属于是 JVM 的，由于 JVM 提供的堆内存会进行垃圾回收等工作，效率不如直接申请和操作内存来得快，一些比较追求极致性能的框架会用到堆外内存来提升运行速度，如 nio 框架。\n垃圾回收机制 **注意：**此部分为重点内容\n我们前面提到，Java 会自动管理和释放内存，它不像 C/C++ 那样要求我们手动管理内存，JVM 提供了一套全自动的内存管理机制，当一个 Java 对象不再用到时，JVM 会自动将其进行回收并释放内存，那么对象所占内存在什么时候被回收，如何判定对象可以被回收，以及如何去进行回收工作也是 JVM 需要关注的问题。\n对象存活判定算法 首先我们来套讨论第一个问题，也就是：对象在什么情况下可以被判定为不再使用已经可以回收了？这里就需要提到以下几种垃圾回收算法了。\n引用计数法 我们知道，如果我们要经常操作一个对象，那么首先一定会创建一个引用变量：\n1 2 3 // str就是一个引用类型的变量，它持有对后面字符串对象的引用，可以代表后面这个字符串对象本身 String str =\u0026#34;lbwnb\u0026#34;; // str.xxxxx.· 实际上，我们会发现，只要一个对象还有使用价值，我们就会通过它的引用变量来进行操作，那么可否这样判断一个对象是否还需要被使用：\n每个对象都包含一个 引用计数器，用于存放引用计数（其实就是存放被引用的次数）\n每当有一个地方引用此对象时，引用计数 +1\n当引用失效（比如离开了局部变量的作用域或是引用被设定为 null）时，引用计数 -1\n当引用计数为 0 时，表示此对象不可能再被使用，因为这时我们已经没有任何方法可以得到此对象的引用了\n但是这样存在一个问题，如果两个对象相互引用呢?\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Main { public static void main(String[] args) throws IllegalAccessException { Test a = new Test(); Test b = new Test(); a.another = b; b.another = a; // 这里直接把 a 和 b 赋值为 null，这样前面的两个对象我们=不可能再得到了，但是由于 another 的存在，这两个对象的引用计数永远为 1，不会被引用计数法所清除 a = b = null; } private static class Test{ Test another; } } 按照引用计数算法，那么当出现以上情况时，虽然我们无法在得到此对象的引用了，并且此对象我们也无需再使用，但是由于这两个对象直接存在相互引用的情况，那么引用计数器的值将会永远是1，但是实际上此对象已经没有任何用途了。所以引用计数法并不是最好的解决方案。\n可达性分析算法 目前比较主流的编程语言（包括Java），一般都会使用可达性分析算法来判断对象是否存活，它采用了类似于树结构的搜索机制。\n首先每个对象的引用都有机会成为树的根节点（GC Roots），可以被选定作为根节点条件如下：\n位于虚拟机栈的栈帧中的本地变量表中所引用到的对象（其实就是我们方法中的局部变量）同样也包括本地方法栈中 JNI 引用的对象 类的静态成员变量引用的对象 方法区中，常量池里面引用的对象，比如我们之前提到的 String 类型对象 被添加了锁的对象（比如 synchronized 关键字） 虚拟机内部需要用到的对象 一旦已经存在的根节点不满足存在的条件时，那么根节点与对象之间的连接将被断开。此时虽然对象 1 仍存在对其他对象的引用，但是由于其没有任何根节点引用，所以此对象即可被判定为不再使用。比如某个方法中的局部变量引用，在方法执行完成返回之后：\n这样就能很好地解决我们刚刚提到的循环引用问题，我们再来重现一下出现循环引用的情况：\n可以看到，对象1和对象2依然是存在循环引用的，但是只有他们各自的 GCRoots 断开，那么就会变成下面这样：\n所以，我们最后进行一下总结：如果某个对象无法到达任何 GC Roots，则证明此对象是不可能再被使用的。\n最终判定 虽然在经历了可达性分析算法之后基本可能判定哪些对象能够被回收，但是并不代表此对象一定会被回收，我们依然可以在最终判定阶段对其进行挽留。\n0bject 类中的 finalize() 方法：\n1 protected void finalize() throws Throwable {} 此方法正是最终判定方法，如果子类重写了此方法，那么子类对象在被判定为可回收时，会进行二次确认，也就是执行 finalize() 方法，而在此方法中，当前对象是完全有可能重新建立 GC Roots 的！所以，如果在二次确认后对象不满足可回收的条件，那么此对象不会被回收，巧妙地逃过了垃圾回收的命运。比如下面这个例子:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class Main { private static Test a; public static void main(String[] args) throws IllegalAccessException, InterruptedException { a = new Test(); // 这里直接赋值 null a = null; //手动申请执行垃圾回收操作（只是申请，并不一定执行，一般来说会执行） System.gc(); // 等待回收 Thread.sleep(1000); System.out.println(a); } private static class Test { @Override protected void finalize() throws Throwable { System.out.println(this + \u0026#34;不准回收！\u0026#34;); a = this; } } } 注意 finalize()方法并不是在主线程调用的，而是虚拟机自动建立的一个低优先级的 Finalizer 线程（正是因为优先级比较低，所以前面才需要等待1秒钟）进行处理，我们可以稍微修改一下看看：\n1 2 3 4 5 6 7 private static class Test { @Override protected void finalize() throws Throwable { System.out.println(Thread.currentThread()); a = this; } } 1 2 Thread[Finalizer,8,system] org.example.Main$Test@1b6d3586 同时，同一个对象的 finalize() 方法只会有一次调用机会，也就是说，如果我们连续两次这样操作，那么第二次，对象必定被回收：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class Main { private static Test a; public static void main(String[] args) throws IllegalAccessException, InterruptedException { a = new Test(); // 这里直接赋值 null a = null; //手动申请执行垃圾回收操作（只是申请，并不一定执行，一般来说会执行） System.gc(); // 等待回收 Thread.sleep(1000); System.out.println(a); a=null; System.gc(); Thread.sleep(1000); System.out.println(a); } private static class Test { @Override protected void finalize() throws Throwable { System.out.println(Thread.currentThread()); a = this; } } } 1 2 3 Thread[Finalizer,8,system] org.example.Main$Test@1b6d3586 null 当然， finalize() 方法也并不是专门防止对象被回收的，我们可以使用它来释放一些程序使用中的资源等\n最后，总结成一张图:\n当然，除了堆中的对象以外，方法区中的数据也是可以被垃圾回收的，但是回收条件比较严格，这里就暂时不谈了。\n垃圾回收算法 前面我们介绍了对象存活判定算法，现在我们已经可以准确地知道堆中的哪些对象可以被回收了，那么，接下来就该考虑如何对对象进行回收了，垃圾收集器会不定期地检查堆中的对象，查看它们是否满足被回收的条件。我们该如何对这些对象进行回收，是一个一个判断是否需要回收吗？\n分代收集机制 实际上，如果我们对堆中的每一个对象都依次判断是否需要回收，这样的效率其实是很低的，那么有没有更好地回收机制呢？第一步，我们可以对堆中的对象进行分代管理。\n比如某些对象，在多次垃圾回收时，都未被判定为可回收对象，我们完全可以将这一部分对象放在一起，并让垃圾收集器减少回收此区域对象的频率，这样就能很好地提高垃圾回收的效率了。\n因此，Java 虚拟机将堆内存划分为新生代、老年代和永久代（其中永久代是 HotSpot 虚拟机特有的概念，在 JDK8 之前方法区实际上就是采用的永久代作为实现，而在 JDK8 之后，方法区由元空间实现，并且使用的是本地内存，容量大小取决于物理机实际大小，之后会详细介绍）这里我们主要讨论的是新生代和老年代。\n不同的分代内存回收机制也存在一些不同之处，在 HotSpot 虚拟机中，新生代被划分为三块，一块较大的 Eden 空间和两块较小的 Survivor 空间，默认比例为 8:1:1，老年代的 GC 频率相对较低，永久代一般存放类信息等（其实就是方法区的实现）如图所示\n那么它是如何运作的呢?\n首先，所有新创建的对象，在一开始都会进入到新生代的 Eden 区（如果是大对象会被直接丢进老年代），在进行新生代区域的垃圾回收时，首先会对所有新生代区域的对象进行扫描，并回收那些不再使用对象：\n接着，在一次垃圾回收之后，Ede n区域没有被回收的对象，会进入到 Sunivor 区。在一开始 From 和 To 都是空的，而 GC 之后，所有 Eden 区域存活的对象都会直接被放入到 From 区，最后 From 和 To 会发生一次交换，也就是说目前存放我们对象的 From 区，变为 To 区而 To 区变为 From 区：\n接着就是下一次垃圾回收了，操作与上面是一样的，不过这时由于我们 To区域中已经存在对象了，所以，在 Eden 区的存活对象复制到 From 区之后，所有 To 区域中的对象会进行年龄判定（每经历一轮 GC 年龄+1，如果对象的年龄大于 默认值为15 ，那么会直接进入到老年代，否则移动到 From 区）\n最后像上面一样交换 To 区和 From 区，之后不断重复以上步骤\n而垃圾收集也分为:\nMinor GC - 次要垃圾回收，主要进行新生代区域的垃圾收集\n触发条件:新生代的 Eden 区容量已满时 MajorGC - 主要垃圾回收，主要进行老年代的垃圾收集\nFull GC - 完全垃圾回收，对整个 Java 堆内存和方法区进行垃圾回收\n触发条件1：每次晋升到老年代的对象平均大小大于老年代剩余空间\n触发条件2：Minor GC 后存活的对象超过了老年代剩余空间\n触发条件3：永久代内存不足（JDK8之前）\n触发条件4：手动调用 System.gc() 方法\n我们可以添加启动参数来查看 JVM 的 GC 日志：\n现在我们还只能大致看懂 GC 日志，不过在学习完成本章全部内容后，我们就可以轻松阅读了。\n空间分配担保 我们可以思考一下，有没有这样一种极端情况（正常情况下新生代的回收率是很高的，所以说不用太担心会经常出现这种问题），在一次GC后，新生代 Eden 区仍然存在大量的对象（因为GC之后存活对象会进入到一个 Survivor 区，但是很明显这时已经超出 Sunvivor 区的容量了，肯定是装不下的）那么现在该怎么办？\n这时就需要用到空间分配担保机制了，可以把 Sunivor 区无法容纳的对象直接送到老年代，让老年代进行分配担保（当然老年代也得装得下才行）在现实生活中，贷款会指定担保人，就是当借款人还不起钱的时候由担保人来还钱。\n当新生代无法容纳更多的的对象时，可以把新生代中的对象移动到老年代中，这样新生代就腾出了空间来容纳更多的对象。\n好，那既然新生代装不下就丢给老年代，那么要是老年代也装不下新生代的数据呢？这时，老年代肯定担保人是当不成了，那么这样的话，首先会判断一下之前的每次垃圾回收进入老年代的平均大小是否小于当前老年代的剩余空间，如果小于，那么说明也许可以放得下（不过也仅仅是也许，依然有可能放不下，因为判断的实际上只是平均值，万一这一次突然非常大呢），否则，会先来一次 FullGC，进行一次大规模垃圾回收，来尝试腾出空间，再次判断老年代是否有空间存放，要是还是装不下，直接抛出 OOM 错误，摆烂。\n最后，总结一下一次 Minor GC 的整个过程：\n标记-清除算法 前面我们已经了解了整个堆内存实际上是以分代收集机制为主，但是依然没有讲到具体的收集过程，那么，具体的回收过程又是什么样的呢?首先我们救了解一下最古老的 标记-清除 算法。\n首先标记出所有需要回收的对象，然后再依次回收掉被标记的对象，或是标记出所有不需要回收的对象，只回收未标记的对象。实际上这种算法是非常基础的，并且最易于理解的（这里对象我就以一个方框代替了，当然实际上存放是我们前说到的 GC Roots 形式）\n虽然此方法非常简单，但是缺点也是非常明显的，首先如果内存中存在大量的对象，那么可能就会存在大量的标记，并且大规模进行清除。并且一次标记清除之后，连续的内存空间可能会出现许许多多的空隙，碎片化会导致连续内存空间利用率降低。\n标记-复制法 既然标记清除算法在面对大量对象时效率低，那么我们可以采用标记-复制算法。它将容量分为同样大小的两块区域\n标记复制算法，实际上就是将内存区域划分为大小相同的两块区域，每次只使用其中的一块区域，每次垃圾回收结束后，将所有存活的对象全部复制到另一块区域中，并一次性清空当前区域。虽然浪费了一些时间进行复制操作，但是这样能够很好地解决对象大面积回收后空间碎片化严重的问题。\n这种算法就非常适用于新生代（因为新生代的回收效率极高，一般不会留下太多的对象）的垃圾回收，而我们之前所说的新生代 Survivor 区其实就是这个思路，包括 8:1:1 的比例也正是为了对标记复制算法进行优化而采取的。\n标记-整理算法 虽然 标记-复制 算法能够很好地应对新生代高回收率的场景，但是放到老年代，它就显得很鸡肋了。我们知道，一般长期都回收不到的对象，才有机会进入到老年代，所以老年代一般都是些钉子户，可能一次 GC 后，仍然存留很多对象。而标记复制算法会在 GC 后完整复制整个区域内容，并且会折损 50% 的区域，显然这并不适用于老年代。\n那么我们能否这样，在标记所有待回收对象之后，不急着去进行回收操作，而是将所有待回收的对象整齐排列在一段内存空间中，而需要回收的对象全部往后丢，这样，前半部分的所有对象都是无需进行回收的，而后半部分直接一次性清除即可。\n虽然这样能保证内存空间充分使用，并且也没有标记复制算法那么繁杂，但是缺点也是显而易见的，它的效率比前两者都低。甚至,由于需要修改对象在内存中的位置，此时程序必须要暂停才可以，在极端情况下，可能会导致整个程序发生停顿（被称为“Stop The World”）。\n所以，我们可以将标记清除算法和标记整理算法混合使用，在内存空间还不是很凌乱的时候，采用标记清除算法其实是没有多大问题的，当内存空间凌乱到一定程度后，我们可以进行一次标记整理算法。\n垃圾收集器实现 聊完了对象存活判定和垃圾回收算法，接着我们就要看看具体有哪些垃圾回收器的实现了。我们可以自由地为新生代和老年代选择更适合它们的收集器。\nSerial 收集器 这款垃圾收集器也是元老级别的收集器了，在 JDK1.3.1 之前，是虚拟机新生代区域收集器的唯一选择。这是一款单线程的垃圾收集器，也就是说，当开始进行垃圾回收时，需要暂停所有的线程，直到垃圾收集工作结束。它的新生代收集算法采用的是标记复制算法，老年代采用的是标记整理算法。\n可以看到，当进入到垃圾回收阶段时，所有的用户线程必须等待 GC 线程完成工作，就相当于你打一把 LOL 40 分钟，中途每隔 1 分钟网络就卡 5 秒钟，可能这时你正在打团，结果你被物理控制直接在那里站了 5 秒钟，这确实让人难以接受。\n虽然缺点很明显，但是优势也是显而易见的：\n1.设计简单而高效。 2.在用户的桌面应用场景中，内存一般不大，可以在较短时间内完成垃圾收集，只要不频繁发生，使用串行回收器是可以接受的。\n所以，在客户端模式（一般用于一些桌面级图形化界面应用程序）下的新生代中，默认垃圾收集器至今依然是 Serial 收集器。我们可以在 java -version 中查看默认的客户端模式:\n我们可以在 jvm.cfg 文件中切换 JRE 为 Server VM 或是 Client VM ，默认路径为:\n1 JDK安装目录/jre/lib/jvm.cfg 比如我们需要将当前模式切换为客户端模式，那么我们可以这样编辑：\n1 2 -client KNOWN -server IGNORE ParNew 收集器 这款垃圾收集器相当于是 Serial 收集器的多线程版本，它能够支持多线程垃圾收集：\n除了多线程支持以外，其他内容基本与 Serial 收集器一致，并且目前某些 JVM 默认的服务端模式新生代收集器就是使用的 ParNew 收集器\nParallel Scavenge/Parallel Old收集器 Parallel Scavenge 同样是一款面向新生代的垃圾收集器，同样采用标记复制算法实现，在 JDK6 时也推出了其老年代收集器Paralel Old，采用标记整理算法实现：\n与 ParNew 收集器不同的是，它会自动衡量一个吞吐量，并根据吞吐量来决定每次垃圾回收的时间，这种自适应机制，能够很好地权衡当前机器的性能，根据性能选择最优方案。\n目前 JDK8 采用的就是这种 Parallel Scavenge + Parallel Old 的垃圾回收方案。\nCMS 收集器 在 JDK1.5。HotSpot 推出了一款在强交互应用中几乎可认为有划时代意义的垃圾收集器：CMS（Concurent-Mark-Sweep）收集器，这款收集器是 HotSpot 虛拟机中第一款真正意义上的并发（注意这里的并发和之前的并行是有区别的，并发可以理解为同时运行用户线程和 GC 线程，而并行可以理解为多条 GC 线程同时工作）收集器，它第一次实现了让垃圾收集线程与用户线程同时工作。\n它主要采用标记清除算法：\n它的垃圾回收分为 4 个阶段：\n初始标记（需要暂停用户线程）：这个阶段的主要任务仅仅只是标记出 GC Roots 能直接关联到的对象，速度比较快，不用担心会停顿太长时间 并发标记：从 GC Roots 的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行 重新标记（需要暂停用户线程）：由于并发标记阶段可能某些用户线程会导致标记产生变动，因此这里需要再次暂停所有线程进行并行标记，这个时间会比初始标记时间长一丢丢 并发清除：最后就可以直接将所有标记好的无用对象进行删除，因为这些对象程序中也用不到了，所以可以与用户线程并发运行 虽然它的优点非常之大，但是缺点也是显而易见的，我们之前说过，标记清除算法会产生大量的内存碎片，导致可用连续空间逐渐变少，长期这样下来，会有更高的概率触发 Full GC，并且在与用户线程并发执行的情况下，也会占用一部分的系统资源，导致用户线程的运行速度一定程度上减慢\n不过，如果你希望的是最低的 GC 停顿时间，这款垃圾收集器无疑是最佳选择，不过自从 G1 收集器问世之后，CMS 收集器不再推荐使用了\nGarbage First（G1）收集器 此垃圾收集器也是一款划时代的垃圾收集器，在 JDK7 的时候正式走上历史舞台，它是一款主要面向于服务端的垃圾收集器，并且在 JDK9 时，取代了 JDK8 默认的 Parallel Scavenge+ Parallel Old 的回收方案。\n我们知道，我们的垃圾回收分为 Minor Gc、Major GC和Full GC，它们分别对应的是新生代，老年代和整个堆内存的垃圾回收，而 G1 收集器巧妙地绕过了这些约定，它将整个 Java 堆划分成 2048 个大小相同的独立 Reqion 块，每个 Region 块 的大小根据堆空间的实际大小而定，整体被控制在 1MB 到 32MB 之间，且都为 2 的 N 次幂。所有的 Region 大小相同，且在 JVM 的整个生命周期内不会发生改变\n那么分出这些 Region 有什么意义呢？每一个 Region 都可以根据需要，自由决定扮演哪个角色（Eden、Sunvivor 和老年代），收集器会根据对应的角色采用不同的回收策略。此外，G1 收集器还存在一个 Humongous 区域，它专门用于存放大对象（一般认为大小超过了 Region 容量一半的对象为大对象）这样，新生代、老年代在物理上，不再是一个连续的内存区域，而是到处分布的。\n它的回收过程与 CMS 大体类似：\n分为以下四个步骤：\n初始标记（暂停用户线程）：仅仅只是标记一下 GC Roots 能直接关联到的对象，并且修改 TAMS 指针的值，让下一阶段用户线程并发运行时，能正确地在可用 Region 中分配新对象，这个阶段需要停顿线程，但耗时很短，而且时借用进行 Minor GC 的时候同步完成的，所以 G1 收集器在这个阶段实际并没有额外的停顿 并发标记：从 GC Root 开始对堆中的队形进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这个阶段耗时较长，但可与用户线程并发执行 最终标记（暂停用户线程）：对用户线程做一个短暂的暂停，用于处理并发标记阶段漏标的那部分对象 筛选回收：负责更新 Region 的统计数据，对各个 Region 的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个 Region 构成回收集，然后把决定回收的那一步能否 Region 的存活对象复制到空的 Region 中，在清理掉整个旧 Region 的全部空间，这里的操作设计存活对象的移动，是必须暂停用户线程，由多个收集器线程并行完成的 元空间 JDK8 之前，Hotspot 虚拟机的方法区实际上是永久代实现的。在 JDK8 之后，Hotspot 虚拟机不再使用永久代，而是采用了全新的元空间。类的元信息被存储在元空间中。元空间没有使用堆内存，而是与堆不相连的本地内存区域。所以，理论上系统可以使用的内存有多大，元空间就有多大，所以不会出现永久代存在时的内存溢出问题。这项改造也是有必要的，永久代的调优是很困难的，虽然可以设置永久代的大小，但是很难确定一个合适的大小，因为其中的影响因素很多，比如类数量的多少、常量数量的多少等。\n因此在JDK8时直接将本地内存作为元空间（Metaspace）的区域，物理内存有多大，元空间内存就可以有多大，这样永久代的空间分配问题就解决了，所以最终它变成了这样：\n到此，我们对于 JVM 内存区域的讲解就基本完成了。\n其他区引用类型 最后，我们来介绍一下其他引用类型\n我们知道，在 Java 中，如果变量是一个对象类型的，那么它实际上存放的是对象的引用，但是如果是一个基本类型，那么存放的就是基本类型的值。实际上我们平时代码中类似于0bject o = new 0bject()这样的的引用类型，细分之后可以称为 强引用。\n我们通过前面的学习可以明确，如果方法中存在这样的 强引用 类型，现在需要回收强引用所指向的对象，那么要么此方法运行结束，要么引用连接断开，否则被引用的对象是无法被判定为可回收的，因为我们说不定后面还要使用它。\n所以，当 JVM 内存空间不足时，JVM 宁愿抛出 Out0fMemoryError 使程序异常终止，也不会靠随意回收具有强引用的“存活”对象来解决内存不足的问题。\n除了强引用之外，Java也为我们提供了三种额外的引用类型：\n软引用 软引用不像强引用那样不可回收，当 JVM 认为内存不足时，会去试图回收软引用指向的对象，即 JVM 会确保在抛出OutOfMemoryError 之前，清理软引用指向的对象。当然，如果内存充足，那么是不会轻易被回收的。\n我们可以通过以下方式来创建一个软引用：\n1 2 3 4 5 6 7 8 9 public class Main{ public static void main(String[] args) { // 强引用写法：Object obj = new Object(); // 软引用写法： SoftReference\u0026lt;Object\u0026gt; reference = new SoftReference\u0026lt;\u0026gt;(new Object()); // 使用 get 方法就可以获取到软引用所指的对象了 System.out.println(reference.get()); } } 可以看到软引用还存在一个带队列的构造方法，软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java 虚拟机就会把这个软引用加入到与之关联的引用队列中。\n这里我们来进行一个测试，首先设定一下参数，是最大堆内存为 10 M，并且答应 GC 日志\n1 -Xms10m -Xmx10m -XX:+PrintGCDetails 接着运行以下代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Main{ public static void main(String[] args) { ReferenceQueue\u0026lt;Object\u0026gt; queue = new ReferenceQueue\u0026lt;\u0026gt;(); SoftReference\u0026lt;Object\u0026gt; reference = new SoftReference\u0026lt;\u0026gt;(new Object(), queue); System.out.println(reference); try{ List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); while (true) list.add(new String(\u0026#34;aaaaaa\u0026#34;)); }catch (Throwable t) { System.out.println(\u0026#34;内存溢出\u0026#34;); System.out.println(\u0026#34;软引用对象：\u0026#34; + reference.get()); System.out.println(queue.poll()); } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 [GC (Allocation Failure) [PSYoungGen: 1024K-\u0026gt;504K(1536K)] 1024K-\u0026gt;704K(5632K), 0.0011488 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] java.lang.ref.SoftReference@1b6d3586 [GC (Allocation Failure) [PSYoungGen: 1526K-\u0026gt;484K(1536K)] 1726K-\u0026gt;1156K(5632K), 0.0007738 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [GC (Allocation Failure) [PSYoungGen: 1508K-\u0026gt;512K(1536K)] 2180K-\u0026gt;1905K(5632K), 0.0011489 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [GC (Allocation Failure) [PSYoungGen: 1535K-\u0026gt;512K(1536K)] 2929K-\u0026gt;2951K(5632K), 0.0020703 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [GC (Allocation Failure) [PSYoungGen: 1536K-\u0026gt;512K(1536K)] 3975K-\u0026gt;4008K(5632K), 0.0020181 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [Full GC (Ergonomics) [PSYoungGen: 512K-\u0026gt;0K(1536K)] [ParOldGen: 3496K-\u0026gt;3169K(4096K)] 4008K-\u0026gt;3169K(5632K), [Metaspace: 3450K-\u0026gt;3450K(1056768K)], 0.0488801 secs] [Times: user=0.41 sys=0.00, real=0.05 secs] ......... [Full GC (Ergonomics) [PSYoungGen: 1024K-\u0026gt;1024K(1536K)] [ParOldGen: 4035K-\u0026gt;4035K(4096K)] 5059K-\u0026gt;5059K(5632K), [Metaspace: 3535K-\u0026gt;3535K(1056768K)], 0.0543443 secs] [Times: user=0.61 sys=0.00, real=0.05 secs] 内存溢出 软引用对象：null java.lang.ref.SoftReference@1b6d3586 [Full GC (Ergonomics) [PSYoungGen: 1024K-\u0026gt;0K(1536K)] [ParOldGen: 4046K-\u0026gt;714K(4096K)] 5070K-\u0026gt;714K(5632K), [Metaspace: 3548K-\u0026gt;3548K(1056768K)], 0.0047166 secs] [Times: user=0.20 sys=0.00, real=0.00 secs] Heap PSYoungGen total 1536K, used 41K [0x00000000ffe00000, 0x0000000100000000, 0x0000000100000000) eden space 1024K, 4% used [0x00000000ffe00000,0x00000000ffe0a620,0x00000000fff00000) from space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000) to space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000) ParOldGen total 4096K, used 714K [0x00000000ffa00000, 0x00000000ffe00000, 0x00000000ffe00000) object space 4096K, 17% used [0x00000000ffa00000,0x00000000ffab2968,0x00000000ffe00000) Metaspace used 3574K, capacity 4564K, committed 4864K, reserved 1056768K class space used 378K, capacity 388K, committed 512K, reserved 1048576K 弱引用 弱引用比软引用的生命周期还要短，在进行垃圾回收时，不管当前内存空间是否充足，都会回收它的内存。\n我们可以像这样创建一个弱引用：\n1 2 3 4 5 6 public class Main { public static void main(String[] args) { WeakReference\u0026lt;Object\u0026gt; reference = new WeakReference\u0026lt;\u0026gt;(new Object()); System.out.println(reference.get()); } } 使用方法和软引用是差不多的，但是如果我们在这之前手动进行一次 GC：\n1 2 3 4 5 6 7 8 9 public class Main { public static void main(String[] args) { WeakReference\u0026lt;Object\u0026gt; weakReference = new WeakReference\u0026lt;\u0026gt;(new Object()); SoftReference\u0026lt;Object\u0026gt; softReference = new SoftReference\u0026lt;\u0026gt;(new Object()); System.gc(); System.out.println(\u0026#34;软引用对象：\u0026#34; + softReference.get()); System.out.println(\u0026#34;弱引用对象：\u0026#34; + weakReference.get()); } } 可以看到，弱引用对象直接就被回收了，而软引用对象没有被回收。同样的，它也支持 ReferenceQueue，和软引用用法一致，这里就不多做介绍了\nWeakHashMap，正是一种类似于弱引用的 HashMap 类，如果 Map 中的 Key 没有其他引用那么此 Map 会自动丢弃此键值对：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class Main { public static void main(String[] args) { Integer a = new Integer(1); WeakHashMap\u0026lt;Integer, String\u0026gt; weakHashMap = new WeakHashMap\u0026lt;\u0026gt;(); weakHashMap.put(a, \u0026#34;yyds\u0026#34;); System.out.println(weakHashMap); a=null; System.gc(); System.out.println(weakHashMap); } } 可以看到，当变量 a 的引用断开后，这时只有 WeakHashMap 本身对此对象存在引用，所以在 GC 之后，这个键值对就自动被舍弃了。所以说这玩意，就挺适合拿去做缓存的。\n虚引用（鬼引用） 虚引用相当于没有引用，随时都有可能会被回收。\n看看它的源码，非常简单：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public class PhantomReference\u0026lt;T\u0026gt; extends Reference\u0026lt;T\u0026gt; { /** * Returns this reference object\u0026#39;s referent. Because the referent of a * phantom reference is always inaccessible, this method always returns * \u0026lt;code\u0026gt;null\u0026lt;/code\u0026gt;. * * @return \u0026lt;code\u0026gt;null\u0026lt;/code\u0026gt; */ public T get() { return null; } /** * Creates a new phantom reference that refers to the given object and * is registered with the given queue. * * \u0026lt;p\u0026gt; It is possible to create a phantom reference with a \u0026lt;tt\u0026gt;null\u0026lt;/tt\u0026gt; * queue, but such a reference is completely useless: Its \u0026lt;tt\u0026gt;get\u0026lt;/tt\u0026gt; * method will always return {@code null} and, since it does not have a queue, * it will never be enqueued. * * @param referent the object the new phantom reference will refer to * @param q the queue with which the reference is to be registered, * or \u0026lt;tt\u0026gt;null\u0026lt;/tt\u0026gt; if registration is not required */ public PhantomReference(T referent, ReferenceQueue\u0026lt;? super T\u0026gt; q) { super(referent, q); } } 也就是说我们无论调用多少次 get() 方法得到的永远都是 nu11，因为虚引用本身就不算是个引用，相当于这个对象不存在任何引用并且只能使用带队列的构造方法，以便对象被回收时接到通知。\n最后，Java 中 4 种引用的级别由高到低依次为：强引用 \u0026gt;软引用 \u0026gt;弱引用 \u0026gt; 虚引用\n类与类加载 类文件结构 在我们学习 C 语言的时候，我们的编程过程会经历如下几个阶段：写代码、保存、编译、运行。实际上，最关键的一步是编译，因为只有经历了编译之后，我们所编写的代码才能够翻译为机器可以直接运行的二进制代码，并且在不同的操作系统下，我们的代码都需要进行一次编译之后才能运行。\n如果全世界所有的计算机指令集只有x86一种，操作系统只有 Windows 一种，那也许就不会有 Java 语言的出现。\n随着时代的发展，人们迫切希望能够在不同的操作系统、不同的计算机架构中运行同一套编译之后的代码。本地代码不应该是我们编程的唯一选择，所以，越来越多的语言选择了与操作系统和机器指令集无关的中立格式作为编译后的存储格式。\n“一次编写，到处运行”，Java最引以为傲的口号，标志着平台不再是限制编程语言的阻碍。\n实际上，Java 正式利用了这样的解决方案，将源代码编译为平台无关的中间格式，并通过对应的 Java 虚拟机读取和运行这些中间格式的编译文件，这样，我们只需要考虑不同平台的虚拟机如何编写，而 Java 语言本身很轻松地实现了跨平台。\n现在，越来越多的开发语言都支持将源代码编译为 .class 字节码文件格式，以便能够直接交给 JVM 运行，包括 Kotlin（安卓开发官方指定语言）、Groovy、Scala 等。\n那么，让我们来看看，我们的源代码编译之后，是如何保存在字节码文件中的。\n类文件信息 我们之前都是使用 javap 命令来对字节码文件进行反编译查看的，那么，它以二进制格式是怎么保存呢？我们可以使用VS code 下载 Hex Editor 插件来以十六进制查看字节码文件\n1 2 3 4 5 6 7 public class Main { public static void main(String[] args){ int i = 10; int a= i++; int b = ++i; } } 找到我们在 IDEA 中编译出来的 class 文件，将其拖动进去:\n可以看到整个文件中，全是一个字节一个字节分组的样子，从左上角开始，一行一行向下读取。可以看到在右侧中还出现了一些我们之前也许见过的字符串，比如\u0026lt;init\u0026gt;、Object等\n实际上 Class 文件采用了一种类似于 C 中结构体的伪结构来存储数据（当然我们直接看是看不出来的）但是如果像这样呢：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 Classfile /D:/code/blogchat-java/untitled/target/classes/org/example/Main.class Last modified 2024-9-26; size 450 bytes MD5 checksum d9b6dcbc5f453955fc4b5c9562eac423 Compiled from \u0026#34;Main.java\u0026#34; public class org.example.Main minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPER Constant pool: #1 = Methodref #3.#21 // java/lang/Object.\u0026#34;\u0026lt;init\u0026gt;\u0026#34;:()V #2 = Class #22 // org/example/Main #3 = Class #23 // java/lang/Object #4 = Utf8 \u0026lt;init\u0026gt; #5 = Utf8 ()V #6 = Utf8 Code #7 = Utf8 LineNumberTable #8 = Utf8 LocalVariableTable #9 = Utf8 this #10 = Utf8 Lorg/example/Main; #11 = Utf8 main #12 = Utf8 ([Ljava/lang/String;)V #13 = Utf8 args #14 = Utf8 [Ljava/lang/String; #15 = Utf8 i #16 = Utf8 I #17 = Utf8 a #18 = Utf8 b #19 = Utf8 SourceFile #20 = Utf8 Main.java #21 = NameAndType #4:#5 // \u0026#34;\u0026lt;init\u0026gt;\u0026#34;:()V #22 = Utf8 org/example/Main #23 = Utf8 java/lang/Object { public org.example.Main(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.\u0026#34;\u0026lt;init\u0026gt;\u0026#34;:()V 4: return LineNumberTable: line 3: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this Lorg/example/Main; public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=1, locals=4, args_size=1 0: bipush 10 2: istore_1 3: iload_1 4: iinc 1, 1 7: istore_2 8: iinc 1, 1 11: iload_1 12: istore_3 13: return LineNumberTable: line 5: 0 line 6: 3 line 7: 8 line 8: 13 LocalVariableTable: Start Length Slot Name Signature 0 14 0 args [Ljava/lang/String; 3 11 1 i I 8 6 2 a I 13 1 3 b I } 乍一看，是不是感觉还真的有点结构体那味？\n而结构体中，有两种允许存在的数据类型，一个是无符号数，还有一个是表。\n无符号数一般是基本数据类型，用 u1、u2、u4、u8 来表示，表示 1 个字节 ~ 8 个字节 的无符号数。可以表示数字、索引引用、数量值或是以 UTF-8 编码格式的字符串。 表包含多个无符号数，并且以 \u0026ldquo;info\u0026rdquo; 结尾。 我们首先从最简单的开始看起\n首先，我们可以看到，前 4 个字节（共32位）组成了魔数（其实就是表示这个文件是一个 JVM 可以运行的字节码文件，除了 Java 以外，其他某些文件中也采用了这种魔数机制来进行区分，这种方式比直接起个文件扩展名更安全）\n字节码文件的魔数为：CAFEBABE（这名字能想出来也是挺难的了，毕竟4个bit位只能表示出A-F这几个字母）\n紧接着魔数的后面 4 个字节存储的是字节码文件的版本号，注意前两个是次要版本号（现在基本都不用了，都是直接Java8、Java9这样命名了），后面两个是主要版本号，这里我们主要看主版本号，比如上面的就是 34，注意这是以 16 进制表示的，我们把它换算为 10 进制后，得到的结果为：34 -\u0026gt; 3 * 16 + 4 = 52，其中 52 代表的是 JDK8 编译的字节码文件（51是JDK7、50是JDK6、53是 JDK9 以此类推）\nJVM 会根据版本号决定是否能够运行，比如 JDK6 只能支持版本号为 1.16 的版本，也就是说必须是 Java6 之前的环境编译出来的字节码文件，否则无法运行。又比如我们现在安装的是 JDK8 版本，它能够支持的版本号为 1.18，那么如果这时我们有一个通过 Java7 编译出来的字节码文件，依然是可以运行的，所以说 Java 版本是向下兼容的。\n紧接着，就是类的常量池了，这里面存放了类中所有的常量信息（注意这里的常量并不是指我们手动创建的 final 类型常量，而是程序运行一些需要用到的常量数据，比如字面量和符号引用等）由于常量的数量不是确定的，所以在最开始的位置会存放常量池中常量的数量（是从 1 开始计算的，不是 0，比如这里是 18，翻译为 10 进制就是 24，所以实际上有 23 个常量）\n接着再往下，就是常量池里面的数据了，每一项常量池里面的数据都是一个表，我们可以看到他们都是以 info 结尾的:\n我们来看看一个表中定义了哪些内容：\n首先上来就会有一个 1 字节的无符号数，它用于表示当前常量的类型（常量类型有很多个）这里只列举一部分的类型介绍:\n类型 标志 描述 CONSTANT_Utf8_info 1 UTF-8编码格式的字符串 CONSTANT_Integer_info 3 整形字面量 CONSTANT_Class_info 7 类或接口的符号引用 CONSTANT_String_info 8 字符串类型的字面量 CONSTANT_Fieldref_info 9 字段的符号引用 CONSTANT_Methodref_info 10 方法的符号引用 CONSTANT_MethodType_info 16 方法类型 CONSTANT_NameAndType_info 12 字段或方法的部分符号引用 实际上这些东西，虽然我们不知道符号引用是什么东西，我们可以观察出来，这些东西或多或少都是存放类中一些名称、数据之类的东西。\n比如我们来看第一个 CONSTANT_Methodref_info 表中存放了什么数据，这里我只列出它的结构表（详细的结构表可以查阅《深入理解Java虚拟机 第三版》中222页总表）\n常量 项目 类型 描述 CONSTANT_Methodref_info tag u1 值为10 index u2 指向声明方法的类描述父 CONSTANT_Class_info 索引项 index u2 指向名称及类型描述符 CONSTANT_NameAndType_info 索引项 比如我们刚刚的例子中：\n可以看到，第一个索引项指向了第3号常量，我们来看看三号常量：\n常量 项目 类型 描述 CONSTANT_Class_info tag u1 值为7 index u2 指向全限定名常量项的索引 一直向下推即可\n可以看到，方法名称为 \u0026ldquo;\u0026quot;，一般构造方法的名称都是 ，普通方法名称是什么就是什么，方法描述符为\u0026rdquo;()V\u0026quot;，表示此方法没有任何参数，并且返回值类型为 void，描述符对照表如下：\n比如这里有一个方法 public int test(double a，char b ){...}，那么它的描述符就应该是:(DC)I，参数依次放入括号中，括号右边是返回值类型。再比如 public String test(0bject obj){...}，那么它的描述符就应该是：(Ljava/lang/0bject;)Ljava/lang/string，注意如果参数是对象类型，那么必须在后面添加;\n对于数组类型，只需要在类型最前面加上 [ 即可，有几个维度，就加几个，比如 public void test(int\\[\\]\\[\\] arr)，参数是一个二维 int 类型数组，那么它的描述符为：([[I)V\n所以，这里表示的，实际上就是此方法是一个无参构造方法，并且是属于 Object 类的。那么，为什么这里需要 Object 类构造方法的符号引用呢？每个类都是直接或简介继承自 0biect 类，所有类的构造方法，必须先调用父类的构造方法，但是如果父类存在无参构造，默认可以不用显示调用 super 关键字（当然本质上是调用了的）\n我们可以在反编译结果中的方法中看到\n1 2 3 4 5 6 7 8 9 10 11 12 13 public org.example.Main(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.\u0026#34;\u0026lt;init\u0026gt;\u0026#34;:()V 4: return LineNumberTable: line 3: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this Lorg/example/Main; 其中 invokespecial （调用父类构造方法）指令的参数指向了 1 号常量，而 1 号常量正是代表的 Object 类的无参构造方法，虽然饶了这么大一圈，但是过程理清楚，还是很简单的。\n虽然我们可以直接查看 16 进制的结果，但是还是不够方便，但是我们也不能每次都去使用 javap 命令，所以我们这里安装一个 IDEA 插件，来方便我们查看字节码中的信息，名称为jclasslib Bytecode Viewer :\n首先在项目中选中我们的 Main 类，然后点击工具栏的视图，然后点击 show Bytecode With Jcasslib，这样右侧就会出现当前类的字节码解析信息了。注意如果修改了类的话，那么需要你点击运行或是构建，然后点击刷新按钮来进行更新。\n接着我们来看下一个内容，在常量池之后，紧接着就是访问标志，访问标志就是类的种类以及类上添加的一些关键字等内容：\n可以看到它只占了 2 个字节，那么它是如何表示访问标志呢？\n比如我们这里的 Main 类，它是一个普通的 class 类型，并且访问权限为 public，那么它的访问标志值是这样计算的：\nACC PUBLIC | ACC SUPER = 0x0001 | 0x0020 = 0x0021 （这里进行的是按位或运算），可以看到和我们上面的结果是一致的。\n再往下就是类索引、父类索引、接口索引：\n可以看到它们的值也是指向常量池中的值，其中 2 号常量正是存储的当前类信息，3 号常量存储的是父类信息，这里就不再倒推回去了，由于没有接口，所以这里接口数量为 0，如果不为 0 还会有一个索引表来引用接口。\n接着就是字段和方法表集合了：\n由于我们这里没有声明任何字段，所以我们先给 Main 类添加一个字段再重新加载一下：\n1 2 3 4 5 6 7 8 9 public class Main { public static int a = 10; public static void main(String[] args){ int i = 10; int a= i++; int b = ++i; } } 现在字节码就新增了一个字段表，这个字段表实际上就是我们刚刚添加的成员字段 a 的数据。\n可以看到一共有四个 2 字节的数据：\n首先是 access_flags，这个与上面类标志的计算规则是一样的，表还是先列出来吧\n后续字节码可以自己对应去看对应关系，不在此赘述\n字节码指令 虚拟机的指令是由一个字节长度的、代表某种特定操作含义的数字（操作码，类似于机器语言），操作后面也可以携带 0个或多个参数一起执行。我们前面已经介绍过了，JVM 实际上并不是面向寄存器架构的，而是面向操作数栈，所以大多数指令都是不带参数的。\n由于之前已经讲解过大致运行流程，这里我们就以当前的 Main 类中的 main 方法作为教材进行讲解：\n1 2 3 4 5 public static void main(String[] args) { int i= 10; int a= i++; int b = ++i; } 可以看到，main 方法中首先是定义了一个 int 类型的变量 i，并赋值为10，然后变量 a 接收 i++ 的值，变量 b 接收 ++i 的值，那么我们来看看编译成字节码之后，是什么样的：\n首先第一句， bipush，将 10 送至操作数顶。\n接下来将操作数栈顶的数值存进1号本地变量，也就是变量 i 中。\n接着将变量 i 中的值又丢向操作数栈顶\n这里使用 iinc 指令，将1号本地变量的值增加 1（结束之后i的值就是11了）\n接着将操作数栈顶的值(操作数栈顶的值是10)存入2号本地变量(这下彻底知道i++到底干了啥才会先返回后自增了吧，从原理角度来说，实际上 i 是先自增了的，但由于这里取的是（操作数栈中的值，所以说就得到了 i 之前的值）\n接着往下，我们看到 ++i 是先直接将 i 的值自增 1\n然后在将其值推向操作数栈顶\n而从结果来看， i++ 操作确实是先返回再自增的，而字节码指令层面来说，却是截然相反的，只是结果一致罢了。\nASM 字节码编程 既然字节码文件结构如此清晰，那么我们能否通过编程，来直接创建一个字节码文件呢？如果我们可以直接编写一个字节码文件，那么我们就可以省去编译的过程。ASM（某些 JDK 中内置）框架正是用于支持字节码编程的框架。\n比如现在我们需要创建一个普通的 Main 类（暂时不写任何内容）\n首先我们来看看如何通过编程创建一个 Main 类的字节码文件：\n1 2 3 4 5 public class Main { public static void main(String[] args) { ClassWriter writer = new ClassWriter(ClassWriter.COMPUTE_MAXS); } } 首先需要获取 Classwriter 对象，我们可以使用它来编辑类的字节码文件，在构造时需要传入参数：\n0 这种方式不会自动计算操作数栈和局部临时变量表大小，需要自己手动来指定\nClassWriter.COMPUTE_MAXS(1) 这种方式会自动计算上述操作数栈和局部临时变量表大小，但需要手动触发\nClassWriter.COMPUTE_FRAMES(2) 这种方式不仅会计算上述操作数栈和局部临时变量表大小，而且会自动计算StackMapFrames\n这里我们使用 ClassWriter.COMPUTE_MAXS 即可\n接着我们首先需要指定类的一些基本信息：\n1 2 3 4 public static void main(String[] args) { ClassWriter writer = new ClassWriter(ClassWriter.COMPUTE_MAXS); writer.visit(V1_8, ACC_PUBLIC,\u0026#34;org/example/Main\u0026#34;,null,\u0026#34;java/lang/Object\u0026#34;,null); } 这里我们将字节码文件的版本设定位 Java8，然后修饰符设定为 ACC_PUBLIC 代表 public class Main，类名称注意要携带包名，标签设置为 null，父类设定为 Object 类，然后没有实现任何接口，所以说最后一个参数也是 null。\n接着，一个简单的类字节码文件就创建好了，我们可以尝试将其进行保存:\n1 2 3 4 5 6 7 8 9 10 11 public class Main { public static void main(String[] args) { ClassWriter writer = new ClassWriter(ClassWriter.COMPUTE_MAXS); writer.visit(V1_8, ACC_PUBLIC,\u0026#34;org/example/Main\u0026#34;,null,\u0026#34;java/lang/Object\u0026#34;,null); try (FileOutputStream stream = new FileOutputStream(\u0026#34;./Main.class\u0026#34;)) { stream.write(writer.toByteArray()); } catch (IOException e) { e.printStackTrace(); } } } 我们知道，正常的类在编译之后，如果没有手动添加构造方法，那么会自带一个无参构造，但是我们这个类中还没有，所以我们来手动添加一个无参构造方法：\n1 writer.visitMethod(ACC_PUBLIC, \u0026#34;\u0026lt;init\u0026gt;\u0026#34;, \u0026#34;()V\u0026#34;,null,null); 可以看到反编译的结果中已经存在了我们的构造方法\n但是这样是不合法的，因为我们的构造方法还没有添加父类构造方法调用，所以说我们还需要在方法中添加父类构造方法调用指令：\n我们需要对方法进行详细编辑：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 public class Main { public static void main(String[] args) { ClassWriter writer = new ClassWriter(ClassWriter.COMPUTE_MAXS); writer.visit(V1_8, ACC_PUBLIC,\u0026#34;org/example/Main\u0026#34;,null,\u0026#34;java/lang/Object\u0026#34;,null); // 通过 MethodVisitor 接收返回值，进行进一步操作 MethodVisitor visitor = writer.visitMethod(ACC_PUBLIC, \u0026#34;\u0026lt;init\u0026gt;\u0026#34;,\u0026#34;()V\u0026#34;,null,null); // 开始编辑代码 visitor.visitCode(); // Label 用于存储行号 Label l1 = new Label(); // 当前代码写到哪行了，l1 得到的就是多少行 visitor.visitLabel(l1); // 添加源码行数对应表（其实可以不用） visitor.visitLineNumber(11, l1); // 注意不同类型的指令需要用不同的方法来调用，因为操作数不一致，具体的注释有写 visitor.visitVarInsn(ALOAD, 0); visitor.visitMethodInsn(INVOKESPECIAL, \u0026#34;java/lang/Object\u0026#34;,\u0026#34;\u0026lt;init\u0026gt;\u0026#34;,\u0026#34;()V\u0026#34;, false); Label l2 = new Label(); visitor.visitLabel(l2); // 添加本地变量表，这里加的是 this 关键字，但是方法中没用到，其实可以不加 visitor.visitLocalVariable(\u0026#34;this\u0026#34;,\u0026#34;Lorg/example/Main;\u0026#34;,null,l1,l1,0); // 最后设定最大栈深度和本地变量数 visitor.visitMaxs(1,1); visitor.visitEnd(); try (FileOutputStream stream = new FileOutputStream(\u0026#34;./Main.class\u0026#34;)) { stream.write(writer.toByteArray()); } catch (IOException e) { e.printStackTrace(); } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 Classfile /D:/code/blogchat-java/untitled/Main.class Last modified 2024-9-26; size 227 bytes MD5 checksum 39fa40f1948f91acc569c91eac8615d3 public class org.example.Main minor version: 0 major version: 52 flags: ACC_PUBLIC Constant pool: #1 = Utf8 org/example/Main #2 = Class #1 // org/example/Main #3 = Utf8 java/lang/Object #4 = Class #3 // java/lang/Object #5 = Utf8 \u0026lt;init\u0026gt; #6 = Utf8 ()V #7 = NameAndType #5:#6 // \u0026#34;\u0026lt;init\u0026gt;\u0026#34;:()V #8 = Methodref #4.#7 // java/lang/Object.\u0026#34;\u0026lt;init\u0026gt;\u0026#34;:()V #9 = Utf8 this #10 = Utf8 Lorg/example/Main; #11 = Utf8 Code #12 = Utf8 LocalVariableTable #13 = Utf8 LineNumberTable { public org.example.Main(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #8 // Method java/lang/Object.\u0026#34;\u0026lt;init\u0026gt;\u0026#34;:()V LocalVariableTable: Start Length Slot Name Signature 0 0 0 this Lorg/example/Main; LineNumberTable: line 11: 0 } 可以看到和之前的基本一致了，到此为止我们构造方法就编写完成了，接着我们来写一下 main 方法，一会我们就可以通过main 方法来运行Java程序了。比如我们要编写这样一个程序：\n1 2 3 4 public static void main(String[] args) { int a = 10; System.out.println(a); } 看起来很简单的一个程序对吧，但是我们如果手动去组装指令，会极其麻烦！首先 main 方法是一个静态方法，并且方法是 public 权限，然后还有一个参数 String[] args ，所以说我们这里要写的内容有点小多：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 public class Main { public static void main(String[] args) { ClassWriter writer = new ClassWriter(ClassWriter.COMPUTE_MAXS); writer.visit(V1_8, ACC_PUBLIC,\u0026#34;org/example/Main\u0026#34;,null,\u0026#34;java/lang/Object\u0026#34;,null); // 通过 MethodVisitor 接收返回值，进行进一步操作 MethodVisitor visitor = writer.visitMethod(ACC_PUBLIC, \u0026#34;\u0026lt;init\u0026gt;\u0026#34;,\u0026#34;()V\u0026#34;,null,null); // 开始编辑代码 visitor.visitCode(); // Label 用于存储行号 Label l1 = new Label(); // 当前代码写到哪行了，l1 得到的就是多少行 visitor.visitLabel(l1); // 添加源码行数对应表（其实可以不用） visitor.visitLineNumber(11, l1); // 注意不同类型的指令需要用不同的方法来调用，因为操作数不一致，具体的注释有写 visitor.visitVarInsn(ALOAD, 0); visitor.visitMethodInsn(INVOKESPECIAL, \u0026#34;java/lang/Object\u0026#34;,\u0026#34;\u0026lt;init\u0026gt;\u0026#34;,\u0026#34;()V\u0026#34;, false); visitor.visitInsn(RETURN); Label l2 = new Label(); visitor.visitLabel(l2); // 添加本地变量表，这里加的是 this 关键字，但是方法中没用到，其实可以不加 visitor.visitLocalVariable(\u0026#34;this\u0026#34;,\u0026#34;Lorg/example/Main;\u0026#34;,null,l1,l2,0); // 最后设定最大栈深度和本地变量数 visitor.visitMaxs(1,1); visitor.visitEnd(); // 开始安排 main 方法 MethodVisitor v2 = writer.visitMethod(ACC_PUBLIC | ACC_STATIC,\u0026#34;main\u0026#34;,\u0026#34;([Ljava/lang/String;)V\u0026#34;,null,null); v2.visitCode(); // 记录起始行信息 Label l3 = new Label(); v2.visitLabel(l3); v2.visitLineNumber(13,l3); // 首先是 int a = 10 的操作，执行指令以此为： // bipush 10 将10推向操作数栈顶 // istore_1 将操作数栈顶元素保存到 1 号本地变量 a 中 v2.visitIntInsn(BIPUSH, 10); v2.visitVarInsn(ISTORE, 1); Label l4 = new Label(); // 记录行信息 v2.visitLabel(l4); v2.visitLineNumber(14,l4); // 获取 System 类中 out 静态变量 （PrintStream 接口），用于打印 v2.visitFieldInsn(GETSTATIC, \u0026#34;java/lang/System\u0026#34;,\u0026#34;out\u0026#34;,\u0026#34;Ljava/io/PrintStream;\u0026#34;); // 把 a 取出来 v2.visitVarInsn(ILOAD, 1); // 调用接口中的抽象方法 println v2.visitMethodInsn(INVOKEVIRTUAL, \u0026#34;java/io/PrintStream\u0026#34;,\u0026#34;println\u0026#34;,\u0026#34;(I)V\u0026#34;,false); // 再次记录行信息 Label l6 = new Label(); v2.visitLabel(l6); v2.visitLineNumber(15,l6); v2.visitInsn(RETURN); Label l7 = new Label(); v2.visitLabel(l7); // 最后是本地变量表中的各个变量 v2.visitLocalVariable(\u0026#34;args\u0026#34;,\u0026#34;[Ljava/lang/String;\u0026#34;,null,l3,l7,0); v2.visitLocalVariable(\u0026#34;a\u0026#34;,\u0026#34;I\u0026#34;,null,l4,l7,1); v2.visitMaxs(1,2); v2.visitEnd(); try (FileOutputStream stream = new FileOutputStream(\u0026#34;./Main.class\u0026#34;)) { stream.write(writer.toByteArray()); } catch (IOException e) { e.printStackTrace(); } } } Spring 中的动态代理就是使用了 此 ASM 字节码框架\n类加载机制 现在，我们已经了解了字节码文件的结构，以及 JVM 如何对内存进行管理，现在只剩下最后一个谜团等待解开了，也就是我们的类字节码文件到底是如何加载到内存中的，加载之后又会做什么事情。\n类加载过程 首先，要加载一个类，一定是出于某种目的的，比如我们要运行我们的 Java 程序，那么就必须要加载主类才能运行主类中的主方法，又或是我们需要加载数据库驱动，那么可以通过反射来将对应的数据库驱动类进行加载。\n所以，一般在这些情况下，如果类没有被加载，那么会被自动加载：\n使用 new 关键字创建对象时\n使用某个类的静态成员（包括方法和字段）的时候（当然，final类型的静态字段有可能在编译的时候被放到了当前类的常量池中，这种情况下是不会触发自动加载的）\n使用反射对类信息进行获取的时候（之前的数据库驱动就是这样的）加载一个类的子类时\n加载接口的实现类，且接口带有 default 的方法默认实现时\n比如这种情况，那么需要用到另一个类中的成员字段，所以就必须将另一个类加载之后才能访问：\n1 2 3 4 5 6 7 8 9 10 11 12 13 public class Main { public static void main(String[] args) { System.out.println(Test.str); } public static class Test { static { System.out.println(\u0026#34;初始化\u0026#34;); } public static String str = \u0026#34;啊啊啊\u0026#34;; } } 这里我们就演示一个不太好理解的情况，我们现在将静态成员变量修改为 final 类型的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 public class Main { public static void main(String[] args) { System.out.println(Test.str); } public static class Test { static { System.out.println(\u0026#34;初始化\u0026#34;); } public final static String str = \u0026#34;啊啊啊\u0026#34;; } } 可以看到，在主方法中，我们使用了 Test 类的静态成员变量，并且此静态成员变量是一个 final 类型的，也就是说不可能再发生改变。Test 类会像上面一样被初始化吗？\nldc 从常量池里取值\n很明显，这里使用的是 ldc 指令从常量池中将字符串取出并推向操作数栈顶，也就是说，在编译阶段，整个 Test.str 直接被替换为了对应的字符串（因为 final 不可能发生改变的，编译就会进行优化，直接来个字符串比你去加载类在获取快得多不是吗，反正结果都一样），所以说编译之后，实际上跟 Test 类半毛钱关系都没有了。\n所以说，当你在某些情况下疑惑为什么类加载了或是没有加载时，可以从字节码指令的角度去进行分析，一般情况下，只要遇到 new、getstatic、putstatic、invokestatic这些指令时，都会进行类加载，比如:\n好了，聊完了类的加载触发条件，我们接着来看一下类的详细加载流程\n首先类的生命周期一共有 7 个阶段，而首当其冲的就是加载，加载阶段需要获取此类的二进制数据流，比如我们要从硬盘中读取一个 clas s文件，那么就可以通过文件输入流来获取类文件的 byte[] ，也可以是其他各种途径获取类文件的输入流，甚至网络传输并加载个类也不是不可以。然后交给类加载器进行加载（类加载器可以是 JDK 内置的，也可以是开发者自己撸的，后面会详细介绍）类的所有信息会被加载到方法区中，并且在堆内存中会生成一个代表当前类的 Class 类对象（那么思考一下，同一个 Class 文件加载的类，是唯一存在的吗？），我们可以通过此对象以及反射机制来访问这个类的各种信息。\n数组类要稍微特殊一点，通过前面的检验，我们发现数组在创建后是不会导致类加载的，数组类型本身不会通过类加载器进行加载的，不过你既然要往里面丢对象进去，那最终依然是要加载类的。\n接着我们来看验证阶段，验证阶段相当于是对加载的类进行一次规范校验（因为一个类并不一定是由我们使用 IDEA 编译出来的，有可能是像我们之前那样直接用 ASM 框架写的一个），如果说类的任何地方不符合虚拟机规范，那么这个类是不会验证通过的，如果没有验证机制，那么一旦出现危害虚拟机的操作，整个程序会出现无法预料的后果。\n验证阶段，首先是文件格式的验证：\n是否魔数是否是 咖啡北鼻 主、次版本号是否可以由当前虚拟机运行 Class 文件各个部分完整性 \u0026hellip; 有关类验证的详细过程，可以参考《深入理解Java虚拟机 第三版》268页。\n接下来就是准备阶段了，这个阶段会为类变量分配内存，并为一些字段设定初始值，注意是系统规定的初始值，不是我们手动指定的初始值。\n再往下就是解析阶段，此阶段是将常量池内的符号引用替换为直接引用的过程，也就是说，到这个时候，所有引用变量的指向都是已经切切实实地指向了内存中的对象了。\n再往下就是解析阶段，此阶段是将常量池内的符号引用替换为直接引用的过程，也就是说，到这个时候，所有引用变量的指向都是已经切切实实地指向了内存中的对象了。\n到这里，链接过程就结束了，也就是说这个时候类基本上已经完成大部分内容的初始化了\n最后就是真正的初始化阶段了，从这里开始，类中的 Java 代码部分，才会开始执行，还记得我们之前介绍的 方法吗，它就是在这个时候执行的，比如我们的类中存在一个静态成员变量，并且赋值为 10，或是存在一个静态代码块，那么就会自动生成一个 方法来进行赋值操作，但是这个方法是自动生成的。\n全部完成之后，我们的类就算是加载完成了\n类加载器 Java 提供了类加载器，以便我们自己可以更好地控制类加载，我们可以自定义类加载器，也可以使用官方自带的类加载器去加载类。对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在 Java 虚拟机中的唯一性。\n也就是说，一个类可以由不同的类加载器加载，并且，不同的类加载器加载的出来的类，即使来自同一个 Class 文件，也是不同的，只有两个类来自同一个 Class 文件并且是由同一个类加载器加载的，才能判断为是同一个。默认情况下，所有的类都是由 JDK 自带的类加载器进行加载。\n实际上，JDK 内部提供的类加载器一共有三个，比如上面我们的 Main 类，其实是被 AppClassLoader 加载的，而JDK内部的类，都是由 BootstrapClassLoader 加载的，这其实就是为了实现双亲委派机制而坐的。\n","date":"2024-09-24T15:59:43+08:00","image":"https://akaxedx.github.io/p/jvm-%E8%AF%A6%E8%A7%A3/zoye_hu18340939680479360138.jpeg","permalink":"https://akaxedx.github.io/p/jvm-%E8%AF%A6%E8%A7%A3/","title":"JVM 详解"},{"content":"刷题日记 1. 两数之和 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。\n你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。\n你可以按任意顺序返回答案。\n示例 1：\n1 2 3 输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 示例 2：\n1 2 输入：nums = [3,2,4], target = 6 输出：[1,2] 示例 3：\n1 2 输入：nums = [3,3], target = 6 输出：[0,1] 提示：\n2 \u0026lt;= nums.length \u0026lt;= 104 -109 \u0026lt;= nums[i] \u0026lt;= 109 -109 \u0026lt;= target \u0026lt;= 109 只会存在一个有效答案 **进阶：**你可以想出一个时间复杂度小于 O(n2) 的算法吗？\n思路 使用哈希表保存每个数据以及其下标，一次循环即可完成存储和返回\n题解 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public int[] twoSum(int[] nums, int target) { Map\u0026lt;Integer, Integer\u0026gt; hashtable = new HashMap\u0026lt;Integer, Integer\u0026gt;(); for (int i = 0; i \u0026lt; nums.length; ++i) { if (hashtable.containsKey(target - nums[i])) { return new int[]{hashtable.get(target - nums[i]), i}; } hashtable.put(nums[i], i); } return new int[0]; } } 49. 字母异位词分组 给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。\n字母异位词 是由重新排列源单词的所有字母得到的一个新单词。\n示例 1:\n1 2 输入: strs = [\u0026#34;eat\u0026#34;, \u0026#34;tea\u0026#34;, \u0026#34;tan\u0026#34;, \u0026#34;ate\u0026#34;, \u0026#34;nat\u0026#34;, \u0026#34;bat\u0026#34;] 输出: [[\u0026#34;bat\u0026#34;],[\u0026#34;nat\u0026#34;,\u0026#34;tan\u0026#34;],[\u0026#34;ate\u0026#34;,\u0026#34;eat\u0026#34;,\u0026#34;tea\u0026#34;]] 示例 2:\n1 2 输入: strs = [\u0026#34;\u0026#34;] 输出: [[\u0026#34;\u0026#34;]] 示例 3:\n1 2 输入: strs = [\u0026#34;a\u0026#34;] 输出: [[\u0026#34;a\u0026#34;]] 提示：\n1 \u0026lt;= strs.length \u0026lt;= 104 0 \u0026lt;= strs[i].length \u0026lt;= 100 strs[i] 仅包含小写字母 思路 遍历每一个字符串，对其进行排序，并使用哈希表存储，即可完成分组\n题解 1 2 3 4 5 6 7 8 9 10 11 class Solution { public List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; groupAnagrams(String[] strs) { Map\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; strs.length; i++) { char[] s = strs[i].toCharArray(); Arrays.sort(s); map.computeIfAbsent(new String(s), k-\u0026gt;new ArrayList\u0026lt;\u0026gt;()).add(strs[i]); } return new ArrayList\u0026lt;\u0026gt;(map.values()); } } 128. 最长连续序列 给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。\n请你设计并实现时间复杂度为 O(n) 的算法解决此问题。\n示例 1：\n1 2 3 输入：nums = [100,4,200,1,3,2] 输出：4 解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。 示例 2：\n1 2 输入：nums = [0,3,7,2,5,8,4,6,0,1] 输出：9 提示：\n0 \u0026lt;= nums.length \u0026lt;= 105 -109 \u0026lt;= nums[i] \u0026lt;= 109 思路 双指针，左指针永远指向当前序列开始数字，右指针一直移动，寻找可能的序列最大数，并更新进 currentNum，最后序列长度为 currentNum - nums[left] + 1\n题解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public int longestConsecutive(int[] nums) { if(nums.length == 0) { return 0; } Arrays.sort(nums); int left = 0; int result = 1; int currentNum = nums[left]; for (int i = 1; i \u0026lt; nums.length; i++ ) { if (nums[i] != currentNum \u0026amp;\u0026amp; nums[i] != currentNum+1) { left = i; currentNum = nums[left]; } else { currentNum = nums[i]; result = Math.max(result, currentNum - nums[left] + 1); } } return result; } } 283. 移动零 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。\n请注意 ，必须在不复制数组的情况下原地对数组进行操作。\n示例 1:\n1 2 输入: nums = [0,1,0,3,12] 输出: [1,3,12,0,0] 示例 2:\n1 2 输入: nums = [0] 输出: [0] 提示:\n1 \u0026lt;= nums.length \u0026lt;= 104 -231 \u0026lt;= nums[i] \u0026lt;= 231 - 1 **进阶：**你能尽量减少完成的操作次数吗？\n思路 双指针，左指针指向已处理序列的最后一位，右指针指向待处理序列的第一位，进行换位\n题解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public void moveZeroes(int[] nums) { int n = nums.length, left = 0, right = 0; while (right \u0026lt; n) { if (nums[right] != 0) { swap(nums, left, right); left++; } right++; } } public void swap(int[] nums, int left, int right) { int temp = nums[left]; nums[left] = nums[right]; nums[right] = temp; } } 11. 盛最多水的容器 给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。\n找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。\n返回容器可以储存的最大水量。\n**说明：**你不能倾斜容器。\n示例 1：\n1 2 3 输入：[1,8,6,2,5,4,8,3,7] 输出：49 解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 示例 2：\n1 2 输入：height = [1,1] 输出：1 提示：\nn == height.length 2 \u0026lt;= n \u0026lt;= 105 0 \u0026lt;= height[i] \u0026lt;= 104 思路 双指针，每次移动较短的那个板子，并更新最大值\n题解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int maxArea(int[] height) { int result = 0; int left = 0; int right = height.length-1; while (left != right) { result =Math.max(Math.min(height[left],height[right]) * (right - left), result); if (height[left] \u0026gt;= height[right]) { right--; } else{ left ++; } } return result; } } 15. 三数之和 给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请你返回所有和为 0 且不重复的三元组。\n**注意：**答案中不可以包含重复的三元组。\n示例 1：\n1 2 3 4 5 6 7 8 输入：nums = [-1,0,1,2,-1,-4] 输出：[[-1,-1,2],[-1,0,1]] 解释： nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。 nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。 nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。 不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。 注意，输出的顺序和三元组的顺序并不重要。 示例 2：\n1 2 3 输入：nums = [0,1,1] 输出：[] 解释：唯一可能的三元组和不为 0 。 示例 3：\n1 2 3 输入：nums = [0,0,0] 输出：[[0,0,0]] 解释：唯一可能的三元组和为 0 。 提示：\n3 \u0026lt;= nums.length \u0026lt;= 3000 -105 \u0026lt;= nums[i] \u0026lt;= 105 思路 对数组排序，使用双指针，左指针指向 loop 的下一个，右指针指向数组最后一个，三数和大于 0 ，移动右指针，小于 0 移动右指针，直到会和，注意避免重复值即可，可优化的点，当 loop 值已经大于 0 或者 right 值已经小于零就可以不用继续遍历了，必然不会满足和为 0 的要求\n题解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; threeSum(int[] nums) { Arrays.sort(nums); List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); int last = nums[0] - 1; for (int i = 0; i\u0026lt;nums.length - 2;i++) { int left = i+1; int right = nums.length-1; if (nums[i] == last) { continue; } if (nums[i] \u0026gt; 0 ) return result; if (nums[right] \u0026lt; 0) return result; last = nums[i]; while (left \u0026lt; right) { int sum = nums[i] + nums[left] + nums[right]; if(sum == 0) { result.add(List.of(nums[i],nums[left],nums[right])); for (left++;left\u0026lt;right \u0026amp;\u0026amp; nums[left] == nums[left-1];left++); for (right--;left\u0026lt;right \u0026amp;\u0026amp; nums[right] == nums[right+1];right--); } else if (sum \u0026gt;0) { right --; } else { left++; } } } return result; } } 42. 接雨水 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。\n示例 1：\n1 2 3 输入：height = [0,1,0,2,1,0,1,3,2,1,2,1] 输出：6 解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 示例 2：\n1 2 输入：height = [4,2,0,3,2,5] 输出：9 提示：\nn == height.length 1 \u0026lt;= n \u0026lt;= 2 * 104 0 \u0026lt;= height[i] \u0026lt;= 105 思路 将每一列看成一个桶，这个桶的积水量由有方的最长板子 Hr 和 左方的最长板子 Hl 的最小值所决定，减去自身高度即可求出每个桶子的积水量\n题解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public int trap(int[] height) { int[] Hl = new int[height.length]; int[] Hr = new int[height.length]; // 左右板高数组 int j = height.length - 1; int hl = 0; int hr = 0; int result = 0; for (int i = 0; i \u0026lt; Hl.length; i++) { hl = Math.max(hl,height[i]); hr = Math.max(hr,height[j]); Hl[i] = hl; Hr[j] = hr; j--; } for (int i = 0; i \u0026lt; Hr.length; i++) { result += Math.min(Hl[i],Hr[i]) - height[i]; } return result; } } 进阶思路 灵茶山艾府 思路一 为了减少空间复杂度，使用相向双指针，前缀最大值比后缀最大值小，木板高度就为前缀最大值，前缀更新，反之后缀更新\n题解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public int trap(int[] height) { int ans = 0; int left = 0; int right = height.length - 1; int preMax = 0; // 前缀最大值，随着左指针 left 的移动而更新 int sufMax = 0; // 后缀最大值，随着右指针 right 的移动而更新 while (left \u0026lt; right) { preMax = Math.max(preMax, height[left]); sufMax = Math.max(sufMax, height[right]); ans += preMax \u0026lt; sufMax ? preMax - height[left++] : sufMax - height[right--]; } return ans; } } 思路二 单调栈，难度较高，直接看 视频\n3. 无重复字符的最长子串 给定一个字符串 s ，请你找出其中不含有重复字符的 最长\n子串\n的长度。\n示例 1:\n1 2 3 输入: s = \u0026#34;abcabcbb\u0026#34; 输出: 3 解释: 因为无重复字符的最长子串是 \u0026#34;abc\u0026#34;，所以其长度为 3。 示例 2:\n1 2 3 输入: s = \u0026#34;bbbbb\u0026#34; 输出: 1 解释: 因为无重复字符的最长子串是 \u0026#34;b\u0026#34;，所以其长度为 1。 示例 3:\n1 2 3 4 输入: s = \u0026#34;pwwkew\u0026#34; 输出: 3 解释: 因为无重复字符的最长子串是 \u0026#34;wke\u0026#34;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，\u0026#34;pwke\u0026#34; 是一个子序列，不是子串。 提示：\n0 \u0026lt;= s.length \u0026lt;= 5 * 104 s 由英文字母、数字、符号和空格组成 思路 初始化一个为 0 的滑动窗口，使用哈希表来判断是否有重复值，在遍历的同时，增加滑动窗口的大小，答案即为滑动窗口的大小\n题解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Solution { public int lengthOfLongestSubstring(String s) { char[] cs = s.toCharArray(); Map\u0026lt;Character, Boolean\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); int left = 0; int right = 0; int result = 0; for (char c : cs) { if (!map.containsKey(c)) { map.put(c, true); right++; } else break; } if (right == cs.length) { return right; } right --; while (right \u0026lt;= cs.length - 1) { map.clear(); for (int i = left; i\u0026lt;= right \u0026amp;\u0026amp; right \u0026lt;=cs.length-1;i++){ if (!map.containsKey(cs[i])) { map.put(cs[i],true); if (i == right) { right++; } if (right == cs.length) { right --; return Math.max(result, right - left + 1); } } else { if (i == right) { left ++; } result = Math.max(result, right - left + 1); break; } } } return Math.max(result, right - left + 1); } } 灵茶山艾府 思路 使用哈希表进行记录重复次数，两个指针都从最左处枚举，当出现重复字符时，左端点右移，没有充分字符，右端点右移，返回差值最大值即可\n题解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int lengthOfLongestSubstring(String s) { Map\u0026lt;Character, Integer\u0026gt; m = new HashMap\u0026lt;\u0026gt;(); char[] cs = s.toCharArray(); int left = 0; int result = 0; for (int right = 0; right \u0026lt; cs.length; right++) { if (!m.containsKey(cs[right])) { m.put(cs[right], 0); } m.put(cs[right], m.get(cs[right])+ 1); while (m.get(cs[right]) \u0026gt; 1) { m.put(cs[left], m.get(cs[left]) - 1); left++; } result = Math.max(result, right - left + 1); } return result; } } 438. 找到字符串中所有字母异位词 给定两个字符串 s 和 p，找到 s 中所有 p 的\n异位词\n的子串，返回这些子串的起始索引。不考虑答案输出的顺序。\n示例 1:\n1 2 3 4 5 输入: s = \u0026#34;cbaebabacd\u0026#34;, p = \u0026#34;abc\u0026#34; 输出: [0,6] 解释: 起始索引等于 0 的子串是 \u0026#34;cba\u0026#34;, 它是 \u0026#34;abc\u0026#34; 的异位词。 起始索引等于 6 的子串是 \u0026#34;bac\u0026#34;, 它是 \u0026#34;abc\u0026#34; 的异位词。 示例 2:\n1 2 3 4 5 6 输入: s = \u0026#34;abab\u0026#34;, p = \u0026#34;ab\u0026#34; 输出: [0,1,2] 解释: 起始索引等于 0 的子串是 \u0026#34;ab\u0026#34;, 它是 \u0026#34;ab\u0026#34; 的异位词。 起始索引等于 1 的子串是 \u0026#34;ba\u0026#34;, 它是 \u0026#34;ab\u0026#34; 的异位词。 起始索引等于 2 的子串是 \u0026#34;ab\u0026#34;, 它是 \u0026#34;ab\u0026#34; 的异位词。 提示:\n1 \u0026lt;= s.length, p.length \u0026lt;= 3 * 104 s 和 p 仅包含小写字母 思路 遍历字符串，对每次遍历的进行排序，对遍历到的字串进行排序，如果和待匹配字符串相同，则是异位词，否则不是\n题解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public List\u0026lt;Integer\u0026gt; findAnagrams(String s, String p) { char[] pc = p.toCharArray(); Arrays.sort(pc); String nP = new String(pc); List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i\u0026lt;=s.length() - p.length();i++) { char[] tmp = s.substring(i, i+p.length()).toCharArray(); Arrays.sort(tmp); if ((new String(tmp)).equals(nP)) { result.add(i); } } return result; } } 优化思路 试试使用哈希表，将待匹配词中的出现次数存如哈希表，然后遍历 p，如果将哈希表中的数字清空，则表示是异味词，否则不是，在移位过程中，把减小的数字加回去\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class Solution { public List\u0026lt;Integer\u0026gt; findAnagrams(String s, String p) { if (p.length()\u0026gt;s.length()) { return new ArrayList\u0026lt;\u0026gt;(); } // 初始化 HashMap char[] az = {\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;d\u0026#39;,\u0026#39;e\u0026#39;,\u0026#39;f\u0026#39;,\u0026#39;g\u0026#39;,\u0026#39;h\u0026#39;,\u0026#39;i\u0026#39;,\u0026#39;j\u0026#39;,\u0026#39;k\u0026#39;,\u0026#39;l\u0026#39;,\u0026#39;m\u0026#39;,\u0026#39;n\u0026#39;,\u0026#39;o\u0026#39;,\u0026#39;p\u0026#39;,\u0026#39;q\u0026#39;,\u0026#39;r\u0026#39;,\u0026#39;s\u0026#39;,\u0026#39;t\u0026#39;,\u0026#39;u\u0026#39;,\u0026#39;v\u0026#39;,\u0026#39;w\u0026#39;,\u0026#39;x\u0026#39;,\u0026#39;y\u0026#39;,\u0026#39;z\u0026#39;}; Map\u0026lt;Character, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (char c : az) { map.put(c,0); } for (char c : p.toCharArray()) { map.put(c,map.get(c) + 1); } // 初始化答案列表 List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); char[] sc = s.toCharArray(); // 对第一次遍历的字串进行判断 for (int i = 0; i\u0026lt; p.length();i++) { map.put(sc[i],map.get(sc[i])-1); } // 开始遍历，当 map 全为 0 时，表示是异味子串 for (int i = 0; i \u0026lt;= s.length()-p.length(); i++) { AtomicBoolean skip = new AtomicBoolean(false); map.forEach((k,v)-\u0026gt;{ if (v!=0) { skip.set(true); } }); if (!skip.get()) { result.add(i); } if (i != s.length()-p.length()) { map.put(sc[i], map.get(sc[i]) + 1); map.put(sc[i+p.length()],map.get(sc[i+p.length()])-1); } } return result; } } 560. 和为 K 的子数组 给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的子数组的个数 。\n子数组是数组中元素的连续非空序列。\n示例 1：\n1 2 输入：nums = [1,1,1], k = 2 输出：2 示例 2：\n1 2 输入：nums = [1,2,3], k = 3 输出：2 提示：\n1 \u0026lt;= nums.length \u0026lt;= 2 * 104 -1000 \u0026lt;= nums[i] \u0026lt;= 1000 -107 \u0026lt;= k \u0026lt;= 107 思路 由于数组不是有序的，所以滑动窗口使用有困难，所以尝试使用 前缀和 来进行解题，将数组前缀和计算出，并使用 哈希表 保存前缀和出现次数，更新结果\n题解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public int subarraySum(int[] nums, int k) { int res = 0; // 前缀和 int pre = 0; // 哈希表，统计前缀和出现的次数，并初始化一个虚拟的 0 Map\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(0,1); // 遍历 for (int num : nums) { pre += num; // 出现符合的前缀和 统计加 上前缀和出现次数 if (map.containsKey(pre - k)) { res += map.get(pre - k); } // 更新前缀和 map.put(pre, map.getOrDefault(pre, 0) + 1); } return res; } } 239. 滑动窗口最大值 给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。\n返回 滑动窗口中的最大值 。\n示例 1：\n1 2 3 4 5 6 7 8 9 10 11 输入：nums = [1,3,-1,-3,5,3,6,7], k = 3 输出：[3,3,5,5,6,7] 解释： 滑动窗口的位置 最大值 --------------- ----- [1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 示例 2：\n1 2 输入：nums = [1], k = 1 输出：[1] 提示：\n1 \u0026lt;= nums.length \u0026lt;= 105 -104 \u0026lt;= nums[i] \u0026lt;= 104 1 \u0026lt;= k \u0026lt;= nums.length 思路 遍历的时候记录最大值所在位置（索引），窗口滑动时，如果索引还在其中，就直接对比新加入的数据，否则遍历整个滑动窗口\n题解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Solution { public int[] maxSlidingWindow(int[] nums, int k) { int left = 1; int right = k; int max = -500000; int maxIndex = 0; int index = 1; int[] res = new int[nums.length - k + 1]; for (int i = 0; i \u0026lt;= (k \u0026lt; nums.length ? k:nums.length) - 1;i++) { if (nums[i] \u0026gt;= max) { max = nums[i]; maxIndex = i; } } res[0] = max; if (k \u0026gt; nums.length) { return new int[]{max}; } for (left = 1; right\u0026lt;nums.length;left++) { if (maxIndex \u0026gt;= left \u0026amp;\u0026amp; maxIndex \u0026lt;= right) { if (nums[right] \u0026gt;= max) { max = nums[right]; maxIndex = right; } res[index] = max; index++; } else { max = -500000; for (int i = left; i\u0026lt;= right;i++) { if (nums[i] \u0026gt;= max) { max = nums[i]; maxIndex = i; } } res[index] = max; index++; } right++; } return res; } } 效率。。。很低， O(N*K) 的时间复杂度，与暴力算法没有差别\n灵茶山艾府 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public int[] maxSlidingWindow(int[] nums, int k) { if(nums == null || nums.length \u0026lt; 2) return nums; // 双向队列 保存当前窗口最大值的数组位置 保证队列中数组位置的数值按从大到小排序 LinkedList\u0026lt;Integer\u0026gt; queue = new LinkedList(); // 结果数组 int[] result = new int[nums.length-k+1]; // 遍历nums数组 for(int i = 0;i \u0026lt; nums.length;i++){ // 保证从大到小 如果前面数小则需要依次弹出，直至满足要求 while(!queue.isEmpty() \u0026amp;\u0026amp; nums[queue.peekLast()] \u0026lt;= nums[i]){ queue.pollLast(); } // 添加当前值对应的数组下标 queue.addLast(i); // 判断当前队列中队首的值是否有效 if(queue.peek() \u0026lt;= i-k){ queue.poll(); } // 当窗口长度为k时 保存当前窗口中最大值 if(i+1 \u0026gt;= k){ result[i+1-k] = nums[queue.peek()]; } } return result; } } 76. 最小覆盖子串 给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 \u0026quot;\u0026quot; 。\n注意：\n对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。 如果 s 中存在这样的子串，我们保证它是唯一的答案。 示例 1：\n1 2 3 输入：s = \u0026#34;ADOBECODEBANC\u0026#34;, t = \u0026#34;ABC\u0026#34; 输出：\u0026#34;BANC\u0026#34; 解释：最小覆盖子串 \u0026#34;BANC\u0026#34; 包含来自字符串 t 的 \u0026#39;A\u0026#39;、\u0026#39;B\u0026#39; 和 \u0026#39;C\u0026#39;。 示例 2：\n1 2 3 输入：s = \u0026#34;a\u0026#34;, t = \u0026#34;a\u0026#34; 输出：\u0026#34;a\u0026#34; 解释：整个字符串 s 是最小覆盖子串。 示例 3:\n1 2 3 4 输入: s = \u0026#34;a\u0026#34;, t = \u0026#34;aa\u0026#34; 输出: \u0026#34;\u0026#34; 解释: t 中两个字符 \u0026#39;a\u0026#39; 均应包含在 s 的子串中， 因此没有符合条件的子字符串，返回空字符串。 提示：\nm == s.length n == t.length 1 \u0026lt;= m, n \u0026lt;= 105 s 和 t 由英文字母组成 **进阶：**你能设计一个在 o(m+n) 时间内解决此问题的算法吗？\n思路 滑动窗口，哈希表保存 t 中字符需要的个数，左指针停在第一个 t 中出现的字符处，右指针开始移动，每匹配一个，哈希表中保存到字符个数减 1，当所有字符个数都小于等于 0 时匹配到字串，记录长度，左指针移动，将移动前的个数加回哈希表，每匹配到需要字符，再次判断是否满足条件，记录长度\n题解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 class Solution { public String minWindow(String s, String t) { // 初始化 s 字符数组 char[] sc = s.toCharArray(); char[] ts = t.toCharArray(); if (t.length() == s.length()) { Arrays.sort(sc); Arrays.sort(ts); if ((new String(sc).equals(new String(ts)))) { return s; } else { return \u0026#34;\u0026#34;; } } else if (t.length() \u0026gt; s.length()){ return \u0026#34;\u0026#34;; } // 初始化 map Map\u0026lt;Character, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); int realNeed = 0; for (char c : t.toCharArray()) { map.put(c,map.getOrDefault(c, 0)+1); realNeed++; } int left = 0; int right = 0; // 初始化 窗口指针 while (!map.containsKey(sc[left])) { left++; if (left == s.length()) { return \u0026#34;\u0026#34;; } } right = left; map.put(sc[left], map.get(sc[left])-1); realNeed --; // 初始化最小值 int min = Integer.MAX_VALUE; int tmp = min; String res = \u0026#34;\u0026#34;; while (!(right == s.length() - 1 \u0026amp;\u0026amp; right - left \u0026lt; t.length()-1) \u0026amp;\u0026amp; left != s.length()) { // 计算最小值 if (realNeed == 0) { min = Math.min(min, right - left + 1); if (tmp != min) { res = s.substring(left, right + 1); tmp = min; } } // 左指针移动条件 if (realNeed ==0 || (!map.containsKey(sc[left]))) { // 如果左指针移动时正好是需要的字符，进行特殊处理 if (map.containsKey(sc[left])) { int num = map.get(sc[left]); if (num \u0026gt;= 0) { realNeed ++; } map.put(sc[left], num + 1); } left++; } else { right ++; if (right == s.length()) { break; } if (map.containsKey(sc[right])) { int num = map.get(sc[right]); if (num \u0026gt; 0) { realNeed --; } map.put(sc[right], num - 1); } } } return res; } } 遗憾的是，并没有想出来 O(N + M) 的算法\n灵茶山艾府 基础算法 思路大致和我相同，但是引入 涵盖 思想，实现起来会更加便捷\n什么是「涵盖」\n看示例 1，s 的子串 BANC 中每个字母的出现次数，都大于等于 t=ABC 中每个字母的出现次数，这就叫涵盖。\n初始化 ansLeft=−1, ansRight=m，用来记录最短子串的左右端点，其中 m 是 s 的长度。 用一个哈希表（或者数组）cntT 统计 t 中每个字母的出现次数。 初始化 left=0，以及一个空哈希表（或者数组）cntS，用来统计 s 子串中每个字母的出现次数。 遍历 s，设当前枚举的子串右端点为 right，把 s[right] 的出现次数加一。 遍历 cntS 中的每个字母及其出现次数，如果出现次数都大于等于 cntT 中的字母出现次数： 如果 right−left\u0026lt;ansRight−ansLeft，说明我们找到了更短的子串，更新 ansLeft=left, ansRight=right。 把 s[left] 的出现次数减一。 左端点右移，即 left 加一。 重复上述三步，直到 cntS 有字母的出现次数小于 cntT 中该字母的出现次数为止。 最后，如果 ansLeft\u0026lt;0，说明没有找到符合要求的子串，返回空字符串，否则返回下标 ansLeft 到下标 ansRight 之间的子串。 由于本题大写字母和小写字母都有，为了方便，代码实现时可以直接创建大小为 128 的数组，保证所有 ASCII 字符都可以统计。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Solution { public String minWindow(String S, String t) { char[] s = S.toCharArray(); int m = s.length; int ansLeft = -1; int ansRight = m; int left = 0; int[] cntS = new int[128]; // s 子串字母的出现次数 int[] cntT = new int[128]; // t 中字母的出现次数 for (char c : t.toCharArray()) { cntT[c]++; } for (int right = 0; right \u0026lt; m; right++) { // 移动子串右端点 cntS[s[right]]++; // 右端点字母移入子串 while (isCovered(cntS, cntT)) { // 涵盖 if (right - left \u0026lt; ansRight - ansLeft) { // 找到更短的子串 ansLeft = left; // 记录此时的左右端点 ansRight = right; } cntS[s[left++]]--; // 左端点字母移出子串 } } return ansLeft \u0026lt; 0 ? \u0026#34;\u0026#34; : S.substring(ansLeft, ansRight + 1); } private boolean isCovered(int[] cntS, int[] cntT) { for (int i = \u0026#39;A\u0026#39;; i \u0026lt;= \u0026#39;Z\u0026#39;; i++) { if (cntS[i] \u0026lt; cntT[i]) { return false; } } for (int i = \u0026#39;a\u0026#39;; i \u0026lt;= \u0026#39;z\u0026#39;; i++) { if (cntS[i] \u0026lt; cntT[i]) { return false; } } return true; } } 优化算法 上面的代码每次都要花费 O(∣Σ∣) 的时间去判断是否涵盖，能不能优化到 O(1) 呢？\n可以。用一个变量 less 维护目前子串中有 less 种字母的出现次数小于 t 中字母的出现次数。\n具体来说（注意下面算法中的 less 变量）：\n初始化 ansLeft=−1, ansRight=m，用来记录最短子串的左右端点，其中 m 是 s 的长度。 用一个哈希表（或者数组）cntT 统计 t 中每个字母的出现次数。 初始化 left=0，以及一个空哈希表（或者数组）cntS，用来统计 s 子串中每个字母的出现次数。 初始化 less 为 t 中的不同字母个数。 遍历 s，设当前枚举的子串右端点为 right，把字母 c=s[right] 的出现次数加一。加一后，如果 cntS[c]=cntT[c]，说明 c 的出现次数满足要求，把 less 减一。 如果 less=0，说明 cntS 中的每个字母及其出现次数都大于等于 cntT 中的字母出现次数，那么： 如果 right−left\u0026lt;ansRight−ansLeft，说明我们找到了更短的子串，更新 ansLeft=left, ansRight=right。 把字母 x=s[left] 的出现次数减一。减一前，如果 cntS[x]=cntT[x]，说明 x 的出现次数不满足要求，把 less 加一。 左端点右移，即 left 加一。 重复上述三步，直到 less\u0026gt;0，即 cntS 有字母的出现次数小于 cntT 中该字母的出现次数为止。 最后，如果 ansLeft\u0026lt;0，说明没有找到符合要求的子串，返回空字符串，否则返回下标 ansLeft 到下标 ansRight 之间的子串。 代码实现时，可以把 cntS 和 cntT 合并成一个 cnt，在遍历 s 时，把 s[right] 的出现次数减少，如果减少成 0，就意味着 s 和 t 中的 s[right] 一样多。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public String minWindow(String S, String t) { int[] cnt = new int[128]; int less = 0; for (char c : t.toCharArray()) { if (cnt[c]++ == 0) { less++; // 有 less 种字母的出现次数 \u0026lt; t 中的字母出现次数 } } char[] s = S.toCharArray(); int m = s.length; int ansLeft = -1; int ansRight = m; int left = 0; for (int right = 0; right \u0026lt; m; right++) { // 移动子串右端点 char c = s[right]; // 右端点字母（移入子串） if (--cnt[c] == 0) { less--; // c 的出现次数从 \u0026lt; 变成 \u0026gt;= } while (less == 0) { // 涵盖：所有字母的出现次数都是 \u0026gt;= if (right - left \u0026lt; ansRight - ansLeft) { // 找到更短的子串 ansLeft = left; // 记录此时的左右端点 ansRight = right; } char x = s[left++]; // 左端点字母（移出子串） if (cnt[x]++ == 0) { less++; // x 的出现次数从 \u0026gt;= 变成 \u0026lt; } } } return ansLeft \u0026lt; 0 ? \u0026#34;\u0026#34; : S.substring(ansLeft, ansRight + 1); } } 53. 最大子数组和 给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n子数组\n是数组中的一个连续部分。\n示例 1：\n1 2 3 输入：nums = [-2,1,-3,4,-1,2,1,-5,4] 输出：6 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。 示例 2：\n1 2 输入：nums = [1] 输出：1 示例 3：\n1 2 输入：nums = [5,4,-1,7,8] 输出：23 提示：\n1 \u0026lt;= nums.length \u0026lt;= 105 -104 \u0026lt;= nums[i] \u0026lt;= 104 **进阶：**如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。\n思路 前缀和 + 相向双指针\n题解 ","date":"2024-09-18T16:37:57+08:00","image":"https://akaxedx.github.io/p/leetcode-top-100-%E5%88%B7%E9%A2%98%E6%97%A5%E5%BF%97/zoye_hu10364527454385264162.jpeg","permalink":"https://akaxedx.github.io/p/leetcode-top-100-%E5%88%B7%E9%A2%98%E6%97%A5%E5%BF%97/","title":"LeetCode Top 100 刷题日志"},{"content":"JUC 对线程安全的理解 线程安全指的是，我们写的某段代码，在多个线程同时执行时，不会产生混乱，依然能够得到正常的结果，比如 i++，初始化为0，那么两个线程来同时执行这行代码，如果代码时线程安全的，那么最终结果应该就是一个线程的结果为1，一个线程结果为2，如果出现了两个线程结果都为1，则表示这段代码线程不安全\n对守护线程的理解 线程分为用户线程和守护线程，用户线程就是普通线程，守护线程时 JVM 的后台线程，比如垃圾回收线程就是一个守护线程，守护线程会在其他普通线程都停止运行后自动关闭，我们可以通过设置 thread.setDaemon(true) 来把一个线程设置为守护线程\n并发、并行、串行之间的区别 串行：一个任务执行完，才能执行下一个 并行：两个任务同时执行 并发：两个任务看上去是同时执行的，但实际上是任务被分成了很多分，然后一个一个执行 Java 避免死锁 造成死锁的原因 一个资源每次只能被一个线程使用 一个线程在阻塞等待某个资源时，不释放已占有资源 一个线程已经获得资源，在未使用完之前，不能强行剥夺 若干线程形成头尾相接的循环等待资源关系 这是形成死锁的必须达到的四个条件，只要不满足其中一个，就能避免死锁的形成，而前三个是作为锁的必要条件，所有打破第四个条件，不出现循环等待锁的关系\n开发注意事项 注意加锁顺序，保证每个线程按同样的顺序进行加锁 注意加锁时限，可以针对锁设置超时时间 注意死锁检查，确保在第一时间发现死锁并解决 Java 中创建线程的方式 继承Thread类 1 2 3 4 5 6 7 8 9 10 11 public class TestThread extends Thread{ public static void main(String[] args) { TestThread thread = new TestThread(); thread.start(); } @Override public void run() { System.out.println(\u0026#34;111\u0026#34;); } } 由于 Java 是单继承，直接继承 Thread 会限制继承其他类，因此多用 Runnable 接口实现多线程 Thread 也是继承了 Runnable 接口的类，本质上还是等于继承了 Runnable 接口 实现Runnable接口 1 2 3 4 5 6 7 8 9 10 11 public class TestRunnable implements Runnable{ public static void main(String[] args) { Thread thread = new Thread(new TestRunnable()); thread.start(); } @Override public void run() { System.out.println(\u0026#34;111\u0026#34;); } } 匿名内部类实现多线程\n1 2 3 4 5 6 7 8 9 10 11 public class LambdaThread { public static void main(String[] args) { Thread thread = new Thread(new Runnable() { @Override public void run() { System.out.println(\u0026#34;111\u0026#34;); } }); thread.start(); } } 使用 lambda 表达式简化\n1 2 3 4 5 6 public class LambdaThread { public static void main(String[] args) { Thread thread = new Thread(() -\u0026gt; System.out.println(\u0026#34;111\u0026#34;)); thread.start(); } } 实现 Callable 接口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import java.util.concurrent.Callable; import java.util.concurrent.ExecutionException; import java.util.concurrent.FutureTask; public class TestCallable implements Callable\u0026lt;String\u0026gt; { public static void main(String[] args) throws ExecutionException, InterruptedException { FutureTask\u0026lt;String\u0026gt; futureTask = new FutureTask\u0026lt;\u0026gt;(new TestCallable()); Thread thread = new Thread(futureTask); thread.start(); String result = futureTask.get(); System.out.println(result); } @Override public String call(){ return \u0026#34;111\u0026#34;; } } 与 Runnable 的区别在于可以拿到线程执行的结果，这里需要与 FutureTask 结合使用 而 FutureTask 是继承的 Runnable 接口和 Future 接口的接口 线程池创建线程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; public class TestThreadPool implements Runnable{ public static void main(String[] args) { ExecutorService executorService = Executors.newFixedThreadPool(10); executorService.execute(new TestThreadPool()); } @Override public void run() { System.out.println(\u0026#34;111\u0026#34;); } } 总结 以上四种方式底层均为 Runnable 接口\n线程池底层工作原理 线程池内部通过队列+线程实现的，我们利用线程池执行任务时\n如果此时线程池中的线程数量小于 corePoolSize，即线程池中的线程都处于空闲状态，也要创建新的线程来处理被添加的任务 如果此时线程池中的线程数量等于 corePoolSize，但是缓冲队列 workQueue 未满，那么任务被放入缓冲队列 如果此时线程池中的线程数量大于等于 corePoolSize，缓冲队列 workQueue 满，并且线程池中的数量小于 maximumPoolSize，建新的线程来处理被添加的任务 如果此时线程池中的线程数量大于 corePoolSize，缓冲队列 workQueue 满，并且线程池中的数量等于 maximumPoolSize，那么通过 handler 所指定的策略来处理此任务 当线程池中的线程数量大于 corePoolSize，如果某线程空闲时间超过 keepAliveTime，线程将被终止。这样，线程池可以动态的调整池中的线程数 线程池为什么是先添加队列而不是先创建最大线程 当线程池中的核心线程都在忙时，如果继续往线程池中添加任务，那么任务会先入队列，队列满了之后，才会开新线程。相当于一个公司有十个员工，本来十个员工可以正常处理各种需求，但是随着共公司的发展，需求在慢慢增加，但是一开始这些需求只会增加在待开发列表中，然后这十个员工从待开发列表中获取任务进行处理，但是某一天开发列表满了，十个员工彻底处理不过来了，才会招收新员工\n不建议使用 Executors 创建线程池的原因 FixedThreadPool 当我们使用 Executors 创建 FixedThreadPool 时，对应的构造方法为\n1 2 3 4 5 public static ExecutorService newFixedThreadPool(int nThreads) { return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue\u0026lt;Runnable\u0026gt;()); } 这里 LinkedBlockingQueue 是一个无界的阻塞队列，如果使用该线程池执行任务，如果任务过多就会不断的添加进队列，会有 OOM 的风险 SingleThreadExecutor 当我们使用 Executors 创建 SingleThreadExecutor 时，对应的构造方法为\n1 2 3 4 5 6 public static ExecutorService newSingleThreadExecutor() { return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue\u0026lt;Runnable\u0026gt;())); } 也是 LinkedBlockingQueue 总结 除了 OOM 的风险外，我们使用 Executors 来创建线程池也不能自定义线程的名字，不利于排查问题，所以应该用 ThreadPoolExecutor 直接定义线程池，可以灵活控制\n线程池有哪几种状态，每种状态分别表示什么 RUNNING 表示线程池正常运行，既能接收新任务，也会正常处理队列中的任务\nSHUTDOWN 当调用线程池 shutdown() 方法时，进入 SHUTDOWN 状态，表示线程池正处于关闭状态，不会接收新任务，但会继续把队列中的任务处理完\nSTOP 当调用线程池 shutdownnow() 方法时，线程池进入 STOP 状态，表示线程池正处于停止状态，此状态 不会接收新任务，也不会处理队列中的任务，正在运行的线程也会终断\nTIDYING 线程池中没有线程运行后，线程池状态自动变为 TIDYING，并且调用 terminated()，该方法是空方法，可以自行扩展\nTERMINATED terminated() 方法执行完后，线程池状态变为 TERMINATED\nSynchronized 和 ReentrantLock Synchronized ReentrantLock Java 中的一个关键值 JDK 提供的一个类 自动加锁与释放锁 手动加锁与释放 JVM 层面的锁 API 层面的锁 非公平锁 公平锁或非公平锁 锁的是对象，锁信息保存在对象头中 int 类型的 state 标识来标识锁的状态 底层有锁升级的过程 没有锁升级的过程 ReentrantLock 分为公平和非公平锁，底层是怎么实现的 首先，不管是公平锁还是非公平锁，他们的底层实现都会用 AQS 来进行排队，他们的区别在于线程在使用 lock() 方法加锁时：\n公平锁：检查 AQS 队列中是否存在线程在排队，如果有，则当前线程也进行排队 非公平锁：不检查是否排队，直接竞争锁 总结 不管是否是公平锁，一旦没竞争到锁，都会进行排队，当锁释放时，都是唤醒排在最前面的线程，所以非公平锁知识体现在的线程加锁阶段，而没有体现在线程被唤醒阶段\nReentrantLock 是可重入锁，不管是否公平\nReentrantLock 中 tryLock 和 lock 方法的区别 tryLock 表示尝试加锁，可能加到可能加不到。该方法不会阻塞线程，加到返回 true，没有返回 false lock 表示阻塞加锁，线程会阻塞直到加到锁，方法也没有返回值 CountDownLatch 和 Semaphore 的区别和底层原理 CountDownLatch CountDownLatch 表示计数器，可以给 CountDownLatch 设置一个数字，一个线程调用 CountDownLatch 的 await() 将会阻塞，其他线程可以调用 CountDownLatch 的 countDown() 方法来对 CountDownLatch 中的数字减一，当数字为 0 后，所有 await 的线程将会被唤醒\n原理：待用 await() 方法的线程会利用 AQS 排队，一旦数字被减为0，则会将 AQS 中排队的线程依此唤醒\nSemaphore Semaphore 表示信号量，可以设置许可的个数，表示同时允许最多多少个线程使用该信号量，通过 acquire() 来获取许可，如果没有许可可用则线程阻塞，并通过 AQS 来排队，可以通过 release() 方法来释放许可，当某个线程释放了某个许可后，会从 AQS 中正在排队的第一个线程一次唤醒，直到没有空闲许可\n谈谈对 AQS 的理解，AQS 如何实现可重入锁 AQS 时一个 Java 线程同步的框架，是 JDK 中很多锁工具的核心实现框架 在 AQS 中，维护了一个信号量 state 和一个线程组成的双向链表队列，其中，这个线程队列，就是用来给线程排队用的，而state 就像是一个红绿灯，用来控制线程排队或者放行的，在不同场景下有不同的意义 在可重入锁这个场景下，state 就用来表示加锁次数，0表示无锁，每加一次锁，state 就加1，释放减1 Synchronized 锁是怎么升级的 偏向锁：在锁对象的对象头中记录一下当前获取到该锁的线程 ID，该线程下次如果又来获取该锁就可以直接获取到了，也就是支持锁重入 轻量级锁：有偏向锁升级，当一个线程获取到锁后，此时这把锁是偏向锁，此时又有第二个线程来竞争锁，偏向锁会升级为轻量级锁，轻量级锁通过自旋实现，不会阻塞线程 自旋次数过多仍没有获取到锁，则会升级成重量级锁，重量级锁会导致线程阻塞 自旋锁：自旋锁就是线程在获取锁的过程中，不会去阻塞线程，也就无所谓唤醒线程，阻塞和唤醒这两个步骤都是需要操作系统去进行的，比较耗费时间，自旋锁是线程通过 CAS 获取预期的一个标记，如果没获取到则循环获取，这个过程线程一直在运行中，没有使用太多操作系统资源，比较轻量 ThreadLocal的应用场景，底层实现是什么样的 ThreadLocal 底层 ThreadLocal 是 Java 中所提供的线程本地存储机制，可以利用该机制将数据 缓存在某个线程内部，该线程可以在任意时刻、任意方法中获取缓存的数据 ThreadLocal 底层是通过 ThreadLocalMap 实现的，每个 Thread 对象中都存在一个 ThreadLocalMap，Map 的 key 为 Threadlocal 对象，Map 的 value 为需要缓存的值 1 2 3 4 5 6 7 8 9 10 11 12 13 public class TestThreadLocal { private ThreadLocal\u0026lt;String\u0026gt; local = new ThreadLocal\u0026lt;\u0026gt;(); public void a() { local.set(\u0026#34;111\u0026#34;); b(); } public void b() { String s = local.get(); System.out.println(s); } } 在线程池中使用 ThreadLocal 会造成内存泄漏，因为当 ThreadLocal 对象使用完后，应该把设置的 key，value 也就是 Entry 对象进行回收，但线程池中的线程不会回收，而线程对象是通过强引用指向 ThreadLocalMap，ThreadLocalMap 也是通过强引用指向 Entry 对象，线程不被回收，Entry 对象也就不会回收，从而出现内存泄漏。解决方法是，在使用 ThreadLocal 对象后，手动调用 ThreadLocal d remove 方法，手动清除 Entry 对象 应用场景 一个经典的场景就是连接管理（一个线程持有一个连接，该连接对象可以在不同方法之间进行传递，线程之间不共享同一个连接\nJava 基础 JUC =================================\n更新于 2024.9.5，旧版在淘汰文章中可以查看\n=================================\n=================================\n没想到吧，又被淘汰了\n=================================\n什么是锁 在并发环境下，多个线程会对同一个线程进行争抢，可能会导致数据不一致，为了解决这一问题，很多编程语言都引入了锁机制，通过一种抽象的锁对资源进行锁定\nJava 锁机制 红色区域各个线程私有的，蓝色是公有的，私有部分不会导致线程安全问题，而蓝色区域被所有线程共享，需要锁机制来进行限制，锁是一种抽象的概念，Java 是怎么实现的？\nJava 对象结构 实例数据 初始化所设置的属性方法等内容\n填充字节 为了满足 Java 对象是 8 bit 的倍数所设计的，填充的无用字节\n对象头 Class Point：指针，指向当前对象类型所在方法区中的类型数据 Mark Word：存放了和当前对象运行时状态有关的数据 Synchronized 关键字 编译后生成字节码指令 monitorenter 和 monitorexit 来管控线程\nMonitor -\u0026gt; 管程、监视器\n当一个线程进入 monitor，其他线程只能等待，下图为重量级锁的机制\n为了避免切换内核态的时间超过运行程序时间，Java 对 Synchronized 进行了优化\n升级过程 无锁：\n无竞争，直接调用 存在竞争，使用非锁方式同步线程，这就是 CAS，CAS 在操作系统中通过一条命令保证原子性 偏向锁：\n一个对象被加锁了，但实际运行时只有一个线程会获取这个锁，理想状态我们不通过线程状态切换，也不通过 CAS 来获取锁，因为多多少少会浪费资源。我们让这个对象认识这个线程，直接交出资源即可。 实现方式：如果当前锁标志位为 01，那么判断倒数低 3 个 bit 是否为 1，如果为 1，于是读取 前 23 个 bit，这 23 个bit 就是线程 ID，通过对比当前线程 ID 和存放的线程 ID 是否相同，假如发生了变化，不止一个线程在使用这个对象，则从偏向锁升级成轻量级锁 轻量级锁：\n实现方式：当前锁标志位为 00，则在**虚拟机栈（线程私有）**中开辟 Lock Record 空间，线程通过 CAS 去尝试获取锁，一旦获得，就会复制对象头中的 Mark Word 到 Lock Record 中，并将 Lock Record 中的 Owner 指针指向该对象，另一方面，Mark Word 的前 30 个 bit 生成一个指针，指向线程虚拟机栈中的 Lock Record，这样实现了线程和对象锁的绑定 其他线程来了：其他线程自旋等待，自旋可以理解为一种轮询，线程不断地循环尝试获取目标对象的锁，如果锁释放了就获取，没释放就继续下一轮循环。不同于操作系统挂起，如果线程很快的就能获取到锁，那么就不需要线程中断和恢复，效率更高。自旋相当于 CPU 空转，如果长时间空转，会浪费 CPU 资源，于是出现了 适应性自旋的优化，自旋次数不再固定，而是视上一次在同一锁上自旋获取锁的情况而动态变化的 自旋等待的线程超过一个或等待时间过长，轻量级锁将升级为重量级锁，将通过 monitor 来进行控制资源，资源将被完全锁定，线程将被挂起等待 CAS 上面的部分多次提到了 CAS，CAS 究竟是什么\n当多个线程来操作资源时，我们第一反应就是使用 互斥锁，但互斥锁是 悲观的\n悲观锁 操作系统将悲观的认为如果不严格同步线程的调用，那么系统是一定会出问题的，互斥锁将完全锁定资源，不允许其他线程调用。这种同步机制就是悲观锁\n但是在读操作多，或者同步代码块执行的耗时远远小于线程切换的耗时时，就本末倒置了，于是不想使用互斥锁，那么如何解决？CAS 就此诞生\nCAS（compare and swap） 比较然后交换\n原理： 资源对象将有一个状态值标记，为 0 可以获取，为 1 正被占用 A 线程 B 线程 同时调用该资源对象，他们都读取到了该资源对象的状态值为 0，于是各自生成两个值，oldValue：之前读到的资源对象的状态值，newValue：代表想要将资源对象的状态值更新后的值 A 抢到时间片，将 oldValue 与资源对象的状态值进行 compare，发现一致，于是 swap 为 newValue，B 线程后来 compare 时发现不一致，放弃 swap，进行自旋 缺陷： 由于没有进行任何线程同步，在 A 线程 swap 的一瞬间，B 抢到时间片，也进行 swap，A B 线程同时获取资源 所以 compare 和 swap 必须被绑定，同时只能用一条线程可以操作，也就是必须保证 CAS 原子性 解决方法： 不同架构的 CPU 都提供了指令级别的 CAS 原子操作，在 x86 架构下，通过 cmpxchg 指令支持 CAS，在 ARM 架构下，通过 LL/SC 实现 CAS，不需要通过操作系统的同步原语（mutex），CPU 已经原生地支持了 CAS，上层可以直接调用 由于不会锁定资源，且认为线程需要修改对象资源的时候乐观认为对象状态值没有被其他线程修改过，而是每次自己主动尝试去 compare 状态值，因此也被称为 乐观锁，所以 乐观锁 其实是无锁同步机制\nJava 如何利用 CAS 特性进行无锁编程 一个需求，多线程打印 0 到 1000\n无锁： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class LambdaThread { static Integer num = 0; public static void main(String[] args) { for (int i = 0; i \u0026lt; 3; i++) { Thread t = new Thread(new Runnable() { @Override public void run() { while (num \u0026lt; 1000) { System.out.println(\u0026#34;thread name:\u0026#34; + Thread.currentThread().getName() + \u0026#34; :\u0026#34; + num++); } } }); t.start(); } } } 互斥锁 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class LambdaThread { static Integer num = 0; public static void main(String[] args) { for (int i = 0; i \u0026lt; 3; i++) { Thread t = new Thread(new Runnable() { @Override public void run() { synchronized (LambdaThread.class) { while (num \u0026lt; 1000) { System.out.println(\u0026#34;thread name:\u0026#34; + Thread.currentThread().getName() + \u0026#34; :\u0026#34; + num++); } } } }); t.start(); } } } 乐观锁 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class LambdaThread { static AtomicInteger num = new AtomicInteger(0); public static void main(String[] args) { for (int i = 0; i \u0026lt; 3; i++) { Thread t = new Thread(new Runnable() { @Override public void run() { while (num.get() \u0026lt; 1000) { System.out.println(\u0026#34;thread name:\u0026#34; + Thread.currentThread().getName() + \u0026#34; :\u0026#34; + num.incrementAndGet()); } } }); t.start(); } } } AtomicInteger 内容： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class AtomicInteger extends Number implements java.io.Serializable { private static final long serialVersionUID = 6214790243416807050L; // setup to use Unsafe.compareAndSwapInt for updates private static final Unsafe unsafe = Unsafe.getUnsafe(); private static final long valueOffset; static { try { valueOffset = unsafe.objectFieldOffset (AtomicInteger.class.getDeclaredField(\u0026#34;value\u0026#34;)); } catch (Exception ex) { throw new Error(ex); } } .......... public final int getAndIncrement() { return unsafe.getAndAddInt(this, valueOffset, 1); } } getAndAddInt： 1 2 3 4 5 6 7 public final int getAndAddInt(Object o, long offset, int delta) { int v; do { v = getIntVolatile(o, offset); } while (!compareAndSwapInt(o, offset, v, v + delta)); return v; } do while 就是自旋，默认 10 次\ncompareAndSwapInt： 1 2 3 public final native boolean compareAndSwapInt(Object o, long offset, int expected, int x); 被 native 修饰，底层 C++\nUnsafe： AQS AbstractQueuedSynchronizer\n成员属性 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /** * Head of the wait queue, lazily initialized. Except for * initialization, it is modified only via method setHead. Note: * If head exists, its waitStatus is guaranteed not to be * CANCELLED. */ private transient volatile Node head; /** * Tail of the wait queue, lazily initialized. Modified only via * method enq to add new wait node. */ private transient volatile Node tail; /** * The synchronization state. */ private volatile int state; state 不为 boolean 的原因： 线程获取锁的两种模式 独占模式：一旦被占用，其他线程不能占用 共享模式：一旦被占用，其他共享模式下的线程能占用 所以需要使用 int 来表示占用的数量 头尾节点 线程在当前时刻没有获取到共享资源，可以选择进行排队 这个队列的数据结构是 FIFO 先进先出双向链表 Node：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 static final class Node { /** Marker to indicate a node is waiting in shared mode */ static final Node SHARED = new Node(); /** Marker to indicate a node is waiting in exclusive mode */ static final Node EXCLUSIVE = null; /** waitStatus value to indicate thread has cancelled */ static final int CANCELLED = 1; /** waitStatus value to indicate successor\u0026#39;s thread needs unparking */ static final int SIGNAL = -1; /** waitStatus value to indicate thread is waiting on condition */ static final int CONDITION = -2; /** * waitStatus value to indicate the next acquireShared should * unconditionally propagate */ static final int PROPAGATE = -3; volatile int waitStatus; volatile Node prev; volatile Node next; volatile Thread thread; Node nextWaiter; } 两种场景 尝试获取锁（修改标记位，立即返回） 1 2 3 protected boolean tryAcquire(int arg) { throw new UnsupportedOperationException(); } AQS 继承类必须重写这个方法，给上层提供操作空间\n获取锁（修改标记位），愿意进入队列等待，直到获取 1 2 3 4 5 public final void acquire(int arg) { if (!tryAcquire(arg) \u0026amp;\u0026amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); } 不允许修改 final\n调用 tryAcquire() ，失败直接跳出\naddWaiter：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 private Node addWaiter(Node mode) { Node node = new Node(Thread.currentThread(), mode); // Try the fast path of enq; backup to full enq on failure Node pred = tail; if (pred != null) { node.prev = pred; if (compareAndSetTail(pred, node)) { pred.next = node; return node; } } enq(node); return node; } 将当前线程封装成一个 Node 对象\nacquireQueued：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 final boolean acquireQueued(final Node node, int arg) { boolean failed = true; try { boolean interrupted = false; for (;;) { final Node p = node.predecessor(); if (p == head \u0026amp;\u0026amp; tryAcquire(arg)) { setHead(node); p.next = null; // help GC failed = false; return interrupted; } if (shouldParkAfterFailedAcquire(p, node) \u0026amp;\u0026amp; parkAndCheckInterrupt()) interrupted = true; } } finally { if (failed) cancelAcquire(node); } } 这里的 if (shouldParkAfterFailedAcquire(p, node) \u0026amp;\u0026amp; parkAndCheckInterrupt()) 会判断当前节点是否有资格获取锁，没资格的挂起，避免没必要的自旋\nTips Java 中断 作用于线程对象，并不会直接促成该线程挂起，会根据当前状态产生不同效果 如果当前线程是运行状态，那么改线程的运行并不会被影响 如果当前线程是等待状态，那么对该线程 interrupt 使其抛出中断异常 判断方法 shouldParkAfterFailedAcquire 如果前置节点正在等待拿锁，那么当前节点自然可以挂起休息，返回 true 如果前置节点状态 \u0026gt; 0 ，那么只会是 CANCELLED，直接从队列里删除 如果前置节点是其他状态，那么既然当前节点已经加入，那么前置节点状态设置为 SINGLE，让其被唤醒，返回 false 当 shouldParkAfterFailedAcquire 返回 true 执行真正的挂起操作\n1 2 3 4 private final boolean parkAndCheckInterrupt() { LockSupport.park(this); // 在这里挂起 return Thread.interrupted(); } 唤醒时机 1 2 3 4 5 6 7 8 9 10 11 12 13 protected boolean tryRelease(int arg) { throw new UnsupportedOperationException(); } public final boolean release(int arg) { if (tryRelease(arg)) { Node h = head; if (h != null \u0026amp;\u0026amp; h.waitStatus != 0) unparkSuccessor(h); return true; } return false; } unparkSuccessor：此方法是为了唤醒 Head 后面的 Node，使其自旋地获取锁\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 private void unparkSuccessor(Node node) { /* * If status is negative (i.e., possibly needing signal) try * to clear in anticipation of signalling. It is OK if this * fails or if status is changed by waiting thread. */ int ws = node.waitStatus; if (ws \u0026lt; 0) compareAndSetWaitStatus(node, ws, 0); /* * Thread to unpark is held in successor, which is normally * just the next node. But if cancelled or apparently null, * traverse backwards from tail to find the actual * non-cancelled successor. */ Node s = node.next; if (s == null || s.waitStatus \u0026gt; 0) { s = null; for (Node t = tail; t != null \u0026amp;\u0026amp; t != node; t = t.prev) if (t.waitStatus \u0026lt;= 0) s = t; } if (s != null) LockSupport.unpark(s.thread); } 从尾节点开始找，找到 Head 后最靠前的 ws 小于等于 0 的节点，并唤醒对应的线程\n一旦线程被唤醒，他就会继续调用 acquireQueued 方法进行自旋尝试获取锁\nAQS 相关的组件、工具 ReentrantLock ReentrantLock 基于 AQS，\n在并发编程中可以实现公平锁和非公平锁来对共享资源进行同步\n同时，和 synchronized 一样，ReentrantLock 支持可重入\n除此之外，ReentrantLock 在调度上更灵活，支持更多丰富的内容\nLock 接口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public interface Lock { void lock(); void lockInterruptibly() throws InterruptedException; boolean tryLock(); boolean tryLock(long time, TimeUnit unit) throws InterruptedException; void unlock(); Condition newCondition(); } 源码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class ReentrantLock implements Lock, java.io.Serializable { private static final long serialVersionUID = 7373984872572414699L; /** Synchronizer providing all implementation mechanics */ private final Sync sync; /** * Base of synchronization control for this lock. Subclassed * into fair and nonfair versions below. Uses AQS state to * represent the number of holds on the lock. */ abstract static class Sync extends AbstractQueuedSynchronizer {...} // Sync object for non-fair locks static final class NonfairSync extends Sync {...} // Sync object for fair locks static final class FairSync extends Sync {...} Sync： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 abstract static class Sync extends AbstractQueuedSynchronizer { private static final long serialVersionUID = -5179523762034025860L; abstract void lock(); final boolean nonfairTryAcquire(int acquires) {...} protected final boolean tryRelease(int releases) {...} protected final boolean isHeldExclusively() {...} final ConditionObject newCondition() {...} // Methods relayed from outer class final Thread getOwner() {...} final int getHoldCount() {...} final boolean isLocked() {...} private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException {...} } 继承自 AQS ，可以使用 AQS 的特性\n被 abstract 修饰，需要子类来实例化\nJava 核心类库及其底层原理 JDK，JRE，JVM之间的区别 JDK JDK 是 JAVA 标准开发包，提供了编译、运行 Java 程序所需的各种工具和资源，包括 Java 编译器、Java 运行时环境，以及常见的 Java 类库等\nJRE JRE 是 Java 运行环境，用于运行 Java 的字节码文件。JRE 中包括了 JVM 以及 JVM 工作所需的类库，普通用户只需要安装 JRE 来运行 Java 程序，而程序开发者必须安装 JDK 来编译、调试程序\nJVM JVM 是 Java 虚拟机，是 JRE 的一部分，是整个 Java 实现跨平台最核心的部分，负责运行字节码文件\ne.g. 写 Java 代码，txt 就可以写，但是写出来的代码，想要运行，需要编译成字节码，需要编译器，JDK 中包含编译器 javac，编译折后的字节码想要运行，需要一个可执行字节码的程序，这个程序就是 JVM，专门用来执行 Java 字节码的\n开发需要 JDK\n运行编译好的 Java 字节码文件需要 JRE\nJVM 在执行 Java 字节码时，需要把字节码解释为机器指令，而不同操作系统的机器指令有可能是不一样的，导致不同操作系统的 JVM 是不一样的，所以安装 JDK 时要选择操作系统\n另外 JVM 执行的是 Java 字节码，所以只要编译后是 Java 字节码，都可以在 JVM 上运行，比如 Apache Groovy，Scala ， Kotlin 等\nJVM 中，哪些时线程共享区 项目如何排查 JVM 问题 对于还在正常运行的系统 可以使用 jmap 来查看 JVM 中各个区域的使用情况 可以使用 jstack 来查看线程运行情况，比如哪些线程阻塞、是否出现死锁 可以用 jstack 命令来查看垃圾回收的情况，特别是 fullgc，如果发现 fullgc 比较频繁，那么就得进行调优 通过各个命令的结果或 jvisualvm 等工具来进行分析 首先，初步猜测频繁 fullgc 的原因，如过频繁发生 fuulgc 又没有 OOM，那么表示 fuulgc 实际上是回收了很多对象了，所以这些对象最好能在 younggc 过程中就直接回收掉，避免这些对象进入老年代，对于这种情况，就要考虑这些存活时间不长的对象是不是比较大，导致年轻代放不下，直接进入老年代，尝试加大年轻代的大学，如果改完后，fullgc 减少，那么修改有效 同时，还可以找到占用 CPU 最多的线程，定位到具体的方法，优化这个方法的执行，看是否能避免某些对象的创建，从而节省内存 对于已经发生 OOM 的系统 一般生产系统中都会设置当系统发生 OOM 时，生成当时的 dump 文件 可以利用 jsisualvm 等工具来分析 dump 文件 根据 dump 文件找到异常的实例对象，和异常的线程（占用 CPU 高），定位到具体的代码 然后进行详细的分析和调试 总结 调优不是一蹴而就的，需要分析、推理、实践、总结、再分析\nhashCode() 与 equals() 之间的关系 理论 在 Java 中，每个对象都可以调用自己的 hashCode() 方法得到自己的哈希值，相当于对象的指纹信息，通常来说不会有相同的，但 Java 中做不到这样绝对，但我们仍然可以使用 hashCode 来做一些判断\n如果两个对象的 hashCode 不同，这两个对象一定同 如果两个对象的 hashCode 相同，不代表一定是同一个对象 如果两个对象相等，那么 hashCode 一定相同 在 Java 的一些集合类的实现中，在比较两个对象是否相等时，会根据上面的原则，先调用 hashCode() 方法进行比较，如果不同直接判定不同，如果相同进一步调用 equals() 方法。equals() 方法就是来最终确定两个对象是不是相等的。equals() 的实现通常会很重，逻辑较多。\n所以 在我们重写了 equals() 方法时，一定要确保 hashCode() 方法能遵循上述规则\ndemo 演示 未重写 hashCode()\nUser 类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package JAVA.hash_and_equals; public class User { private String name; public User(String name) { this.name = name; } public String getName() { return name; } @Override public boolean equals(Object obj) { User user = (User) obj; return user.getName().equals(this.name); } } 调用\n1 2 3 4 5 6 7 8 9 10 11 12 package JAVA.hash_and_equals; import java.util.HashMap; public class TestHashEquals { public static void main(String[] args) { HashMap\u0026lt;User, String\u0026gt; hashMap = new HashMap\u0026lt;\u0026gt;(); hashMap.put(new User(\u0026#34;AKAxedx\u0026#34;), \u0026#34;111\u0026#34;); System.out.println(hashMap.get(new User(\u0026#34;AKAxedx\u0026#34;))); } } 运行结果：null\n原因：hashMap 中的 get 方法如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public V get(Object key) { Node\u0026lt;K,V\u0026gt; e; return (e = getNode(key)) == null ? null : e.value; } /** * Implements Map.get and related methods. * * @param key the key * @return the node, or null if none */ final Node\u0026lt;K,V\u0026gt; getNode(Object key) { Node\u0026lt;K,V\u0026gt;[] tab; Node\u0026lt;K,V\u0026gt; first, e; int n, hash; K k; if ((tab = table) != null \u0026amp;\u0026amp; (n = tab.length) \u0026gt; 0 \u0026amp;\u0026amp; (first = tab[(n - 1) \u0026amp; (hash = hash(key))]) != null) { if (first.hash == hash \u0026amp;\u0026amp; // always check first node ((k = first.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) return first; if ((e = first.next) != null) { if (first instanceof TreeNode) return ((TreeNode\u0026lt;K,V\u0026gt;)first).getTreeNode(hash, key); do { //这里调用了 hash 进行对比 if (e.hash == hash \u0026amp;\u0026amp; ((k = e.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k))))// 短路掉了 equals() 方法 return e; } while ((e = e.next) != null); } } return null; } 重写 User\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package JAVA.hash_and_equals; public class User { private String name; public User(String name) { this.name = name; } public String getName() { return name; } @Override public boolean equals(Object obj) { User user = (User) obj; return user.getName().equals(this.name); } @Override public int hashCode() { return name.hashCode(); } } 运行结果：111\n== 和 equals 方法的区别 == 如果比较基本数据类型，比较的是值，如果是引用类型，比较的是引用地址 equals() 使用 equals() 方法比较，具体逻辑看具体实现，比如String 类型，虽然是引用类型，但是 String 重写了 equals() 方法，比较的是字符串中各个字符是否相等 String、StringBuffer、StringBuilder的区别 String 是不可变的，如果尝试修改，会生成一个字符串对象，StringBuffer 和 StringBuilder 是可变的 StringBuffer 是线程安全的，StringBuilder 是线程不安全的，单线程环境下 StringBuilder 效率更高 泛型中 extends 和 super 的区别 \u003c? extends T\u003e 表示包括 T 在内的任何 T 的子类 \u003c? super T\u003e 表示包括 T 在内的任何 T 的父类 重载和重写的区别 重载 发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时\n重写 发生在父子类中，方法名，参数列表必须相同，返回值返回小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。如果父类方法访问修饰符为 private 则不能重写该方法\nList 和 Set 的区别 List 有序，按对象进入的顺序保存对象，可重复，允许多个 Null 元素对象，可以使用 Iterator 取出所有元素，再逐一遍历，还可以使用 get 获取指定下标的元素\nSet 无序，不可重复，最多允许一个 Null 元素对象，取元素时只能使用 Iterator 接口取得所有元素，再逐一遍历\nArrayList 和 LinkedList 的区别 底层数据结构不同，ArrayList 基于数组，而LinkedList 基于链表\n由于底层数据结构不同，他们使用的场景也不同，ArrayList 更适合随机查找，LinkedList 更适合删除和添加。查询、添加、删除的时间复杂度不同\n都是先了 List 接口，而 LinkedList 还而额外实现了 Deque 接口，所以 LinkedList 还能当队列来使用\nConcurrentHashMap 的扩容机制 JDK 1.7版本 ConcurrentHashMap 是基于 Segment 分段实现的 每个 Segment 相当于一个小的 HashMap 每个 Segment 内部会进行扩容，和 HashMap 扩容类似 先生成新的数组，然后转移元素到新数组中 扩容的判断也是每个 Segment 内部单独判断的，判断是否超过阈值 JDK 1.8版本 不再使用 Segment 实现 当某个线程进行 put 时，如果 ConcurrentHashMap 正在扩容，那么该线程一起进行扩容 如果某个线程 put 时，没有在进行扩容，则将 key-value 添加到 ConcurrentHashMap 中，然后判断是否超过阈值，超过进行扩容 ConcurrentHashMap 支持多线程同时扩容 扩容之前生成一个新的数组 在转移元素时，先将原数组分组，将每组分给不同的线程来进行元素的转移，每个线程负责一组或多组的元素转移工作 JDK1.7-JDK1.8 HashMap 发生了什么变化 JDK1.7 数组 + 链表\n头插法\nhash 算法复杂\nJDK1.8 数组 + 链表 + 红黑树\n红黑树提高插入和查询的整体效率\n尾插法\nhash 算法简化\nHashMap 的 put 方法 大致如下\n通过哈希算法与与运算计算得出数组下标 如果数组下标为空，则将 key-value 封装为 Entry (1.8 版本为 Node) 对象，并放入该位置 如果是 JDK1.7，先判断是否扩容，如果扩容，就进行扩容，不扩容就生成 Entry 对象，使用头插法插入当前位置的链表中 如果是 JDK1.8，先判断该位置上的 Node 的类型（链表、红黑树） 如果是红黑树 Node，将 key-value 封装成一个 红黑树节点并添加进树中（插入/更新） 如果是链表 Node，则将 key-value 封装为一个链表 Node 并通过尾插法插入当前链表尾部，由于尾插进行了遍历，遍历过程中进行插入或更新，如果长度大于 8，将链表转换成红黑树 插入链表或红黑树后才进行判单是否进行扩容 HashMap 的扩容机制 JDK1.7 先生成新数组 遍历老数组的每个位置上的链表的每个元素 取出每个元素的 key，并基于新的数组长度，计算出每个元素再新数组中的下标 将元素添加到新数组中去 所有元素转移完后，将新数组赋值给 HashMap 对象中的 table 属性 JDK1.8 先生成新数组 遍历老数组中的每个位置的链表或红黑树 如果是链表，则直接将链表中的每个元素重新计算下标，添加到新数组中 如果是红黑树，先遍历红黑树，计算每个元素对应的下标位置 统计每个下标位置的元素个数 如果该位置的元素超过了8，生成一个新的红黑树，并将根节点的添加到新数组的对应位置 如果没有超过8，则生成一个链表，将头节点添加到数组的对应位置 所有元素转移完了之后，将新数组赋值给 HashMap 对象的 table 属性 深拷贝和浅拷贝 深拷贝和浅拷贝就是指对象的拷贝，一个对象中存在两种类型的属性，一种是基本数据类型，一种是实例对象的引用\n浅拷贝是指，只拷贝基本数据类型的值，以及实例对象的引用地址，不会复制一份引用地址所指向的对象，也就是浅拷贝出来的对象，内部的属性指向的是同一个对象 深拷贝是指，既会拷贝基本数据类型的值，也会针对实例对象的引用地址所指向的对象进行复制，深拷贝出来的对象，内部的属性指向的不是同一个对象 CopyOnWriteArrayList 的底层原理 首先 CopyOnWriteArrayList 内部也是数组，在向 CopyOnWriteArrayList 添加元素时，会赋值一个新的数组，写操作在新数组上进行，读操作在原数组上进行 写操作加锁，防止出现并发写入丢失数据的问题 写操作结束之后会把原数组指向新数组 CopyOnWriteArrayList 允许在写操作时来读数据，提高了读的性能，适合多读少写的应用场景，但是 CopyOnWriteArrayList 比较占内存，同时可能读到的数据不是最新的，不适合实时性要求很高的场景 什么是字节码，采用字节码的好处 编译器将 Java 源文件编译成字节码文件，可以做到一次编译到处允许，win 上编译好的 class 文件，可以直接在 linux 上允许，通过这种方式做到跨平台，前提是，不同的操作系统上安装的 JDK 或 JRE 是不同的，虽然字节码通用，但把字节码解释成各个操作系统机器码是需要不同的解释器的，所以各个操作系统需要自己的 JDK 和 JRE\n采用自己尔玛的好处，一方面实现了跨平台，一方面提高了代码执行的性能，编译器在编译源代码时可以做一些编译器的优化，比如锁消除、标量替换、方法内联等\nJava 异常体系 Java 中所有异常都来自顶级父类 Throwable Throwable 下有两个子类 Exception 和 Error Error 表示非常严重的错误，比如 java.lang.StackOverFlowError 和 OOM ，通常这些错误出现时，仅靠程序自己时解决不了的，可能时虚拟机、磁盘、操作系统层面出现了问题，所有通常不建议在代码中去捕获这些 Error，因为捕获的意义不大，因为程序可能已经运行不了了 Exception 表示异常，表示程序出现 Exception 时，是可以靠自己来解决的，比如空指针，数组越界等，我们可以捕获这些异常来进行特殊处理 Exception 的子类通常可分为 RuntimeException 和非 RuntimeException 异常 RuntimeException 表示运行期异常，表示这个异常实在代码运行过程中抛出的，这些事非检查异常，程序中可以选择捕获或直接抛出，这些异常一般是由逻辑错误引起的，程序应该从逻辑角度尽可能避免，比如空指针和数组越界 非 RuntimeException 表示非运行期异常，也即是检查异常，是必须进行处理的异常，如果不处理，程序就不能检查异常通过，如 IOException，SQLException 等以及用户自定义的 Exception 异常 什么时候抛出异常，什么时候捕获异常 异常是一种提示，抛出异常相当于告诉上层方法，我抛出了一个异常，我处理不了，交给你处理。而上层方法他也需要判断能否处理这个异常\n所有在写方法时，要考虑本方法能否合理地处理该异常，处理的了捕获，处理不了抛出\nJava 中有哪些类加载器 BootstrapClassLoader：是ExtClassLoader 的父类加载器，赋值加载 %JAVA_HOME%/lib 下的 jar 包和 class 文件 ExtClassLoader 是 AppClassLoader 的父类加载器，负责加载 %JAVA_HOME%/lib/ext 文件夹下的 jar 包和 class 类 AppClassLoader 是自定义类加载器的父类，负责加载 classpath 下的类文件 类加载器双亲委派模型 JVM 中存在三个默认的类加载器\nBootstrapClassLoader ExtClassLoader AppClassLoader JVM 在加载一个类时，会调用 AppClassLoader 的 loadClass 方法来加载这个类，不管在这个方法中，会先使用 ExtClassLoader 的 loadClass 方法来加载类，同样 ExtClassLoader 的 loaderClass 会使用 BootstrapClass 的 loaderClass 方法来加载类，如果 BootstrapClassLoader 加载到了直接成功，如果没有则 ExtClassLoader 加载，如果还没有则 AppClassLoader 加载\n所以，双亲委派指的是，JVM 在加载类时，会委派给父类加载，没加载到才自己进行加载\n一个对象加载到 JVM，再到被 GC 清除，都经历了什么过程 首先把字节码文件内容加载到方法区 根据类信息再堆区创建对象 对象首先会分配再堆区中年轻代的 Eden 区，经过一次 Minor GC 后，如果对象存活，进入 Suvivor 区，在后续的每次 Minor GC中，如果对象一直存活，就会在 Suvivor 区来回拷贝，没移动一次，年龄加1 当年龄超过15后，对象依然存活，对象进入老年代 如果经过 Full GC，被标记为垃圾对象，那么就会被 GC 线程清理掉 怎么确定一个对象到底是不是垃圾 引用计数法：这种方式时给堆内存当中每个对象记录一个引用个数，引用个数为0的就认为是垃圾，这是早期 JDK 中使用的方法，引用计数无法解决循环引用的问题 可达性算法：这种方法是再内存中，从根对象一直向下找引用，找到的对象就不是垃圾，没找的是垃圾 JVM 有哪些垃圾回收算法 标记清除算法： 标记阶段：把垃圾内存标记出来 清除阶段：直接将垃圾内存回收 赭红算法简单，但会产生大量内存碎片 复制算法：为了解决标记清除算法的内存碎片问题，就产生了复制算法，复制算法将内存分为大小相等的两半，每次只是用其中一半，垃圾回收时，将当前这一块的内存活对象全部拷贝到另一半，然后这一半直接清除，这种算法没有内存碎片，但是浪费空间 标记压缩法：为了解决复制算法的缺陷，提出标记压缩法，这张算法在标记阶段和清除算法一样，标记完后，不直接清除垃圾，而是将存活对象往一端移动，然后将边界外的所有内存清除 什么是 STW Stop-The-World，实在垃圾回收算法执行过程当中，需要将 JVM 内存冻结的一种状态，在 STW 状态下，Java 所有线程都是停止执行的-GC线程除外，native 方法可以执行，但是，不能与 JVM 交互，GC 各种算法优化的重点，就是减少 STW，这也是 JVM 调优的重点\nJVM 参数有哪些 绝大数情况下，常用的有十来个\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # JVM 启动参数不换行 # 设置堆内存 -Xmx4g -Xms4g # 指定 GC 算法 -XX:+UseG1GC -XX:MaxGCPauseMillis=50 # 指定 GC 并行线程数 -XX:ParallelGCThreads=4 # 打印 GC 日志 -XX:+PrintGCDetails -XX:+PrintGCDateStamps # 指定 GC 日志文件 -Xloggc:gc.log # 指定 Meta 区的最大值 -XX:MaxMetaspaceSize=2g # 设置单个线程栈的大小 -Xss1m # 指定堆内存溢出时自动进行 Dump -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/usr/local/ ","date":"2024-09-05T08:17:38+08:00","image":"https://akaxedx.github.io/p/%E6%B7%98%E6%B1%B0%E6%96%87%E7%AB%A0%E5%90%88%E9%9B%86/zoye_hu11211305020165925006.jpeg","permalink":"https://akaxedx.github.io/p/%E6%B7%98%E6%B1%B0%E6%96%87%E7%AB%A0%E5%90%88%E9%9B%86/","title":"淘汰文章合集"},{"content":"设计模式 面向对象设计模式 我们在进行软件开发时，不仅仅需要将最基本的业务给完成，还要考虑整个项目的可维护性和可复用性，我们开发的项目不单单需要我们自己来维护，同时也需要其他的开发者一起来进行共同维护，因此我们在编写代码时，应该尽可能的规范。如果我们在编写代码时不注重这些问题，整个团队项目就像一座屎山，随着项目的不断扩大，整体结构只会越来越遭。\n甚至到最后你会发现，我们的程序居然是稳定运行在BUG之上的.\n所以，为了尽可能避免这种情况的发生，我们就来聊聊面向对象设计原则。\n单一职责原则 单一职责原则(Simple Responsibility Pinciple，SRP)是最简单的面向对象设计原则，它用于控制类的粒度大小。\n​\t一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中\n比如一个 People 类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 一个人类 public class People{ /** * 人类会编程 */ public void coding(){ System.out.println(\u0026#34;coding\u0026#34;); } public void work(){ System.out.println(\u0026#34;work\u0026#34;); } public void ride() { System.out.println(\u0026#34;ride\u0026#34;); } } 我们可以看到，这个People类可以说是十八般武艺样样精通了，啥都会，但是实际上，我们每个人最终都是在目己所擅长的领现工作，所谓闻道有先后，术业有专攻，会编程的就应该是程序员，会打螺丝的就应该是工人，会送外卖的应该是骑手，显然这个People太过臃肿（我们需要修改任意一种行为都需要修改People类，它拥有不止一个引起它变化的原因），所以根据单一职责原则，我们下需要进行更明确的划分，同种类型的操作我们一般才放在一起:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Coder{ public void coding(){ System.out.println(\u0026#34;coding\u0026#34;); } } class Worker{ public void work(){ System.out.println(\u0026#34;work\u0026#34;); } } class rider{ public void ride() { System.out.println(\u0026#34;ride\u0026#34;); } } 我们将类的粒度进行更近一步的划分，这样就很清晰了，包括我们以后在设计Mapper、Service、Controller等等，根据不同的业务进行划分，都可以采用单一职责原则，以它作为我们实现高内聚低耦合的指导方针。实际上我们的微服务也是参考了单一职责原则，每个微服务只应担负一个职责。\n开闭原则 开闭原则（Open Close Principle）也是重要的面向对象设计原则。\n​\t软件实体应当对扩展开放，对修改关闭。\n一个软件实体，比如类、模块和函数应该对扩展开放，对修改关闭。其中，对扩展开放是针对提供方来说的，对修改关闭是针对调用方来说的。\n比如我们的程序员分为Java程序员、C#程序员、C艹程序员、PHP程序员、前端程序员等，而他们要做的都是去打代码，而具体如何打代码是根据不同语言的程序员来决定的，我们可以将程序员打代码这一个行为抽象成一个统一的接口或是抽象类,这样我们就满足了开闭原则的第一个要求：对扩展开放，不同的程序员可以自由地决定他们该如何进行编程。而具体哪个程序员使用什么语言怎么编程，是自己在负责，不需要其他程序员干涉，所以满足第二个要求：对修改关闭，比如:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public abstract class Coder{ public abstract void coding(); class JavaCoder extend Coder{ @Override public void coding() { System.out.println(\u0026#34;Java\u0026#34;); } } class PHPCoder extend Coder{ @Override public void coding() { System.out.println(\u0026#34;PHP\u0026#34;); } } class CppCoder extend Coder{ @Override public void coding() { System.out.println(\u0026#34;C++\u0026#34;); } } } 通过提供一个Coder抽象类，定义出编程的行为，但感不进行实现，而是开放给其他具体类型的程序员来实现，这样就可以根据不同的业务进行灵活扩展了，具有较好的延续性。\n里氏替换原则 里氏替换原则(Liskov Substitution Principle)是对子类型的特别定义。它由芭芭拉·利斯科夫（Barara Liskov）在1987年在一次会议上名为“数据的抽象与层次”的演说中首先提出。\n​\t所有引用基类的地方必须能透明地使用其子类的对象。\n简单的说就是，子类可以扩展父类的功能，但不能改变父类原有的功能:\n1.子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。\n2.子类可以增加自己特有的方法。\n3.当子类的方法重载父类的方法时，方法的前置条件(即方法的输入/入参)要比父类方法的输入参数更宽松。\n4.当子类的方法实现父类的方法时(重写/重载或实现抽象方法)，方法的后置条件(即方法的输出/返回值)要比父类更严格或与父类一样。\n比如我们下面的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public abstract class Coder{ public void coding() { System.out.println(\u0026#34;我会打代码\u0026#34;); } class JavaCoder extends Coder{ /** * 除了打代码还会打游戏 */ public void game() { System.out.println(\u0026#34;我还会打游戏\u0026#34;); } } } 可以看到JavaCoder虽然继承自Coder， 但是并没有对父类方法进行重写，并且还在父类的基础上进行额外扩展，符合里氏替换原则。\n但是我们再来看下面的这个例子:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public abstract class Coder{ public void coding() { System.out.println(\u0026#34;我会打代码\u0026#34;); } class JavaCoder extends Coder{ /** * 除了打代码还会打游戏 */ public void game() { System.out.println(\u0026#34;我还会打游戏\u0026#34;); } /** * 这里对父类的行为进行了重写，现在它不具备父类原本的能力了 */ public void coding() { System.out.pringln(\u0026#34;不想打代码了\u0026#34;); } } } 可以看到，现在我们对父类的方法进行了重写，显然，父类的行为已经被我们给覆盖了，这个子类已经不具备父类的原本的行为，很显然违背了里氏替换原则。\n要是程序员连敲代码都不会了，还能叫做程序员吗?\n所以，对天这种情况，我们不需要再继承自Coder了，我们可以提升一下，将此行为定义到People中:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public abstract class People { public abstract void coding(); class Coder extends People{ @Override public void coding() { System.out.println(\u0026#34;我会打代码\u0026#34;); } } class JavaCoder extends People { public void game() { System.out.println(\u0026#34;我还会打游戏\u0026#34;); } public void coding() { System.out.pringln(\u0026#34;不想打代码了\u0026#34;); } } } 里氏替换原则也是实现开闭原则的重要方式之一\n依赖倒转原则 依赖倒转原则(Dependence lnversion Principle)也是我们一直在使用的，最明显的就是我们的Spring框架了。\n​\t高层模块不应依赖于底层模块，它们都应该依赖抽象。抽象不应依赖于细节，细节应该依赖于抽象。\n还记得我们在我们之前的学习中为什么要一直使用接口来进行功能定义，然后再去实现吗？我们回顾一下在使用Soring框架之前的情况:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class Main { public static void main(String[] args) { UserController controller = new UserController(); // 具体使用代码 } static class UserMapper { // CRUD } static class UserService { UserMapper mapper = new UserMapper(); // 业务 } static class UserController { UserService service = new UserService(); // 业务 } } 但是突然有一天，公司业务需求变化，现在用户相关的业务操作需要使用新的实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class Main { public static void main(String[] args) { UserController controller = new UserController(); // 具体使用代码 } static class UserMapper { // CRUD } static class UserServiceNew { // 由于 UserServiceNew 发生变化，会直接影响到其他高层模块 UserMapper mapper = new UserMapper(); // 业务 } static class UserController { UserService service = new UserService();// 原来的不能用了 UserServiceNew serviceNew = new UserServiceNew(); // 只能修改成新的 } } 我们发现，我们的各个模块之间实际上是具有强关联的，一个模块是直接指定依赖于另一个模块，虽然这样结构清晰，但是底层模块的变动，会直接影响到其他依赖于它的高层模块，如果我们的项目变得很庞大，那么这样的修改将是一场灾难。\n而有了Spring框架之后，我们的开发模式就发生了变化:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public class Main { public static void main(String[] args) { UserController controller = new UserController(); } interface UserMapper { // 接口中只做 CRUD 的定义 } static class UserMapperImpl implements UserMapper { // 实现类完成实现 } interface UserService { // 业务代码定义 } static class UserServiceImpl implements UserService { @Resource UserMapper mapper; } static class UserController { @Resource UserService service; } } 接口隔离原则 接口隔离原则（Interface Segregation Principle,lSP）实际上是对接口的细化。\n​\t客户端悉应依赖那些它不需要的接口。\n我们在定义接口的时候，一定要注意控制接口的粒度，比如下面的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 interface Device { String getCpu(); String getType(); String getMemory(); } // 电脑是一种电子设备，那么我们就实现此接口 class Computer implements Device { @Override public String getCpu() { return \u0026#34;i9-12900k\u0026#34;; } @Override public String getType() { return \u0026#34;电脑\u0026#34;; } @Override public String getMemory() { return \u0026#34;32G DDR5\u0026#34;; } } // 电风扇也算是一种电子设备 class Fan implements Device { @Override public String getCpu() { return null; } @Override public String getType() { return \u0026#34;风扇\u0026#34;; } @Override public String getMemory() { return null; } } 虽然我们定义了一个Device接口，但是由于此接口的粒度不够细，虽然比较契合电脑这种设备，但是不适合风扇这种设备，因为风扇压根就不需要CPU和内存，所以风扇完全不需要这些方法。这时我们就必须要对其进行更细粒度的划分：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 interface SmartDevice { String getCpu(); String getType(); String getMemory(); } interface NormalDevice { String getType; } class Computer implements SmartDevice { @Override public String getCpu() { return \u0026#34;i9-12900k\u0026#34;; } @Override public String getType() { return \u0026#34;电脑\u0026#34;; } @Override public String getMemory() { return \u0026#34;32G DDR5\u0026#34;; } } class Fan implements NormalDevice { @Override public String getType() { return \u0026#34;风扇\u0026#34;; } } 这样，我们就将接口进行了细粒度的划分，不同类型的电子设备就可以根据划分去实现不同的接口了。当然，也不能划分得太小，还是要根据实际情况来进行决定\n合成复用原则 合成复用原则(Composite Reuse Principle)的核心就是委派。\n​\t优先使用对象组合，而不是通过继承来达到复用的目的\n在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分，新的对象通过向这些对象的委派达到复用已有功能的目的。实际上我们在考虑将某个类通过继承关系在子类得到父类已经实现的方法之外（比如A类实现了连接数据库的功能，恰巧B类中也需要,我们就可以通过继承来获得A已经写好的连接数据库的功能、这样就能直接复用A中已经写好的逻辑）我们应该应该优先地去考虑使用合成的方式来实现复用。\n比如下面这个例子:\n1 2 3 4 5 6 7 8 9 10 11 12 class A { public void connectDatabase() { System.out.println(\u0026#34;数据库连接\u0026#34;); } } class B extends A { // 通过继承复用方法 public void test() { System.out.println(\u0026#34;我也连接数据库\u0026#34;); connectDatabase();// 调用父类方法 } } 虽然这样看起来没啥毛病，但是还是存在我们之前说的那个问题，耦合度太高了。\n可以看到通过继承的方式实现复用，我们是将类B直接指定继承自类A的，那么如果有一天，由于业务的更改，我们的数据库连接操作，不再由A来负责，而是由新来的C去负责，那么这个时候，我们就不得不将需要复用A中方法的子类全部进行修改，很显然这样是费时费力的。\n并且还有一个问题就是，通过继承子类会得到一些父类中的实现细节，比如某些字段或是方法，这样直接暴露给子类，并不安全。\n所以，当我们需要实现复用时，可以优先考虑以下操作:\n1 2 3 4 5 6 7 8 9 10 11 12 class A { public void connectDatabase() { System.out.println(\u0026#34;数据库连接\u0026#34;); } } class B { public void test(A a) { System.out.println(\u0026#34;我也连接数据库\u0026#34;); a.connectDatabase(); } } 或是：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class A { public void connectDatabase() { System.out.println(\u0026#34;数据库连接\u0026#34;); } } class B { A a; public B(A a) { this.a = a; } public void test() { System.out.println(\u0026#34;我也连接数据库\u0026#34;); a.connectDatabase(); } } 通过对象之间的组合，我们就大大降低了类之间的耦合度，并且 A 的实现细节我们也不会直接得到了\n迪米特法则 迪米特法则(Law of Demeter)又称最少知识原则，是对程序内部数据交互的限制。\n​\t每一个软件单位对其驰单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。\n简单来说就是，一个类/模块对其他的类/模块有越少的交互越好。当一个类发生改动，那么，与其相关的类(比如用到此类啥方法的类)需要尽可能少的受影响(比如修改了方法名、字段名等，可能其他用到这些方法或是字段的类也需要跟着修改)这样我们在维护项目的时候会更加轻松一些。\n其实说白了，还是降低耦合度，我们还是来看一个例子:\n1 2 3 4 5 6 7 8 9 10 11 12 13 public class Main { public static void main(String[] args) throws IOExpetion { Socket socket = new Socket(\u0026#34;localhost\u0026#34;, 8080); Test test = new Test(); test.test(socket); } static class Test { public void test(Socket socket) { System.out.println(\u0026#34;IP 地址：\u0026#34; + socket.getLocalAddress()); } } } 可以看到，虽然上面这种写法没有问题，我们提供直接提供一个 Socket 对象，然后再由 test 方法来取出IP地址，但是这样显然违背了迪米特法则，实际上这里的 test 方法只需要一个IP地址即可，我们完全可以直接传入一个字符串，而不是整个 Socket 对象，我们需要保证与其他类的交互尽可能的少。\n就像我们在餐厅吃完了饭，应该是我们自己扫码付款，而不是直接把手机交给老板来帮你操作付款。\n要是某一天，Socket 类中的这些方法发生修改了，那我们就得连带着去修改这些类，很麻烦。\n所以，我们来改进改进：\n1 2 3 4 5 6 7 8 9 10 11 12 13 public class Main { public static void main(String[] args) throws IOExpetion { Socket socket = new Socket(\u0026#34;localhost\u0026#34;, 8080); Test test = new Test(); test.test(socket.getLocalAddress().getHostAddress()); } static class Test { public void test(String str) { System.out.println(\u0026#34;IP 地址：\u0026#34; + str); } } } 这样，类与类之间的耦合度再次降低\n设计模式（创建型） 软件设计模式(Design patern)，又称设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性、程序的重用性。\n肯特·贝克和沃德·坎宁安在1987年利用克里斯托佛·亚历山大在建筑设计领域里的思想开发了设计模式并把此思想应用在Smalltalk中的图形用户接口的生成中。一年后Erich Gamma在他的苏黎世大学博士毕业论文中开始尝试把这种思想改写为适用于软件开发。与此同时James Coplien 在1989年至1991 年也在利用相同的思想致力于C++的开发，而后于1991年发表了他的著作Advanced C++ldioms。就在这一年Erich Gamma得到了博士学位，然后去了美国，在那与Richard Helm,RalphJohnson ,John Vissides合作出版了Design Patterns - Elements of Reusable Object-0riented Software 一书，在此书中共收录了23个设计模式。这四位作者在软件开发领域里也以他们的匿名著称Gang ofFour(四人帮，简称G0),并且是他们在此书中的协作导致了软件设计模式的突破。\n我们先来看看有关对象创建的几种设计模式。\n工厂方法模式 首当其冲的是最简单的一种设计模式\u0026ndash;工厂方法模式，我们知道，如果需要创建一个对象，那么最简单的方式就是直接new一个即可。而工厂方法模式代替了传统的直接new的形式，那么为什么要替代传统的new形式呢?\n可以想象一下，如果所有的对象我们都通过new的方式去创建，那么当我们的程序中大量使用此对象时，突然有一天这个对象的构造方法或是类名发生了修改，那我们岂不是得挨个去进行修改？根据迪米特法则，我们应该尽可能地少与其他类进行交互，所以我们可以将那些需要频繁出现的对象创建，封装到一个工厂类中，当我们需要对象时，直接调用工厂类中的工厂方法来为我们生成对象，这样，就算类出现了变动，我们也只需要修改工厂中的代码即可，而不是大面积地进行修改。\n同时，可能某些对象的创建并不只是一个new就可以搞定，可能还需要更多的步骤来准备构造方法需要的参数，所以我们来看看如何使用 简单工厂模式 来创建对象，既然是工厂，那么我们就来创建点工厂需要生产的东西:\n1 2 3 4 5 6 7 8 9 10 11 12 public abstract class Fruit {// 水果抽象类 private final String name; public Fruit(String name) { this.name = name; } @Override public String toString() { return name + \u0026#34;@\u0026#34; + hashCode(); } } 1 2 3 4 5 public class Apple extends Fruit { public Apple() { super(\u0026#34;苹果\u0026#34;); } } 1 2 3 4 5 public class Orange extends Fruit { public Orange() { super(\u0026#34;橘子\u0026#34;); } } 正常情况下，我们直接 new 就能得到对象了\n1 2 3 4 5 6 public class Main { public static void main (String[] args) { Apple apple = new Apple(); System.out.println(apple); } } 现在我们将对象的创建封装到工厂中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class FruitFactory { /** 这里就直接来一个静态方法根据指定类型进行创建 * @param type 水果类型 * @return 对应的水果对象 */ public static Fruit getFruit(String type) { switch(type) { case \u0026#34;苹果\u0026#34; : return new Apple(); case \u0026#34;橘子\u0026#34; : return new Orange(); default: return null; } } } 不过这样还是有一些问题，我们前面提到了开闭原则，一个软件实体，比如类、模块和函数应该对扩展开放，对修改关闭，但是如果我们现在需要新增一种水果，比如桃子，那么这时我们就得去修改工厂提供的工厂方法了，但是这样是不太符合开闭原则的，因为工厂实际上是针对于调用方提供的，所以我们应该尽可能对修改关闭。\n所以，我们就利用对扩展开放，对修改关闭的性质，将 简单工厂模式 改进为 工厂方法模式，那现在既然不让改，那么我们就看看如何去使用扩展的形式:\n1 2 3 public abstract class FruitFactory\u0026lt;T extends Fruit\u0026gt; { public abstract T getFruit(); } 1 2 3 4 5 6 public class AppleFactory extends FruitFactory\u0026lt;Apple\u0026gt; { @Override public Apple getFruit() { return new Apple(); } } 这样，我们就可以使用不同类型的工厂来生产不同类型的水果了，并且如果新增了水果类型，直接创建一个新的工厂类就行，不需要修改之前已经编写好的内容，\n1 2 3 4 5 6 7 8 9 public class Main { public static void main (String[] args) { test(new AppleFactory()::getFruit); } private static void test(Supplier\u0026lt;Fruit\u0026gt; supplier) { System.out.println(supplier.get() + \u0026#34;被吃掉了，真好吃\u0026#34;); } } 这样，我们就简单实现了工厂方法模式，通过工厂来屏蔽对象的创建细节，使用者只需要关系如何去创建对象即可。\n抽象工厂模式 前面我们介绍了工厂方法模式，通过定义顶层抽象工厂类，通过继承的方式，针对于每一个产品都提供一个工厂类用于创建。\n不过这种模式只适用于简单对象，当我们需要生产许多个产品族的时候，这种模式就有点乏力了，比如:\n实际上这些产品都是成族出现的，比如小米的产品线上有小米12，小米平板等，华为的产品线上也有华为手机、华为平板，但是如果按照我们之前工厂方法模式来进行设计，那就需要单独设计9个工厂来生产上面这些产品，显然这样就比较浪费时间的。\n但是现在有什么方法能够更好地处理这种情况呢?我们就可以使用抽象工厂模式，我们可以将多个产品，都放在一个工厂中进行生成，按不同的产品族进行划分，比如小米，那么我就可以安排一个小米工厂，而这个工厂里面就可以生产整条产品线上的内容，包括小米手机、小米平板、小米路由等。\n所以，我们只需要建立一个抽象工厂即可:\n1 2 public class Router { } 1 2 public class Table { } 1 2 public class Phonr{ } 1 2 3 4 5 public abstract class AbstractFactory { public abstract Phone getPhone(); public abstract Table getTable(); public abstract Router getRouter(); } 一个工厂可以生产同一个产品族的所有产品，这样按族进行分类，显然比之前的工厂方法模式更好。\n不过，缺点还是有的，如果产品族新增了产品，那么我就不得不去为每一个产品族的工厂都去添加新产品的生产方法，违背了开闭原则。\n建造者模式 建造者模式也是非常常见的一种设计模式，我们经常看到有很多的框架都为我们提供了形如 xxXBuilder 的类型，我们一般也是使用这些类来创建我们需要的对象。\n比如，我们在JavaSE中就学习过的 StringBuiler 类:\n1 2 3 4 5 6 7 public static void main (String[] args) { StringBuilder builder = new StringBuilder();// 创建一个 StringBuilder 来逐步构建一个字符串 builder.append(666); builder.append(\u0026#34;老铁\u0026#34;); builder.insert(2,\u0026#39;?\u0026#39;); System.out.println(builder.toString); } 实际上我们是通过建造者来不断配置参数或是内容，当我们配置完所有内容后，最后再进行对象的构建\n相比直接去 new 一个新的对象，建造者模式的重心更加关注在如何完成每一步的配置，同时如果一个类的构造方法参数过多，我们通过建造者模式来创建这个对象，会更加优雅。\n比如我们现在有一个学生类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class Student { int id; int age; int grade; String name; String college; String profession; List\u0026lt;String\u0026gt; awards; public Student(int id, int age, int grade, String name, String college, String profession, List\u0026lt;String\u0026gt; awards) { this.id = id; this.grade = grade; this.name = name; this.college = college; this.profession = profession; this.awards = awards; } } 可以看到这个学生类的属性是非常多的，所以构造方法不是一般的长，如果我们现在直接通过 new 的方式去创建:\n1 2 3 public static void main (String[] args) { Student student = new Student(1,18,3,\u0026#34;小明\u0026#34;,\u0026#34;计算机学院\u0026#34;,\u0026#34;计算机科学与技术\u0026#34;,Arrays.asList(\u0026#34;ICPC-ACM 区域赛 金牌\u0026#34;,\u0026#34;LPL 2022 春季赛冠军\u0026#34;)); } 可以看到，我们光是填参数就麻烦，我们还得一个一个对应着去填，一不小心可能就把参数填到错误的位置了\n所以，我们现在可以使用建造者模式来进行对象的创建：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 public class Student { ... private Student(int id, int age, int grade, String name, String college, String profession, List\u0026lt;String\u0026gt; awards) { this.id = id; this.grade = grade; this.name = name; this.college = college; this.profession = profession; this.awards = awards; } public static StudentBuilder builder() { return new StudentBuilder(); } public static class StudentBuilder{ int id; int age; int grade; String name; String college; String profession; List\u0026lt;String\u0026gt; awards; public StudentBuilder id(int id) { this.id = id; return this;// 为了支持链式调用，直接返回建造者本身，下同 } public StudentBuilder age(int age) { this.age = age; return this; } ... public StudentBuilder awards(String... awards) { this.awards = Arrays.asList(awards); return this; } public Student build() { return new Student(id,age,grade,name,college,profession,awards); } } } 现在，我们可以使用建造者来为我们生成对象了：\n1 2 3 4 5 6 7 8 9 public static void main(String[] args) { Student student = Student.builder() .id(1) .age(18) .grade(3) .name(\u0026#34;小明\u0026#34;) .awards(\u0026#34;ICPC-ACM 区域赛 金牌\u0026#34;,\u0026#34;LPL 2022 春季赛冠军\u0026#34;) .build(); } 这样，我们就可以让这些参数对号入座了，并且比执勤的方式优雅很多\n单例模式 单例模式其实在之前的课程中已经演示过很多次了，这也是使用频率非常高的一种模式。\n那么，什么是单例模式呢?顾名思义，单例那么肯定就是只有一个实例对象，在我们的整个程序中，同一个类始终只会有一个对象来进行操作。比如数据库连接类，实际上我们只需要创建一个对象或是直接使用静态方法就可以了，没必要去创建多个对象。\n这里还是还原一下我们之前使用的简单单例模式：\n1 2 3 4 5 6 7 8 9 10 // 饿汉式单例 public class Singleton { private final static Singleton INSTANCE = new Singleton(); private Singleton() {} public static Singleton getInstance() { return INSTANCE; } } 这样，当我们需要获取此对象时，只能通过 getInstance() 来获取唯一对象\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 懒汉式单例 public static Singleton { private static Singleton INSTANCE; // 一开始不创建对象 private Singleton() {} public static Singleton getInstance() { if (INSTANCE == null) {// 为空则创建 INSTANCE = new Singletonn(); } return INSTANCE; } } 可以看到，懒汉式就真的是条懒狗，你不去用它，它是不会给你提前准备单例对象的(延迟加载，懒加载)，当我1需要状取对家时，才会进行检查并创建。虽然饿汉式和懒汉式写法不同，但是最后都是成功实现了单例模式。\n不过，这里需要特别提醒一下，由于懒汉式是在方法中进行的初始化，在多线程环境下，可能会出现问题。如果这个时候有多个线程同时调用了 getInstanceO 方法，那么会出现什么问题呢？\n可以看到，在多线程环境下，如果三条线程同时调用 getInstance()方法，会同时进行 INSTANCE == nul1 的判断，那么此时由于确实还没有进行任何实例化，所以导致三条线程全部判断为 true(而饿汉式由于在类加载时就创建完成，不会存在这样的问题)此时问题就来了，我们既然要使用单例模式，那么肯定是只希望对象只被初始化一次的，但是现在由于多线程的机制，导致对象被多次创建。\n所以，为了避免线程安全问题，针对于懒汉式单例，我们还得进行一些改进\n1 2 3 4 5 6 public static synchronized Singleton getInstance() { if (INSTANCE == null) {// 为空则创建 INSTANCE = new Singletonn(); } return INSTANCE; } 既然多个线程要调用，那么我们就直接加一把锁，在方法上添加 synchronized 关键字即可，这样同一时间只能有一个线程进入了。虽然这样简单粗暴，但是在高并发的情况下，效率肯定是比较低的，我们来看看如何进行优化：\n1 2 3 4 5 6 7 8 public static Singleton getInstance() { if (INSTANCE == null) {// 为空则创建 synchronized(Singleton.class) { INSTANCE = new Singleton(); } } return INSTANCE; } 不过这样还不完美，因为这样还是有可能多个线程同时判断为 nul1 而进入等锁的状态，所以，我们还得加一层内层判断：\n1 2 3 4 5 6 7 8 public static Singleton getInstance() { if (INSTANCE == null) {// 为空则创建 synchronized(Singleton.class) { if (INSTANCE == null) INSTANCE = new Singleton();// 双重检查锁定 } } return INSTANCE; } 不过我们还少考虑了一样内容，其实IDEA此时应该是给了黄标了：\n可以看到，这种情况下，IDEA会要求我们添加一个 volatiLe 给 INSTANCE，各位还记得这个关键字有什么作用吗?没错，我们还需要保证 INSTANCE 在线程之间的可见性，这样当其他线程进入之后才会拿 INSTANCE 由其他线程更新的最新值去判断，这样，就差不多完美了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public static Singleton { private static volatile Singleton INSTANCE; private Singleton() {} public static Singleton getInstance() { if (INSTANCE == null) { synchronized(SIngleton.class) { if(INSTANCE == null) INSTANCE = new Singleton(); } } return INSTANCE; } } 那么，有没有一直更好的，不用加锁的方式也能实现延迟加载的写法呢？我们可以使用静态内部类\n1 2 3 4 5 6 7 8 9 10 11 public class Singleton { private Singleton() {} private static class Holder {// 由静态内部类持有单例对象，但是根据类加载特性，我们仅使用 Singleton 类时，不会对静态内部类进行初始化 private final static Singleton INSTANCE = new Singleton(); } public static Singleton getInstance() {// 只有真正使用内部类时，才会进行类初始化 return Holder.INSTANCE;\t// 直接获取内部类中的 } } 这种方式显然是最完美的懒汉式解决方案，没有进行任何的加锁操作，也能保证线程安全，不过要实现这种写法，和语言本身也有一定的关联，并不是所有语言都支持这种写法\n原型模式 原型模式实际上与对象的拷贝息息相关，原型模式使用原型实例指定待创建对象的类型，并且通过复制这个原型来创建新的对象。也就是说，原型对象作为模板，通过克隆操作，来产生更多的对象，就像细胞的复制一样。\n开始之前，我们先介绍一下对象的深拷贝和浅拷贝，首先我们来看浅拷贝:\n**浅拷贝：**对于类中基本数据数据类型，会直接复制值给拷贝对象；用于引用类型，只会复制对象的地址，而实际上指向的还是原来的那个对象，拷贝个寂寞 1 2 3 4 5 6 7 8 9 public static void main(String[] args) { int a = 10; int b = a;// 基本类型浅拷贝 System.out.println(a == b); Object o = new Object(); Object k = o;// 引用类型浅拷贝，拷贝的仅仅是对上面对象的引用 System.out.println(o == k); } **深拷贝：**无论是基本类型还是引用类型，深拷贝会将引用类型的所有内容，全部拷贝为一个新的对象，包括对象内部的所有成员变量，也会进行拷贝 在 Java 中，我们就可以使用 Cloneable 接口提供的拷贝机制，来实现原型模式\n1 2 3 4 5 6 public class Student implements Cloneable { @Override public Object clone() throws CloneNotSupportedException {// 提升 clone 方法访问权限 return super.clone(); } } 接着我们来看看克隆的对象是不是原来的对象\n1 2 3 4 5 6 public static void main (String[] args) throws CloneNotSupportedException { Student student0 = new Student(); Student student1 = (Student) student0.clone(); System.out.println(student0); System.out.println(student1); } 可以看到，通过 clone() 方法克隆的对象并不是原来的对象，我们来看看如果对象内部有属性会不会一起进行克隆：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Student implements Cloneable { String name; public Student(String name) { this.name = name; } public String getName() { return name; } @Override public Object clone() throws CloneNotSupportedException { return super.clone(); } } 1 2 3 4 5 public static void main(String[] args) throws CloneNotSupportedException { Student student0 = new Student(\u0026#34;小明\u0026#34;); Student student1 = (Student) student0.clone(); System.out.println(student0.getName() == student1.getName()); } 可以看到，虽然 Student 对象成功拷贝，但是其内层对象并没有进行拷贝，依然只是对象引用的复制，所以 Java 为我们提供的 clone 方法只会进行浅拷贝，那么如何才能实现深拷贝呢？\n1 2 3 4 5 6 @Override public Object clone() throws CloneNotSupportedException { Studet student = (Student) super.clone(); student.name = new String(name); return student; } 这样，我们就实现了深拷贝\n设计模式（结构型） 结构型设计模式关注如何将现有的类或对象组织在一起形成更加强大的结构。并且根据我们前面学习的合成复用原则，我们该如何尽可能地使用关联关系来代替继承关系是我们本版块需要重点学习的内容。\n类/对象适配器模式 在生活中，我们经常遇到这样的一个问题:笔记本太轻薄了，以至于没有 RJ45 网口和 USB A 口(比如Macbook为了轻薄甚至全是 typec 形式的雷电口)但是现在我们因为工作需要，又得使用这些接口来连接线缆，这时我们想到的第一个解决方案，就是去买一个转接口(扩展坞)，扩展坞可以将 type-c 口转换为其他类型的接口供我们使用，实际上这就是一种适配模式。\n由于我们的电脑没有这些接口，但是提供了 type-c 类型的接口，虽然接口类型不一样，但是同样可以做其他接口能做的事情，比如 USB 文件传输、有线网络连接等，所以，这个时候，我们只需要添加一个中间人来帮我们转换一下接口形态即可。包括我们常用的充电头，为什么叫电源适配器呢?我们知道传统的供电是 220V 交流电，但是我们的手机可能只需要 5V 的电压进行充电，虽然现在有电，但是不能直接充，我们也不可能让电力公司专门为我们提供一个 5V 的直流电使用。这时电源适配器就开始发挥作用了，比如苹果的祖传 5V1A 充电头，实际上就是将 220V 交流电转换为 5V 的直流电进行传输，这样就相当于在 220V 交流电和我们的手机之前，做了一个适配器的角色。\n在 Java 程序中，也经常会有这样的问题：\n1 2 3 4 5 6 public class TestSupplier {// 手机供应商 public String doSupply() { return \u0026#34;iPhone 14 Pro\u0026#34;; } } 1 2 3 4 5 6 7 8 9 10 public class Main { public static void main(String[] args) { TestSupplier supplier new TestSupplier(); test(?);// 我们没有 Target 类型的手机供应商，我们只有 TestSupplier 类型 } public static void test (Target target) { System.out.println(\u0026#34;成功得到：\u0026#34; + target.supply());// test 方法需要 Target 类型的手机供应商 } } 1 2 3 public interface Target { String supply(); } 这个时候，我们就可以使用适配器模式了，适配器模式分为类适配器和对象适配器，我们首先来看看如何使用类适配器解决这种问题，我们直接创建一个适配器类：\n1 2 3 4 5 6 public class TestAdapter extends TestSupplier implements Target { @Override public String String supply() { return super.doSupply(); } } 这样我们就得到了一个 Target 类型的实现类，并且同时采用的是 TestSupplier 提供的实现。\n1 2 3 4 5 6 7 8 public static void main(String[] args) { TestAdapter adapter new TestAdapter(); test(adapter); } public static void test (Target target) { System.out.println(\u0026#34;成功得到：\u0026#34; + target.supply()); } 不过，这种实现方式需要占用一个继承坑位，如果此时 Target 不是接口而是抽像类的话，由于 java 不支持多继承，那么就无法实现了。 同时根据合成复用原则，我们应该更多的通过合成的方式去实现功能，所以我们来看看第二种，也是用的比较多的一种模式，对象适配器：\n1 2 3 4 5 6 7 8 9 10 11 12 public TestAdapter implements Target { TestSupplier supplier; public TestAdapter(TestSupplier supplier) { this.supplier = supplier; } @Override public String supply() { return supplier.doSupply(); } } 现在，我们就将对象以组合的形式存放在 TestAdapter 中，依然是通过存放的对象调用具体实现。\n桥接模式 相信各位都去奶茶店买过奶茶，在购买奶茶的时候，店员首先会问我们，您需要什么类型的奶茶，比如我们此时点了一杯啵啵芋圆奶茶，接着店员会直接问我们需要大杯、中杯还是小杯，最后还会询问我们需要加什么配料，比如椰果、珍珠等，最后才会给我们制作奶茶。\n那么现在让你来设计一下这种模式的 Java 类，该怎么做呢？首先我们要明确，一杯奶茶除了类型之外，还分大中小杯，甚至可能还分加什么配料，这个时候，如果我们按照接口实现的写法:\n1 2 3 public interface Tea { String getType(); } 1 2 3 public interface Size { String getSize(); } 比如闲杂我们创建一个新的类型\n1 2 3 4 5 6 7 8 9 10 11 public class LargeKissTea implements Tea, Size { @Override public String getSize() { return \u0026#34;大杯\u0026#34;; } @Override public String getType() { return \u0026#34;芋圆啵啵奶茶\u0026#34;； } } 虽然这样设计起来还挺合理的，但是如果现在我们的奶茶品种多起来了，并且每种奶茶都有大中小杯，现在一共有两个维度需要考虑，那么我们岂不是得一个一个去创建这些类？甚至如果还要考虑配料，那么光创建类就得创建不知道多少个了。显然这种设计不太好，我们得换个方式。\n这时，就可以使用我们的桥接模式了，现在我们面临的问题是，维度太多，不可能各种类型各种尺寸的奶茶都去创建一个类，那么我们就还是单独对这些接口进行简单的扩展，单独对不同的维度进行控制，但是如何实现呢？我们不妨将奶茶的类型作为最基本的抽象类，然后对尺寸、配料等属性进行桥接：\n1 2 3 4 5 6 7 8 9 10 public abstract class AbstractTea { protected Size size;// 尺寸作为桥接属性存放在类中 protected AbstractTea(Size size) { // 在构造时需要知道尺寸属性 this.size = size; } public abstract String getType(); //具体类型依然由子类决定 } 不过这个抽象类提供的方法还不全面，仅仅只有Tea的getType方法，我们还需要添加其他维度的方法，所以继续编写一个子类：\n1 2 3 4 5 6 7 8 9 public abstract class RefinedAbstractTea extends AbstractTea { protected RefinedAbstractTea(Size size) { super(size); } public String getSize { return size.getSize(); } } 现在我们只需要单独为 Size 创建子类即可\n1 2 3 4 5 6 public class Large implements Size { @Override public String getSize() { return \u0026#34;大杯\u0026#34;; } } 现在我们如果需要一个大杯的芋圆啵啵奶茶，只需要\n1 2 3 4 5 6 7 8 9 10 public class KissTea extends RefinedAbstractTea { protected KissTea(Size size) { super(size); } @Override public String getType() { return \u0026#34;芋圆啵啵奶茶\u0026#34;; } } 现在我们就将两个维度拆开了，可以分别进行配置\n1 2 3 4 5 public static void main(String[] args) { KissTea tea = new KissTea(new Large()); System.out.println(tea.getType()); System.out.println(tea.getSize()); } 通过桥接模式，使得抽象和实现可以沿着各自的维度来进行变化，不再是固定的绑定关系。\n组合模式 组合模式实际上就是将多个组件进行组合，让用户可以对它们进行一致性处理。比如我们的文件夹，一个文件夹中可以有很多个子文件夹或是文件\n它就像是一个树形结构一样，有分支有叶子，而组合模式则是可以对整个树形结构上的所有节点进行递归处理，比如我们现在希望将所有文件夹中的文件的名称前面都添加一个前缀，那么就可以使用组合模式。\n组合模式的示例如下，这里我们就用文件和文件夹的例子来讲解：\n1 2 3 4 5 6 public abstract class Component { public abstract void addComponent(Component component);// 添加组件 public abstract void removeComponent(Component component);// 删除子组件 public abstract Component getChild(int index);// 获取子组件 public abstract void test();// 执行对应的业务方法，比如修改文件名称等 } 接着我们来编写两种实现类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public class Directory extends Component{ //目录可以包含多个文件或目录 List\u0026lt;Component\u0026gt; child = new ArrayList\u0026lt;\u0026gt;(); // 这里用 List 来存放目录中的子组件 @Override public void addComponent(Component component) { child.add(component); } @Override public void removeComponent(Component component) { child.remove(component) } @Override public Component getChild(int index) { return child.get(index); } @Override public void tets() { child.foreach(Component::test);// 调用所有子组件的 test 方法 } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class File extends Component {// 文件相当于是树叶，无法再继续添加子组件了 @Override public void addComponent(Component component) { throw new UnsupportedOperationException();// 不支持这些操作了 } @Override public void removeComponent(Component component) { throw new UnsupportedOperationException(); } @Override public Component getChild(int index) { throw new UnsupportedOperationException(); } @Override public void tets() { System.out.println(\u0026#34;文件名修改成功：\u0026#34; + this); // 具体的名称修改操作 } } 最后，测试\n1 2 3 4 5 6 7 8 9 public static void main(String[] args) { Directory outer = new Directory(); Directory inner = new Directory(); outer.addComponent(inner); outer.addComponent(new File()); inner.addComponent(new File()); inner.addComponent(new File()); outer.test(); } 装饰模式 装饰模式就像其名字一样，为了对现有的类进行装饰。比如一张相片就一张纸，如果直接贴在墙上，总感觉少了点什么，但是我们给其添加一个好看的相框，就会变得非常对味。装饰模式的核心就在于不改变一个对象本身功能的基础上，给对象添加额外的行为，并且它是通过组合的形式完成的，而不是传统的继承关系。\n比如我们现在有一个普通的功能类:\n1 2 3 public abstract class Base { public abstract void test(); } 1 2 3 4 5 6 public class BaseImpl extends Base { @Override public void test() { System.out.println(\u0026#34;我是业务方法\u0026#34;); } } 不过现在的实现类太简单了，我们加一点装饰上去\n1 2 3 4 5 6 7 8 9 10 11 12 public class Decorator extends Base { protected Base base; public Decorator(Base base) { this.base = base; } @Override public void test() { base.test(); } } 1 2 3 4 5 6 7 8 9 10 11 12 public class DecoratorImpl extends Decorator { public DecoratorImpl(Base base) { super(base); } @Override public void test() { System.out.println(\u0026#34;装饰方法：我是操作前逻辑\u0026#34;); super.test(); System.out.println(\u0026#34;装饰方法：我是操作后逻辑\u0026#34;); } } 这样我们就通过装饰模式对类的功能进行了扩展\n1 2 3 4 5 6 7 8 public static void main(String[] args) { Base base = new BaseImpl(); Decorator decorator = new DecoratorImpl(base); Decorator outer new DecoratorImpl(decorator); decorator.test(); outer.test(); } 代理模式 代理模式和装饰模式很像，初学者很容易搞混，所以这里我们得紧接着来讲解一下。首先请记住，当无法直接访问某个对象或访问某个对象存在困难时，我们就可以通过一个代理对象来间接访问。\n实际上代理在我们生活中处处都存在，比如手机厂商要去销售手机，但是手机厂商本身没有什么渠道可以大规模地进行售卖，很难与这些消费者进行对接，这时就得交给代理商去进行出售，比如 Apple 在中国的直营店很少，但是在中国的授权经销商却很多，手机厂商通过交给旗下代理商的形式来进行更大规模的出售。比如我们经常要访问 Github ，但是直接连接会发现很难连的上，这时我们加了一个代理就可以轻松访问，也是在体现代理的作用。\n同时，代理类需要保证客户端使用的透明性，也就是说操作起来需要与原本的真实对象相同，比如我们访问 Github 只需要输入网址即可访问，而添加代理之后，也是使用同样的方式去访问 Github，所以操作起来是一样的。包括 Spring 框架其实也是依靠代理模式去实现的 AOP 记录日志等。\n比如现在有一个目标类，但是我们现在需要通过代理来使用它:\n1 2 3 public abstract class Subject { public abstract void test(); } 1 2 3 4 5 6 public class SubjectImpl extends Subject { @Override public void test() { System.out.println(\u0026#34;我是测试方法\u0026#34;); } } 现在我们为其建立以恶个代理类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Proxy extends Subject {// 为了保证和 Subject 操作方式一样，保证透明性，也得继承 Subject target; public Proxy(Subject subject) { this.target = subject; } @Override public void test() { System.out.println(\u0026#34;代理前绕方法\u0026#34;); target.test(); System.out.println(\u0026#34;代理后绕方法\u0026#34;); } } 乍一看。这和装饰模式一样\n对装饰器模式来说，装饰者和被装饰者都实现同一个接口/抽象类。对代理模式来说，代理类和被代理的类都实现同一个接口/抽象类在结构上确实没有啥区别。但是他们的作用不同，装饰器模式强调的是增强自身，在被装饰之后你能够在被增强的类上使用增强后的功能，增强后你还是你，只不过被强化了而已;代理模式强调要让别人帮你去做事情，以及添加一些本身与你业务没有太多关系的事情(记录日志、设置缓存等)重点在于让别人帮你做。\n装饰模式和代理模式的不同之处在于思想。\n当然实现代理模式除了我们上面所说的这种方式之外，我们还可以使用JDK为我们提供的动态代理机制，我们不再需要手动编写继承关系创建代理类，它能够在运行时通过反射机制为我们自动生成代理类：\n1 2 3 public interface Subject { void test(); } 1 2 3 4 5 6 public class SubjectImpl implements Subject { @Override public void test() { System.out.println(\u0026#34;我是测试方法\u0026#34;); } } 接着我们需要创建一个动态代理的处理逻辑\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class TestProxy implements InvocationHandler {// 代理类，需要实现 InvocationHandler 接口 private final Object object; // 保存一下被代理的对象 public TestProxy(Object object) { this.object = object; } @Override // 此方法就是调用代理对象的对应方法时会进入，这里我们就要编写如何进行代理了 public Object invoke(Object proxy,Method method, Object[] args) throws Throwable { // method 就是调用的代理对象的哪一个方法，args 是实参数组 System.out.println(\u0026#34;代理的对象：\u0026#34; + proxy.getClass()); Object res = method.invoke(object, args); System.out.println(\u0026#34;方法调用完成，返回值为：\u0026#34;+res); return res; } } 最后我们来看看如何创建一个代理类\n1 2 3 4 5 6 7 8 9 public static void main(String[] args) { SubjectImpl subject = new SubjectImpl(); InvocationHandler handler = new TestProxy(subject); Subject proxy = (Subject) Proxy.newProxyInstance( subject.getClass().getClassLoader(), // 需要传入被代理类的类加载器 subject.getClass().getInterfaces(), // 需要传入被代理的类的接口列表 handler); // 最后传入我们实现的代理处理逻辑实现类 proxy.test(); // 比如现在我们调用代理类的 test 方法，那么就会进入到我们上面 TestProxy 中 invoke 方法，走代理逻辑 } 不过 JDK 提供的动态代理只能使用接口，如果换成我们一开始的抽象类，就没办法了，这时我们可以使用一些第三方框架来实现更多方式的动态代理，比如 Spring 都在使用的 CGLib 框架，Maven依赖如下:\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;cglib\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;cglib\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 由于 CGLib 底层使用 ASM 框架 进行字节码编辑，所以能够实现不仅仅局限于对接口的代理\n1 2 3 4 5 6 7 8 9 10 11 12 13 public class TestProxy implements MethodInterceptor { private final Object target; public TestProxy(Object target) { this.target = target; } @Override public Pbject intercept(Object o, Method method, Object[] objects,MethodProxy methodProxy) throws Throwable { System.out.println(\u0026#34;现在是由 CGLib 进行代理操作\u0026#34; + o.getClass()); return method.invoke(target,objects); } } 接着来创建代理类\n1 2 3 4 5 6 7 8 9 10 11 public static void main(String[] args) { SubjectImpl subject = new SubjectImpl(); Enhancer enhancer = new Enhancer();// 增强器，一会就需要依靠增强其来为我们生成动态代理对象 enhancer.setSuperclass(SubjectImpl.class); // 直接选择我们需要代理的类型，不需要接口或是抽象类，SuperClass 作为代理类的父类存在，这样我们就可以按照指定类型的方式去操作代理类了 enhancer.setCallback(new TestProxy(subject)); // 设定我们刚刚编写好的代理逻辑 SubjectImpl proxy = (SubjectImpl) enhancer.create(); // 直接创建代理类 proxy.test() // 调用代理类的 test 方法 } 外观模式 你是否经历过类似的情况:今年计算机学院的奖学金评定工作开始了，由于你去年一不小心拿了个 ACM 的区域赛金牌，觉得自己又行了，于是也想参与到奖学金的争夺中，首先你的辅导员会通知你去打印你的获奖材料，然后你高高兴兴拿给辅导员之后，辅导员又给了你一张表，让你打印了之后填写一下，包括你的个人信息还有一些个人介绍，完成后，你本以为可以坐等发奖了，结果辅导员又跟你说我们评定还要去某某地方盖章，盖完章还要去找谁谁谁签字，最后还要参加一下答辩….看着如此复杂的流程，你瞬间不想搞了。\n实际上我们生活中很多时候都是这样，可能在办一件事情的时候，由于部门职能的不同，你得各个部门到处跑，你肯定会抱怨一句，就不能有个人来统一一下吗，就不能在一个地方一起把事情都办了吗？这时，我们就可以用到外观模式了。\n外观模式充分体现了迪米特法则。可能我们的整个项目有很多个子系统，但是我们可以在这些子系统的上面加一个门面（Facade）当我们外部需要与各个子系统交互时，无需再去直接使用各个子系统，而是与门面进行交互，再由门面与后面的各个子系统操作，这样，我们以后需要办什么事情，就统一找门面就行了。这样的好处是，首先肯定方便了代码的编写，统一找门面就行，不需要去详细了解子系统，并且，当子系统需要修改时，也只需要修改门面中的逻辑，不需要大面积的变动、遵循迪米特法则尽可能少的交互,\n比如现在我们设计了三个子系统，分别是排队、结婚、领证，正常情况下我们是需要分别去找这三个部门去完成的，但是现在我们通过门面统一来完成：\n1 2 3 4 5 public class SubSystemA { public void test1() { System.out.println(\u0026#34;排队\u0026#34;); } } 1 2 3 4 5 public class SubSystemB { public void test2() { System.out.println(\u0026#34;结婚\u0026#34;); } } 1 2 3 4 5 public class SubSystemC { public void test3() { System.out.println(\u0026#34;领证\u0026#34;); } } 现在三个系统太复杂了，我们添加一个门面\n1 2 3 4 5 6 7 8 9 10 11 public class Facade { SubSystemA a = new SubSystemA(); SubSystemB b = new SubSystemB(); SubSystemC c = new SubSystemC(); public void marry() {// 一条龙 a.test1(); b.test2(); c.test3(); } } 现在只需要一个门面就能把事情全部办完了\n1 2 3 4 public static void main(String[] args) { Facade facade = new Facade(); facade.merry(); } 通过外观模式，我们大大降低了类与类之间的关联程度，并且简化了流程\n享元模式 最后我们来看看享元模式（Flyweight），那么这个“享元”代表什么意思呢？我们先来看看下面的问题：\n1 2 3 4 public static void main(String[] args) { String str1 = \u0026#34;abcdefg\u0026#34;; String str2 = \u0026#34;abcd\u0026#34;; } 我们发现上面的例子中，两个字符串虽然长短不同，但是却饱含了一段相同 的部分，那么现在我们如果要对内存进行优化：\n1 2 3 4 5 public static void main(String[] args) { String str1 = \u0026#34;efg\u0026#34;; String str2 = \u0026#34;abcd\u0026#34;; Systom.out.println(\u0026#34;str1 = \u0026#34;+ str2 + str1); } 而享元模式就是这个思想，我们可以将那些重复出现的内容作为共享部分取出，这样当我们拥有大量对象时，我们把其中共同的部分抽取出来，由于提取的部分是多个对象共享只有一份，那么就可以减轻内存的压力。包括我们的围棋，实际上我们只需要知道棋盘上的各个位置是黑棋还是白棋，实际上没有创建很多个棋子对象，我们只需要去复用一个黑棋和一个白棋子对象即可。\n比如现在我们有两个服务，但是他们都需要使用数据库工具类来操作，实际上这个工具类没必要创建多个，我们这时就可以使用享元模式，让数据库工具类作为享元类，通过享元工厂来提供一个共享的数据库工具类:\n1 2 3 4 5 public class DBUtil { public void selectDB() { System.out.println(\u0026#34;我是数据库操作...\u0026#34;); } } 1 2 3 4 5 6 7 public class DBUtilFactory { private static final DBUtil UTIL = new DBUtil();// 享元对象被存放在工厂中 public static DBUtil getFlyweight() { // 获取享元对象 return UTIL; } } 最后当我们需要使用享元对象时，直接找享元工厂要就行了：\n1 2 3 4 5 6 public class UserService { public void service() { DBUtil util = DBUtilFactory.getFlyweight(); util.selectDB(); } } 设计模式（行为型） 前面我们已经学习了12种设计模式，分为两类:\n创建型:关注对象创建\n结构型:关注类和对象的结构组织\n我们接着来看最后一种设计模式，也是最多的一种，行为型设计模式关注系统中对象之间的交互，研究系统在运行时对象之间的相互通信与协作，进一步明确对象的职责。\n解释器模式 这种模式的使用场景较少，很少使用的一种设计模式，这里提一下就行。\n解释器顾名思义，就是对我们的语言进行解释，根据不同的语义来做不同的事情，比如我们在 SE 中学习的双栈计算器，正是根据我们输入的算式，去进行解析，并根据不同的运算符来不断进行计算。\n比如我们输入:1 + 2 * 3\n那么计算器就会进行解析然后根据语义优先计算2 * 3 的结果然后在计算 1+6 最后得到 7\n模板方法模式 我们先来看看什么是模板方法。\n有些时候，我们的业务可能需要经历很多个步骡来完成，比如我们生病了在医院看病，首先是去门诊挂号，然后等待叫号，然后是去找医生看病，确定病因后，就根据医生的处方去前台开药，最后付钱。这一整套流程看似是规规矩矩的，但是在这其中，某些步骤并不是确定的，比如医生看病这一步，由于不同的病因，可能会进行不同的处理，最后开出来的药方也会不同，所以，整套流程中，有些操作是固定的，有些操作可能需要根据具体情况而定。\n在我们的程序中也是如此，可能某些操作是固定的，我们就可以直接在类中对应方法进行编写，但是可能某些操作需要视情况而定,由不同的子类实现来决定，这时，我们就需要让这些操作由子类来延迟实现了。现在我们就需要用到模板方法模式。\n我们先来写个例子:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public abstract class AbstractDiagnosis { public void test() { System.out.println(\u0026#34;去医院看病\u0026#34;); System.out.println(\u0026#34;1 \u0026gt;\u0026gt; 先挂号\u0026#34;); System.out.println(\u0026#34;2 \u0026gt;\u0026gt; 等待叫号\u0026#34;); // 由于现在不知道开什么处方，所以先定义行为，然后由子类实现 // 大致流程定义好就行 this.prescribe(); this.medicine(); } public abstract void prescribe();// 开处方 public abstract void medicine(); // 拿药 } 现在我们定义好了抽象方法，只是将具体流程定义出来了，具体方法需要根据实现决定\n1 2 3 4 5 6 7 8 9 10 11 public class ColdDiagnosis extends AbstractDiagnosis { @Override public void prescribe() { System.out.println(\u0026#34;3 \u0026gt;\u0026gt; 一眼丁真，鉴定为假，不是感冒，纯是摆烂\u0026#34;); } @Override public void medicine() { System.out.println(\u0026#34;3 \u0026gt;\u0026gt; 开点头孢回去吃\u0026#34;); } } 这样，我们就有了一个具体的实现类，并且由于看病的逻辑已经由父类定义好了，所以子类只需要实现需要实现的部分即可，这样我们就实现了简单的模板方法模式：\n1 2 3 4 public static void main(String[] args) { AbstractDiagnosis a = new ColdDiagnosis(); a.test(); } 责任链模式 责任链模式也非常好理解，比如我们的钉钉审批，实际上就是一条流水线一样的操作，由你发起申请，然后经过多个部门主管审批,最后才能通过，所以你的申请表相当于是在一条责任链上传递。当然除了这样的直线型责任链之外，还有环形、树形等。\n实际上我们之前也遇到过很多种责任链，比如 JavaWeb 中学习的 Fiter 过滤器，正是采用的责任链模式，通过将请求一级一级不断向下传递，来对我们所需要的请求进行过滤和处理。\n这里我们就使用责任链模式来模拟一个简单的面试过程，我们面试也是一面二面三面这样走的流程，这里我们先设计一下责任链上的各个处理器：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public abstract class Handler { protected Handler successor; // 这里我们就涉及责任链以单链表形式存在，这里存放后继结点 public Handler connect(Handler successor) { // 拼接后续结点 this.successor = successor; return successor; // 这里返回后继节点，方便后面链式调用 } public void handle() { this.doHandle(); // 由不同的子类实现具体处理过程 Optional .ofNullable(successor) .ifPresent(Handler::handle); // 责任链上如果还有后继节点，就继续向下传递 } public abstract void doHandle(); // 结合模板方法，交给子类实现 } 因为面试有很多轮，所以这里创建几个处理器的实现\n1 2 3 4 5 6 7 public class FirstHandler extends Handler{ @Override public void doHandle() { System.out.println(\u0026#34;一面\u0026#34;); System.out.println(\u0026#34;问题1\u0026#34;); } } 1 2 3 4 5 6 7 public class SecondHandler extends Handler{ @Override public void doHandle() { System.out.println(\u0026#34;二面\u0026#34;); System.out.println(\u0026#34;问题2\u0026#34;); } } 1 2 3 4 5 6 7 public class ThirdHandler extends Handler{ @Override public void doHandle() { System.out.println(\u0026#34;三面\u0026#34;); System.out.println(\u0026#34;问题3\u0026#34;); } } 这样就编写好了每一轮的面试流程，现在可以构建一个责任链了\n1 2 3 4 5 6 7 public static void main(String[] args) { Handler handler = new FirstHandler(); handler .connect(new SecondHandler()) .connect(new ThirdHandler()); handler.handle(); } 命令模式 大家有没有发现现在的家电都在趋向于智能化，通过一个中央控制器，我们就可以对家里的很多电器进行控制，比如国内做的比较好的小米智能家居系列，还有 Apple 的 HomeKit 等，我们只需要在一个终端上进行操作，就可以随便控制家里的电器。\n比如现在我们有很多的类，彩电、冰箱、空调、洗衣机、热水器等，既然现在我们要通过一个遥控器去控制他们，那么我们就需要将控制这些电器的指令都给设计好才行，并且还不能有太强的关联性。\n所有的电器肯定需要通过蓝牙或是红外线接受遥控器发送的请求，所以所有的电器都是接收者：\n1 2 3 public interface Receiver { void action();// 具体行为，这里就写一个 } 接着我们要控制这些电器，那么肯定需要一个指令才能控制\n1 2 3 4 5 6 7 8 9 10 11 public abstract class Command {// 指令抽象，不同的电器有指令 private final Receiver receiver; protected Command(Receiver receiver) { // 指定此命令对应的电器（接收者） this.receiver = receiver; } public void excute() { receiver.action();// 执行命令，实际上就是让接收者开始干活 } } 最后安排一个遥控器\n1 2 3 4 5 public class Controller { public static void call(Command command) { command.execute(); } } 比如现在我们创建一个空调，那么它就是作为我们命令的接收者：\n1 2 3 4 5 6 public class AirConditioner implements Receiver { @Override public void action() { System.out.println(\u0026#34;空调已开启，呼呼呼\u0026#34;); } } 现在我们创建一个开启空调的命令：\n1 2 3 4 5 public class OpenCommand extends Command { public OpenCommand(AirConditioner airConditioner) { super(airCondition); } } 最后我们只需要通过遥控器发送出去就\n1 2 3 4 public static void main(String[] args) { AirCondition airConditioner = new AirConditioner(); // 先创建一个空调 Controller.call(new OpenCommand(airConditioner));// 通过遥控器来发送空调开启命令 } 通过这种方式，遥控器这个角色并不需要周到具体执行什么，只需要发送命令即可，遥控器和电器的关联就不那么强了\n迭代器模式 回顾我们之前使用迭代器的场景：\n1 2 3 4 5 6 public static void main(String[] args) { List\u0026lt;String\u0026gt; list = Arrays.asList(\u0026#34;AAA\u0026#34;,\u0026#34;BBB\u0026#34;,\u0026#34;CCC\u0026#34;); for (String s : list) { System.out.println(s); } } 编译之后的代码如下：\n1 2 3 4 5 6 7 8 9 public static void main(String[] args) { List\u0026lt;String\u0026gt; list = Arrays.asList(\u0026#34;AAA\u0026#34;,\u0026#34;BBB\u0026#34;,\u0026#34;CCC\u0026#34;); Iterator var2 = list.iterator(); while(var2.hasNext()) { String s = (String)var2.next(); System.out.println(s); } } 可以看到，当我们使用迭代器对List进行遍历时，实际上就像一个指向列表头部的指针，我们通过不断向后移动指针来依次获取所指向的元素：\n这里，我们依照 JDK 提供的迭代器接口（JDK 已经为我们定义好了一个迭代器的具体相关操作），也来设计一个迭代器\n1 2 3 4 5 6 7 8 9 10 11 public class ArrayCollection\u0026lt;T\u0026gt; { private final T[] array; private ArrayCollection(T[] array) { this.array = array; } public static \u0026lt;T\u0026gt; ArrayCollection\u0026lt;T\u0026gt; of(T[] array) { return new ArrayCollection\u0026lt;\u0026gt;(array); } } 现在就可以存数据进集合了\n1 2 3 4 public static void main(String[] args) { String[] arr = new String[]{\u0026#34;AAA\u0026#34;,\u0026#34;BBB\u0026#34;,\u0026#34;CCC\u0026#34;,\u0026#34;DDD\u0026#34;}; ArrayCollection\u0026lt;String\u0026gt; collection = ArrayCollection.of(arr); } 现在我们就可以实现迭代器接口了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public class ArrayCollection\u0026lt;T\u0026gt; implements Iterable\u0026lt;T\u0026gt; { private final T[] array; private ArrayCollection(T[] array) { this.array = array; } public static \u0026lt;T\u0026gt; ArrayCollection\u0026lt;T\u0026gt; of(T[] array) { return new ArrayCollection\u0026lt;\u0026gt;(array); } @Override public Iterator\u0026lt;T\u0026gt; iterator() { return new ArrayIterator(); } public class ArrayIterator implements Iterator\u0026lt;T\u0026gt; { private int cur = 0; @Override public boolean hasNext() { return cur \u0026lt; array.length; } @Override public T next() { return array[cur++]; } } } 进行迭代\n1 2 3 4 5 6 7 8 9 public class Main { public static void main(String[] args) { String[] arr = new String[]{\u0026#34;AAA\u0026#34;,\u0026#34;BBB\u0026#34;,\u0026#34;CCC\u0026#34;,\u0026#34;DDD\u0026#34;}; ArrayCollection\u0026lt;String\u0026gt; collection = ArrayCollection.of(arr); for (String s : collection) { System.out.println(s); } } } 编译后的样子\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Main { public Main() { } public static void main(String[] args) { String[] arr = new String[]{\u0026#34;AAA\u0026#34;, \u0026#34;BBB\u0026#34;, \u0026#34;CCC\u0026#34;, \u0026#34;DDD\u0026#34;}; ArrayCollection\u0026lt;String\u0026gt; collection = ArrayCollection.of(arr); Iterator var3 = collection.iterator(); while(var3.hasNext()) { String s = (String)var3.next(); System.out.println(s); } } } 中介者模式 在早期，我们想要和别人进行语音聊天，一般都是通过电话的方式，我们通过拨打他人的电话号码，来建立会话，不过这样有一个问题，比如我现在想要通知通知 3 个人某件事情，那么我就得依次给三个人打电话，甚至还会遇到一种情况，就是我们没有某个人的电话号码，但是其他人有，这时还需要告知这个人并进行转告，就很麻烦。\n但是现在我们有了 Facetime、有了微信，我们可以同时让多个人参与到群通话中进行群聊，这样我们就不需要一个一个单独进行通话或是转达了。实际上正是依靠了一个中间商给我们提供了进行群体通话的平台，我们才能实现此功能，而这个平台实际上就是一个中间人。又比如我们想要去外面租房，但是我们怎么知道哪里有可以租的房子呢?于是我们就会上各大租房 APP 上去找房源，同样的,.如果我们现在有房子需要出租，我们也不知道谁会想要租房子，同样的我们也会把房子挂在租房 APP 上展示，而当我们去租房时或是出租时，就会有一个称为中介的人来跟我们对接，实际上也是一种中介的模式。\n在我们的程序中，可能也会出现很多的对象，但是这些对象之间的相互调用关系错综复杂，可能一个对象要做什么事情就得联系好几个对象：\n但是如果我们再这中间搞一个中间人\n这样当我们要联系其他人时，一律找中介就可以了，中介储了所有人的联系方式，这样就不会像上面一样乱成一团了。这里我们就以房产中介的例子来编写：\n1 2 3 4 5 6 7 8 9 10 11 public class Mediator { private final Map\u0026gt;String,User\u0026gt; userMap = new HashMap\u0026lt;\u0026gt;(); public void register(String address, User user) { userMap.put(address,user); } public User find(String address) { return userMap.get(address); } } 接着就是用户了，用户伊欧两种角色，一种时租房，一种是出租：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class User { String name; String tel; public User(String name, String tel) { this.name = name; this.tel = tel; } public User find(String address, Mediator mediator) { return mediator.find(address); } @Override public String toString() { return name + \u0026#34;（电话：\u0026#34; + tel + \u0026#34;）\u0026#34;; } } 测试一下\n1 2 3 4 5 6 7 8 9 10 11 12 13 public static void main(String[] args) { User user0 = new User(\u0026#34;刘女士\u0026#34;, \u0026#34;10086\u0026#34;); // 出租人 User user1 = new User(\u0026#34;李先生\u0026#34;, \u0026#34;10010\u0026#34;); //找房人 Mediator mediator = new Mediator(); //黑心中介 mediator.register(\u0026#34;房子地址\u0026#34;, user0); // 房子挂进中介 User user = user1.find(\u0026#34;房子地址1\u0026#34;, mediator); // 在中介找房子 if(User == null) System.out.println(\u0026#34;没有对应房源\u0026#34;); user = user1.find(\u0026#34;房子地址\u0026#34;, mediator); System.out.println(user); } 中介者模式优化了原有的复杂多对多关系，而是将其简化为一对多关系，更容易理解\n备忘录模式 2021年10月1日下午，河南驻马店的一名13岁女中学生，因和同学发生不愉快喝下半瓶百草枯。\n10月5日，抢救四天情况恶化，家属泣不成声称“肺部一个小时一变”\n10月6日下午，据武警河南省总队医院消息，“目前女孩仍在医院救治。”\n喝下百草枯，会给你后悔的时间，但是不会给你后悔的机会(百草枯含有剧毒物质，会直接导致肺部纤维化，这是不可逆的，一般死亡过程在一周左右，即使家里花了再多的钱，接受了再多的治疗，也无法逆转这一过程)相信如果再给这位小女孩一次机会，回到拿起百草枯的那一刻，一定不会再冲动地喝下了吧。\n备忘录模式，就为我们的软件提供了一个可回溯的时间节点，可能我们程序在运行过程中某一步出现了错误，这时我们就可以回到之前的某个被保存的节点上重新来过(就像艾克的大招)，我们平时编辑文本的时候，当我们编辑出现错误时，就需要撤回，而我们只需要按下 Ctrl+z 就可以回到上一步，这样就大大方便了我们的文本编辑。\n其实备忘录模式也可以应用到我们的程序中，如果你学习过安卓开发，安卓程序在很多情况下都会重新加载 Activity，实际上安卓中 Activity 的 onSaveInstancestate 和 onRestoreInstanceState 就是用到了备忘录模式，分别用于保存和恢复，这样就算重新加载也可以恢复到之前的状态。\n这里我们模拟一下对象的状态保存：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class Student { private String currentWork; // 当前正在做的事情 private int percentage; // 当前工作完成百分比 public void work(String currentWork) { this.currentWork = currentWork; this.percentage = new Randon().nextInt(100); } @Override public String toString() { return \u0026#34;我现在正在做：\u0026#34; + currentWork + \u0026#34;（进度\u0026#34; + percentage +\u0026#34;%）\u0026#34;; } } 接着我们需要保存它在某一时刻的状态，我们来编写一个状态保存类\n1 2 3 4 5 6 7 8 9 public class State { final String currentWork; final int percentage; State(String currentWork, int percentage) { // 仅开放给同一个包下的 Student 类使用，default 修饰即可 this.currentWork = currentWork; this.percentage = percentage; } } 接着我们来将状态的保存和恢复操作都实现一下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public class Student { private String currentWork; private int percentage; public void work(String currentWork) { this.currentWork = currentWork; this.percentage = new Randon().nextInt(100); } @Override public String toString() { return \u0026#34;我现在正在做：\u0026#34; + currentWork + \u0026#34;（进度\u0026#34; + percentage +\u0026#34;%）\u0026#34;; } public State save() { return new State(currentWork,percentage); } public void restore (State state) { this.currentWork = state.currentWork; this.percentage = state.percentage; } } 不过备忘录模式为了去保存对象的状态，会占用大量的资源，尤其是那种属性很多的对象，我们需要合理的使用才能保证程序稳定运行。\n观察者模式 牵一发而动全身，一幅有序摆放的多米诺骨牌，在我们推到第一个骨牌时，后面的骨牌会不断地被上一个骨牌推倒\n在 Java 中，一个对象的状态发生改变，可能就会影响到其他的对象，与之相关的对象可能也会联动的进行改变。还有我们之前遇到过的监听器机制，当具体的事件触发时，我们在一开始创建的监听器就可以执行相关的逻辑。我们可以使用观察者模式来实现这样的功能，当对象发生改变时，观察者能够立即观察到并进行一些联动操作，我们先定义一个观察者接口：\n1 2 3 public interface Observer {// 观察者接口 void update();// 当对象有更新时，会回调此方法 } 接着我们来写一个支持观察者的实体类：\n1 2 3 4 5 6 7 8 9 10 11 public class Subject { private final Set\u0026lt;Observer\u0026gt; observerSet = new HashSet\u0026lt;\u0026gt;(); public void observer(Observer observer) { // 添加观察者 observerSet.add(observer); } public void modify() { // 模拟对象进行修改 observerSet.forEach(Observer::update); // 当对象发生修改时，会通知所有的观察者，并进行方法回调 } } 状态模式 在标准大气压下，水在0度时会结冰变成固态，在0-100度之间时，会呈现液态，100度以上会变成气态，水这种物质在不同的温度下呈现出不同的状态，而我们的对象，可能也会像这样存在很多种状态，甚至在不同的状态下会有不同的行为，我们就可以通过状态模式来实现。\n我们来设计一个学生类，然后学生的学习方法会根据状态不同而发生改变，我们先设计一个状态接口：\n1 2 3 public enum State { NORMAL,LAZY } 接着来编写一个学生类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class Student { private State state; public void setState(State state) { this.state = state; } public void study() { switch(state) { case LAZY: System.out.println(\u0026#34;开摆\u0026#34;); break; case NORMAL: System.out.println(\u0026#34;干活\u0026#34;); break; } } } 策略模式 对面卡兹克打野被开了，我们是去打小龙还是打大龙呢？这就要看我们团队这一局的打法策略了。\n我们可以为对象设定一种策略，这样对象之后的行为就会按照我们在一开始指定的策略而决定了，看起来和前面的状态模式很像，但是，它与状态模式的区别在于，这种转换是“主动”的，是由我们去指定，而状态模式，可能是在运行过程中自动切换的。\n其实策略模式我们之前也遇到过，比如线程池的拒绝策略：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public static void main(String[] args) { ThreadPoolExecutor executor = new ThreadPoolExecutor(1,1,10, TimeUnit.SECONDS,new SynchronousQueue\u0026lt;\u0026gt;(),// 这里不给排队 new ThreadPoolExecutor.AbortPolicy());// 当线程池无法再继续创建新任务时，我们可以自由决定使用什么拒绝策略 Runnable runnable = () -\u0026gt; { try { TimeUnit.SECONDS.sleep(60); } catch (InterruptedException e) { throw new RuntimeException(e); } }; executor.execute(runnable); executor.execute(runnable); // 连续两次提交任务，肯定塞不下了，走拒绝 } 可以看到，如果我们使用 AbortPolicy，那么直接抛出异常\n访问者模式 公园中存在多个景点，也存在多个游客，不同的游客对同一个景点的评价可能不同;医院医生开的处方单中包含多种药元素，査看它的划价员和药房工作人员对它的处理方式也不同，划价员根据处方单上面的药品名和数量进行划价，药房工作人员根据处方单的内容进行抓药，相对于处方单来说，划价员和药房工作人员就是它的访问者，不过访问者的访问方式可能会不同。\n在我们的Java程序中，也可能会出现这种情况，我们就可以通过访问者模式来进行设计。\n比如我们日以继夜地努力，终于在某某比赛赢得了冠军，而不同的人对于这分荣誉，却有着不同的反应:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class Prize {// 奖 String name;// 比赛名称 String level;// 等级 public Prize(String name, String level) { this.name = name; this.level = level; } public String getName() { return name; } public String getLevel() { return level; } } 我们首先定义一个访问者接口\n1 2 3 public interface Visitor { void visit(Prize prize); } 然后就是访问者的相关实现\n1 2 3 4 5 6 7 public class Teacher implements Visitor { @Override public void visit(Prize prize) { System.out.println(\u0026#34;你得的是什么奖\u0026#34; + prize.name); System.out.println(\u0026#34;你得了几等奖\u0026#34; + prize.level); } } 1 2 3 4 5 6 7 public class Boss implements Visitor { @Override public void visit(Prize prize) { System.out.println(\u0026#34;你的奖项大吗\u0026#34;); System.out.println(\u0026#34;能为公司带来效益吗\u0026#34;); } } ","date":"2024-09-03T15:28:04+08:00","image":"https://akaxedx.github.io/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/zoye_hu5843364884554689153.jpg","permalink":"https://akaxedx.github.io/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","title":"设计模式"},{"content":"数据库相关 Mybatis 的优缺点 优点 基于 SQL 语言编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL 写在 XML 里，基础 SQL 与程序代码的耦合，便于统一管理；提供 XML 标签，支持编写动态 SQL 语句，并可重用 与 JDBC 相比，减少了 50% 以上的代码量，消除了 JDBC 大量冗余的代码，不需要手动开关连接 很好的与各种数据库兼容（因为 Mybatis 使用 JDBC 来连接数据库，所以只要 JDBC 支持的数据库 Mybatis 都支持） 能够与 Spring 很好的集成 提供映射标签，支持对象与数据库的 ORM 字段关系映射；提供对象关系映射标签，支持对象关系组件维护 缺点 SQL 语句的编写工作量大，尤其当字段多、关联表多时，对开发人员编写 SQL 语句的功底有一定要求 SQL 语句依赖于数据库，导致数据库移植性差，不能随意更换数据库 #{} 和 ${} 的区别 #{} 是预编译处理、是占位符，${} 是字符串替换、是拼接符\nMybatis 在处理 #{} 时，会将 SQL 中的 #{} 替换为 ? ，调用 PreparedStatement 来赋值\nMybatis 在处理 ${} 时，会将 SQL 中的 ${} 替换成变量的值，调用 Statement 来赋值\n使用 #{} 可以有效地防止 SQL 注入，提高系统安全性\n索引的基本原理 索引用来快速地寻找那些具有特定值的记录，如果没有索引，一般来说执行查询时遍历整张表\n索引的原理：就是把无序的数据编程有序的查询\n把创建了索引的列的内容进行排序 对排序结果生成倒排表 在倒排表内容上拼上数据地址链 在查询时先拿到倒排表内容，再取出数据的地址链，从而拿到具体数据 索引设计的原则 查询更快，占用空间更小\n适合索引的列时出现再 where 子句中的列，或者连接子句中指定的列 基数较小的类，索引效果较差，没必要在此列建立索引 使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间，如果搜索词超过索引前缀长度，则使用索引排除不匹配的行，然后检查其余行是否可能匹配 不要过度索引，索引需要额外的磁盘空间，并降低写操作的性能。再修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个事件就会越长。所以只要保持需要的索引有利于查询即可 定义有外键的数据列一定要建立索引 更新频繁字段不适合创建索引 若是不能有效区分数据的列不适合做索引列（如性别） 尽量的扩展索引，不要新建索引，比如表中已经有 a 的索引，现在要加 (a,b) 的 索引，那么只需要修改原来的索引即可 对于哪些查询中很少涉及的列，重复值比较多的列不要建立索引 对于定义为 text、image 和 bit 的数据类型的列不要建立索引 事务的基本特性和隔离级别 事务基本特性 ACID 原子性 指的是一个事务中的操作要么全部成功，要么全部失败\n一致性 指的是数据库总是从一个一致性的状态转换到另一个一致性的状态。比如 A 转账给 B 100 元，假设 A 只有 90 元，支付之前我们数据库里的数据都是符合约束的，但是如果事务执行成功，数据库数据就破坏约束了，因此事务不能成功\n隔离性 指的是一个事务的修改再最终提交前，对其他事务是不可见的\n持久性 指的是一旦事务提交，所做的修改就会永久保存到数据库中\n隔离性的四个隔离级别 read uncommit 读未提交，可能会读到其他事务未提交的数据，也叫做脏读，用户本来应该读取到 id = 1的用户 age 应该是 10，结果读到了其他事务还没有提交的事务，结果读取结果 age = 20，这就是脏读 read commit 读已提交，两次读取结果不一致，也叫不可重复读，不可重复读解决了脏读的问题，他只会读取已经提交的事务。用户开启事务读取 id = 1的用户，查询到 age = 10，再次读取发现结果未 20，在同一个事务里同一个查询读取到不同的结果叫做不可重复读 repeatable read 可重复读，mysql 默认级别，每次读取结果都一样，但是可能产生幻读 serializable 串行，一般是不会使用的，他会给每一行读取的数据加锁，会导致大量超时和锁竞争的问题 什么是 MVCC 多版本并发控制，指的是在使用 READ COMMITTD、REPEATABLE READ 这两种隔离级别的事务在执行普通 SELECT 操作时访问记录的版本链的过程。可以使用不同事务的读-写、写-读操作并发执行，从而提升系统性能。READ COMMITTD、REPEATABLE READ 这两个隔离级别的一个很大的不同是：生成 ReadView 的时机不同，READ COMMITTD 在每一次进行普通 SELECT 操作前都会生成一个 ReadView，而 REPEATABLE READ 只在第一次进行普通 SELECT 操作前生成一个 ReadView，之后的查询操作都重复使用这个 ReadView\nMyISAM 和 InnoDB 的区别 MyISAM 不支持事务，但是每次查询都是原子的 支持表级锁，每次操作对整个表加锁 存储表的总行数 一个 MyISAM 表有三个文件：索引文件，表结构文件，数据文件 采用非聚集索引，索引文件的数据域存储指向数据文件的指针。辅索引与主索引基本一致，但是辅索引不用保证唯一性 InnoDB 支持 ACID 的事务 支持事务的四种隔离级别 支持行级锁以及外键约束，因此可以支持写并发 不存储行总数 一个 InnoDB 引擎存储在一个文件空间（共享表空间，表大小不受操作系统控制，一个表可能分布在多个文件中），也可能未多个（设置为独立表空间，表大小受操作系统文件大小限制，一般为 2G），受操作系统文件大小的限制 主键索引采用聚集索引（索引的数据域存储数据文件本身），辅索引的数据域存储主键的值；因此从辅索引查找数据，需要先通过辅索引找到主键值，再访问辅索引；最好使用自增主键，防止插入数据时，为维持 B+ 树结构，文件的大调整 Explain 语句结果中各个字段分别表示什么 列名 描述 id 查询语句中每出现一个 SELECT 关键字，MySQL 就会为它分配一个唯一的 id 值，某些子查询会被优化为 join 查询，那么出现的 id 会一样 select_type SELECT 关键字对应的那个查询类型 table 表名 partitions 匹配的分区信息 type 针对单表的查询方式（全表扫描、索引） possible_keys 可能用到的索引 key 实际上使用的索引 ken_len 实际上使用的索引长度 ref 当使用索引列等值查询时，与索引列进行等值匹配的对象信息 rows 预估的需要读取的记录条数 filterte 某个表经过 搜索条件过滤后剩余记录条数的百分比 Extra 一些额外的信息，比如排列 索引覆盖是什么 索引覆盖就是一个 SQL 再执行时，可以利用索引来快速查找，并且此 SQL 所要查询的字段在当前索引对应的字段中都包含了，那么就表示此 SQL 走完索引后不用回表了，所需要的字段都在当前索引的叶子节点上存在，可以直接作为结果返回\n最左前缀原则 当一个 SQL 想要利用索引时，就一定要提供该索引锁对应的字段中最左边的字段，也iu是排在最前面的字段，比如针对 a,b,c 三个字段建立了一个联合索引，那么在写以恶搞 SQL 时就一定要提供 a 字段的条件，这样才能用到联合索引，这是由于建立 a,b,c 三个字段的联合索引时，底层的 B+ 树时按照 a,b,c 三个字段从左往右去比较大小进行排序的，所以如果想要利用 B+ 树进行快速查找也得符合这个规则\nInnoDB 是如何实现事务的 InnoDB 通过 Buffer Pool，LogBuffer，Redo Log，Undo Log 来实现事务，以一个 update 语句为例\nInnoDB 在收到一个 update 后，会先根据条件找到数据所在的也，并将该页缓存在 Buffer Pool 中 执行 update 语句，修改 Buffer Pool 重点数据，也就是内存中的数据 针对 update 语句生成一个 RedoLog 对象，并存入 LogBuffer 中 针对 update 语句生成 undolog 日志，用于事务回滚 如果事务提交，那么把 RedoLog 对象进行持久化，后续还有其他机制将 Buffer Pool 中所修改的数据页持久化到磁盘中 如果事务回滚，那么利用 undolog 日志进行回滚 B 树和 B+ 树的区别，为什么 Mysql 使用 B+ 树 B 树的特点\n节点排序 一个节点可以存放多个元素 B+ 树的特点\n拥有 B 树的特点 叶子节点之间有指针 非叶子节点上的元素在叶子节点上都冗余了，也就是叶子节点中存储了所有的元素，并且排好序 Mysql 索引使用的是 B+ 树，因为索引是用来加快查询的，而 B+ 树通过对数据进行 排序所以是可以提高查询速度的，然后通过一个节点中可以存储多个元素，从而可以使 B+ 树的高度不会太高，在 Mysql 中一个 InnoDB 页就是一个 B+ 树节点，一个 InnoDB 页默认 16kb，所以一般情况下一棵两层的 B+ 树可以存 2000万行左右的数据，然后利用 B+ 树叶子节点存储了所有数据并进行了排序，并且叶子几点之间有指针，可以很好的支持全表扫描，范围查找等 SQL\nMysql 锁有哪些，如何理解 按粒度分类\n行锁：锁某行数据，锁粒度最小，并发度高 表锁：锁整张表，锁粒度最大，并发度低 间隙锁：锁的是一个区间 按读写分\n共享锁：读锁，一个事务给某行数据加了读锁，其他事务可以读，但不能写 排他锁：写锁，一个事务给某行数据加了写锁，其他事务不能读不能写 按实现方式\n乐观锁：不会真正去锁某行记录，通过一个版本号来实现 乐观锁：上面的行锁、表锁都是悲观锁 在事务的隔离级别实现中，就需要利用锁来解决幻读\nRedis 的过期键的删除策略 Redis 是 key-value 数据库，我们可以设置 Redis 中缓存的 key 的过期时间。Redis 的过期策略就是指当 Redis 中缓存的 key 过期了，Redis 如何处理\n惰性过期：只有当访问一个 key 时，才会判断该 key 是否已经过期，过期则清除。该策略可以最大化节省 CPU 资源，对内存不友好，极端情况下可能出现大量的过期 key 没有再次被访问，从而不会被清除，占用大量内存 定时过期（Redis 没使用）：实时监控过期时间，对内存友好，对 CPU 不友好 定期过期：每隔一段时间，会扫描一定数量的数据库的 expires 字典中一定数量的 key，并清除其中已经过期的 key。该策略是前两者的折中方案。通过调整定时扫描的 时间间隔和每次扫描的限定耗时，可以在不同情况下使得 CPU 和内存资源达到最优的平衡效果 Redis 事务实现 事务开始 MULTI 命令的执行，标志着一个事务的开始。MULTI 命令会将客户端状态的 flags 属性中的 REDIS_MULTI 标识打开、 命令入队 当一个客户端切换到事务状态之后，服务器会根据这个客户端发送来的命令来执行不同的操作。如果客户端发送的命令为 MULTI、EXEC、WATCh、DISCARD 中的一个，立即执行这个命令，否则将命令放入一个事务队列里，然后向客户端返回 QUEUED 回复 如果客户端发送的命令为 EXEC、DISCARD、WATCh、MULTI 四个命令中的一个，那么服务器立即执行这个命令 如果发送到是其他命令，服务器并不立即执行这个命令。首先检查命令格式是否正确，如果不正确，服务器会在客户端状态（redisClient）的 flags 属性关闭 REDIS_MULTI 标识，并返回错误信息给客户端。如果正确，将这个命令放入一个事务队列里，然后返回 QUEUED 回复 事务队列是按照 FIFO 的方式保存入队命令 事务执行 客户端发送 EXEC 命令，服务器执行 EXEC 命令逻辑 如果客户端状态的 flags 属性不包含 REDIS_MULTI 标识，或者包含 REDIS_DIRTY_CAS 或者 REDIS_DIRTY_EXEC 标识，那么就直接取消事务的执行 否则客户端处于事务状态（flags 有 REDIS_MULTI标识），服务器会遍历客户端的事务队列，然后执行事务队列中的所有命令，最后将返回结果全部返给客户端 redis 不支持事务回滚机制，但是他会检查每一个事务中的命令是否错误 redis 事务不支持检查程序员自己逻辑的错误 WATCH 命令是一个乐观锁，可以为 Redis 事务提供 check-and-set （CAS）行为。可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到 EXEC 命令 MULTI 命令用于开启一个事务，它总是返回 OK。MuLTI 执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当 EXEC 被调用时，所有队列中的命令才会被执行 EXEC：执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。当操作被打断时，返回空值 nil 通过调用 DISCARD，客户端可以清空事务队列，并放弃执行事务，并且客户端会从事务状态退出 UNWATCH 命令可以取消 WATCH 对所有 key 的监控 Redis 主从复制的核心原理 通过执行 slaveof 命令或设置 slaveof 选项，让一个人服务器去复制另一个服务器的数据。主数据库可以进行读写操作，当昔日操作导致数据变化时会自动将数据同步给从数据库。而从数据库一般是只读的，并接受主数据库同步过来的数据。一个主数据库可以拥有多个从数据库，而一个从数据库只能拥有一个主数据库\n全量复制 主节点通过 bgsave 命令 fork 子进程进行 RDB 持久化，该过程是非常消耗 CPU、内存（页表复制）、硬盘 IO 的 主节点通过网络将 RDB 文件发送给从节点，对主从节点的带宽都会带来很大的消耗 从节点清空老数据、载入新 RDB 文件的过程是阻塞的，无法响应客户端的命令；如果从节点执行 bgrewriteaof，也会带来额外的消耗 部分复制 复制偏移量：执行复制的双方，主从节点，分别会维护一个复制偏移量 offset 复制积压缓冲区：主节点内部维护了一个固定长度、先进先出 （FIFO）队列作为复制积压缓冲区，当主从节点 offset 的差距过大超过缓冲区长度时，将无法执行部分复制，只能执行全量复制 服务运行 ID（runid）：每个 Redis 节点都有其运行 ID，yunxing ID 由节点在启动时自动生成，主节点会将自己运行ID 发送给从节点，从节点会将主节点的运行 ID 存起来。从节点 Redis 断开重连的时候，就是根据运行 ID 来判断同步的进度： 如果从节点保存的 runid 与主节点现在的 runid 相同，说明主从节点之前同步过，主从节点会继续尝试使用部分复制（到底能不呢部分复制还要看 offset 和复制积压缓冲区的情况）； 如果从节点保的 runid 与主节点现在的 runid 不同，说明从节点在断线前同步的 Redis 节点并不是当前的主节点，只能进行全量复制 过程原理：\nRedis 有哪些数据结构，有哪些应用场景 字符串：可以用来做最简单的数据，可以缓存某个简单的字符串，也可以缓存某个 json 格式的字符串，Redis 分布式锁就利用了这种数据结构，还包括可以实现计数器、Session 共享、分布式 ID 哈希表：可以用来存储一些 key-value 对，更适合用来存储对象 列表：Redis 的列表通过命令的组合，既可以当作栈，也可以当作队列来使用，可以用来缓存类似微信公众号、微博等消息流数据 集合：和列表类似，也可以存储多个元素，但是不能重复，集合可以进行交集、并集、差集等操作，从而可以实现类似，我和某人共同关注的人、朋友圈点赞等功能 有序集合：集合是无序的，有序集合可以设置顺序，可以实现排行版功能 Redis 分布式锁底层是如何实现的 首先利用 setnx 来保证：如果 key 不存在才能获取到锁，如果 key 存在，则获取不到锁 然后还要利用 lua 脚本来保证多个 redis 操作的原子性 同时还要考虑到锁过期，所需要额外的一个看门狗定时任务来监听锁是否需要续约 同时还要考虑到 redis 节点挂掉后的情况，所以需要采用红锁的方式来同时向 N/2+1 个节点申请锁，都申请到了才证明获取锁成功，这样就算其中某个 redis 节点挂掉了，锁也不能被其他客户端获取到 Redis 集群策略 Redis 提供了三种集群策略\n主从模式：这种模式比较简单，主库可以读写，并且会和从库进行数据同步，这种模式下，客户端直接连接主库或者某个从库，但是当主库或者从库宕机后，客户端需要手动修改 IP，另外，这种模式也比较男进行扩容，整个集群所能存储的数据受到某台机器的内存容量，所以不可能支持特大数据量 哨兵模式：这种模式在主从的基础上新增了哨兵节点，但主库节点宕机后，哨兵会发现主库节点宕机，然后在从库中选择一个库作为新发主库，另外哨兵也可以做集群，从而可以保证当某一个哨兵接待你宕机后，还有其他哨兵节点可以继续工作，这种模式可以比较好的保证 Redis 集群的高可用，但是仍然不能很好的解决 Redis 的容量上限问题 Cluster 模式：Cluster 模式是用的比较多的模式，它支持多主多从，这种模式会按照 key 进行槽位的分配，可以使得不同的 key 分散到不同的主节点上，利用这种模式可以使得整个集群支持更大达到数据容量，同时每个主节点可以拥有自己的多个从节点，如果该主节点宕机，会从他的从节点选举一个新的主节点 对于这三种模式，如果 Redis 要存的数据量不大，可以选择哨兵模式，如果 Redis 要存的数据量大，并且需要持续的扩容，那么选择 Cluster 模式\n缓存穿透，缓存击穿，缓存雪崩分别是什么 缓存中存放的大多都是热点数据，目的就是防止请求可以直接从缓存中获取到数据，而不用访问 Mysql\n缓存雪崩：如果缓存中某一时刻大批热点数据同时过期，那么就可能导致大量请求直接访问 Mysql 了，解决办法就是在过期时间增加一点随机值，另外如果搭建一个高可用的 Redis 集群也是防止缓存雪崩的有效手段 缓存击穿：和缓存雪崩类似，缓存雪崩使大批热点数据失效，而缓存击穿是指某一个热点 key 突然失效，也导致了大量请求直接访问 Mysql 数据库，这就是缓存击穿，解决方案就是考虑这个热点 key 不设过期时间 缓存穿透：假如某一时刻访问 Redis 的大量 key 都不存在 Redis 中（如黑客故意伪造的 key），那么也会给数据库造成压力，这就是缓存穿透，解决方案是使用布隆过滤器，它的作用就是如果它认为一个 key 不存在，那么这个 key 就肯定不存在，所以可以在缓存之前增加一层布隆过滤器来拦截不存在的 key Redis 和 Mysql 如何保证数据一致 先更新 Mysql 再更新 Redis，如果更新 Redis 失败，可能仍然不一致 先删除 Redis 缓存数据，再更新 Mysql，再此查询的时候将数据加到缓存中，这种方案能解决第一个问题，但是在高并发下性能较低，而且仍然会出现数据不一致的问题，比如线程1删除了 Redis 缓存数据，正在更新 Mysql，此时另外一个查询再查询，就会把 Mysql 中的老数据又插到 Redis 中 延时双删，先删除 Redis 缓存数据，再更新 Mysql，延迟几百毫秒再删除 Redis 缓存数据，这样就算在更新 Mysql 时，有其他线程读了 Mysql，把老数据读到了 Redis 中，那么也会被删除，保证数据一致性 Redis 持久化机制 RDB 快照文件，二进制写进磁盘\n手动触发：\nsave 命令，使 Redis 处于阻塞状态，直到 RDB 持久化完成，才会响应其他客户端发来的命令，所以在生产环境一定要慎用 bgsave 命令，fork 出一个子进程执行持久化，主进程只在 fork 过程中有短暂的阻塞，子进程创建之后，主进程就可以响应客户端请求了 自动触发：\nsave m n：在 m 秒内，如果有 n 个键发生改变，则自动触发持久化，通过 bgsave 执行，如果设置多个，只要满足其一就会触发，配置文件有默认配置（可以注释掉） flushall：用于清空 Redis 所有的数据库，flushdb 清空当前 Redis 所在数据库（默认是0号数据库），会清空 RDB 文件，同时也会生成 dump.rdb、内容为空 主从同步：全量同步时会自动触发 bgsave 命令。生成 rdb 发送给从节点 优点：\n整个 Redis 只包含一个文件 dump.rdb，方便持久化 容灾性好，方便备份 性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以时 IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 Redis 高性能 相对于数据集大时，比 AOF 的启动效率更高 缺点：\n数据安全低。RDB 是间隔一段时间进行持久化，如果持久化之间 Redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候 由于 RDB 是通过 fork 子进程来协助完成数据持久化工作的，因此，如果当数据集较大时可能会导致整个服务器停止服务几百毫秒，甚至一秒钟，会占用 CPU AOF 以日志形式记录服务器所处理的每一个写、删除操作，以文本方式记录，可以打开文件看到详细的操作记录\n所有的写命令会追加到 AOF 缓冲中 AOF 缓冲区根据对应的策略向硬盘进行同步操作 随着 AOF 文件越来越大，需要定期对 AOF 文件进行重写，达到压缩的目的 当 Redis 重启时，可以加载 AOF 文件进行数据恢复 同步策略：\n每秒同步：异步完成，效率非常高，一旦系统出现宕机现象，那么这一秒钟之内修改的数据将会丢失 每修改同步：同步持久化，每次发生的数据变化都会被记录到磁盘中，最多丢失一条 不同步：由操作系统控制，可能丢失较多数据 优点：\n数据安全 通过 append 模式写文件，即使中途服务器宕机也不会劈坏已经存在的内容，可以通过 redis-check-aof 工具解决数据一致性的问题 AOF 机制的 rewrite 模式。定期对 AOF 文件进行重写，以达到压缩的目的 缺点：\nAOF 文件比 RDB 文件大，恢复速度慢 数据集大的时候，比 RDB 启动效率低 运行效率没有 RDB 高 Redis 单线程为什么这么快 Redis 基于 Reactor 模式开发了网络事件处理器、文件事件处理器 file event handler。它是单线程的，所以 Redis 才叫做单线程的模型\n","date":"2024-09-02T10:17:38+08:00","image":"https://akaxedx.github.io/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/saber_hu4745314353014532042.jpg","permalink":"https://akaxedx.github.io/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/","title":"数据库相关"},{"content":"计算机基础 计网 计网定义 一些互相连接的自治的计算机的集合\n1 2 3 4 5 互联：是指计算机之间可以通过有线或者无线的方式进行数据通信 自治：是指独立的计算机，他有自己的硬件和软件，可以单独运行使用 集合：是指至少需要两台计算机 中国的三大 ISP ：中国电信，中国联通，中国移动\n一旦某个用户能够接入到因特网，所需要的就是购买一些如调制解调器或路由器这样大设备，让其他用户可以和他相连\n网络协议三要素 语法、语义、同步\n1 2 3 4 5 语法：用户数据与控制信息的结构和格式 语义：需要发出控制信息，以及完成的动作与做出的响应 同步：可以理解为时序，即对时间实现顺序的详细说明 三种交换方式 路由器 是实现 分组交换 的关键构件，其任务是 转发 收到的分组，这是网络核心部分最重要的功能\n传统两两相连的方式，当电话数量很多时，电话线也很多，不方便\n电路交换 电话交换机接通电话线的方式就是电路交换 分组交换 1 2 3 4 5 通常我们把表示该消息的整块数据称为一个报文 在发送报文之前，先把较长的报文划分成一个个更小的等长数据段，在每一个数据段前面，加上一些由必要的控制信息组成的 首部，就构成了一个分组，也可以称为 “包” 首部包含了分组的目的地址 发送过程\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 发送方 构造分组 发送分组 路由器 缓存分组 转发分组 简称为 “分组转发” 路由器处理分组的过程： 把收到的分组先放入缓存（暂时存储） 查找转发表，找出到某个目的地地址应从哪个端口转发 把分组送到适当的端口转发出去 接收方 接收分组 还原报文 报文交换 1 2 报文交换中的结点页采用存储转发方式，但报文交换，对报文的大小没有限制，这就要求 结点交换机需要较大的缓存空间 报文交换主要用于早期的电报通信网，现在较少使用，通常被较先进的分组交换方式所取代 三种交换方式的对比 假设 A B C D 是分组传输路径所要经过的 4 个结点交换机，纵坐标为时间\n按覆盖范围分类 广域网（WAN） 1 作用范围通常为几十到几千公里，因而又是也称为远程网。广域网是互联网的核心部分，其任务是通过 长距离 运送主机所发送的数据 城域网（MAN） 1 作用范围一般是一个城市，可跨越几个街区 甚至是整个城市 局域网（LAN） 1 一般用微型计算机或工作站通过高速通信线路相连（速率通常在 10 Mbit/s 以上），但地理上范围较小（1 km 左右） 个域网（PAN） 1 就是在个人工作的地方把个人使用的 电子设备 用 无线技术 连接起来的网络 按拓扑结构分类 总线型网络 星型网络 环形网络 网状型网络 计算机网络的性能指标 速率 传送比特的速率，也成为比特率或者数据率\n带宽 网络的通信线路所能传送数据的能力\n单位：Hz\n吞吐量 在单位时间内通过某个 信道 的数据量\n时延、等等 按传输介质分类 有线网络 无线网络 常见计算机网络体系结构 【计算机网络】的体系结构是 计算机网络的各层及其协议的集合\n如今使用的最多的是 TCP/IP 体系结构，新进闺蜜最大的，覆盖全球的\n大概流程 物理层 就是解决在各种传输媒体上传输比特 0 和 1 的问题，进而给数据链路层提供 透明传输比特流的服务\n主要由以下四个任务 机械特性：指明所有接线器的形状和尺寸。引脚数目和排列、固定和锁定装置 电气特性：指明在接口电缆的各条线上出现的电压的范围 功能特性：指明某条线上出现的某一电平的电压表示何种意义 过程特性：指明对于不同功能的各种可能事件的出现顺序 传输媒体分为两类：引导型传输媒体，非引导型传输媒体\n引导型传输媒体：通轴电缆、双绞线、光纤、电力线 非引导行传输媒体：无线电波、微波、红外线、可见光 传输方式 串行传输 数据是一个比特一个比特依此发送的，只需要一条数据传输线路\n并行传输 一次发送 n 个比特，需要 n 条传输线路\n同步传输 1 数据块以稳定的比特流形式传输，字节之间没有间隔，接收端在每个比特的中间时刻进行检测，以判别接收到的比特 0 或是比特 1 异步传输 1 以字节为独立的传输单位，字节之间的时间间隔是不固定的，在每个字节的前后分别加上起始位和结束位 单向通信 又称单工通信，通信双方只有一个传输方向\n双向交替通信（半双工） 可以互相传输数据，但是不能同时进行\n双向同时通信（双工） 通信双方可以同时发送和接收消息\n码元 简单来说 码元 就是一段调制好的 基本波形 ，可以表示比特信息\n编码、调制 信号失真 1 信号在传输过程中会受到各种因素的影响，是的信号波形失去码元之间的清晰界限，这种现象称为 码间串扰 1 2 3 4 5 造成信号失真的因素 码元传输速率 信号传输距离 噪声干扰 传输媒体质量 奈氏准则 奈氏准则 是理想条件下推导的，没有考虑传输距离、噪声干扰等因素\n香农公式 数据链路层 概述 链路 是从一个 结点到相邻结点 的一段 物理线路 ，数据链路 则是在 链路的基础 上增加了一些必要的 硬件（如网络适配器）和软件（如协议的实现）\n数据链路层传送的协议数据单元是 帧\n封装成帧 封装成帧 就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧 首部和尾部的一个重要的作用就是进行 帧定界 透明传输 如果数据中的某个字节的 二进制代码恰好和 SOH 或 EOT 一样，数据链路就会 错误地“找到帧的边界”\n解决透明传输的方法\n1 面向 字节的物理链路 使用 字节填充，面向 比特的物理链路 使用 比特填充 的方式实现透明传输 发送端的数据链路层在数据中出现控制字符 “SOH” 或 “EOT” 的前面 插入一个转义字符“ESC”\n差错检测 比特在传输过程中可能会产生差错，1可能变成0，0可能变成1，这就称为比特差错\n差错检测法 奇偶校验 只能检测出奇数个比特出现错误码的情况\nCRC 集线器 集线器是运作在 OSI 模型中的 物理层 ，可以是做多端口的【中继器】\n交换机 也叫做　交换式集线器，它通过对信息进行重新生成，并经过内部处理后　转发至指定端口，具备自动寻址能力和交换作用，在数据链路层\n集线器和交换机的区别 集线器平分带宽，交换机的话也是　３Ｍ\n最初　的　以太网　是将许多计算机都连接到同一根总线上\nCSMA/CD 【CSMA/CD】即 冲突检测 的 载波监听多路访问 的方法\n三大要点 多点接入：说明这是总线型网络，许多计算机以多点接入的方式连接在一根总线上 载波监听：用电子技术检测总线上有没有其他计算机也在发送 碰撞检测：即适配器便发送数据边检测信道上的信号电压的变化情况，以便判断自己在发送数据时其他站是否也在发送数据 PPP 点对点协议，为在点对点连接上传输多协议数据包提供了一个标准方法，为两个对等节点之间的 IP 流量传输提供一种 封装协议\n广播域 指网络中的某一设备同时向 网络中所有的其他设备发送数据，这个数据所能 广播到的范围 即为广播域\n冲突域 多少 站点能抽到这个信息，这些站点就构成一个冲突域\n交换机 所有端口都在同一个广播域内，而每一个端口就是一个冲突域，所以交换机能分割冲突域，但分割不了广播域 。但是，虚拟局域网（Vlan） 技术的交换机可以 隔离广播域\nA 发消息 BC 都能收到\nVLAN 虚拟局域网 VLAN 是由一些局域网网段构成的 与物理位置无关的逻辑组\n同一个 VLAN 内部可以广播通信，不同 VLAN 不可以广播通信 接口划分方式 1 2 3 4 5 6 1、Access 接口 Access 接口一般用于和不能识别 Tag 的用户终端（如用户主机、服务器等）相连，或者不需要区分不同 VLAN 成员时使用 2、Trunk 接口 Trunk 接口一般用于连接交换机、路由器、AP 以及可以同时收发 Tagged 帧和 Untagged 帧的语音终端 3、Hybrid 接口 Hybrid 接口既可以用于连接不能识别 Tag 的用户终端，也可以用于连接交换机、路由器以及可以同时收发 Tagged 帧和 Untagged 帧的语音终端、AP 所属 VLAN 允许通过 VLAN access 只能一个（即划入的 VLAN） 只能一个即划入的 VLAN trunk 只能一个 （即 pvid） 任意个 MAC 地址 MAC 地址是一个 唯一标识符，有助于在任何网络上识别您的机器\nARP 地址解析协议 IP 地址解析为以太网 MAC\n1 当主机或其他网络设备由数据要发送给另一个主机或设备时，它必须知道对方的网络层地址（即 IP地址）。但是仅仅由 IP 地址是不够的，因为 IP 数据报必须封装成帧才能通过物理网络发送，因此发送站还必须由接收站的地址，所以需要一个从 IP 地址到物理地址的映射 网络层 作用 确定在本路由器如何转发分组，确定分组从源到目的经过的路径，是 点到点 服务\nIP （网际协议） IP 地址\n1 2 ipv4：32位\t二进制\t192.168.100.1\t主流 ipv6：128位\t十六进制\tffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff\t在使用，未来会普及 IP 地址的组成\n1 2 3 网络号 + 主机号 network + host 网络号：用来标识一个网段\n主机号：用来标识这个网段上的某一台主机\nIP 地址的分类\nA 类 1 2 3 网络号.主机号.主机.主机 第一个可指派的网络号位1，网络地址为 1.0.0.0 最后一个可指派的网络号为 126 网络地址为 126.0.0.0 1 2 3 4 5 6 可指派的网络号：2^(8-1) - 2 减2的原因是除去最小网络号0和最大网络号127 127.0.0.1 回环地址，用来在每台计算机测试 tcp/ip 协议使用，只能在本机访问，别人不允许访问 可分配的 ip 地址共有：2^24 - 2 、 其中减去的为全为0的网络地址和全为1的广播地址 B 类 1 2 3 4 5 6 128 ~191 网络号.网络号.主机.主机 最小网络号也是第一个可指派的网络号128.0网络地址为128.0.0.0 最大网络号也是最后一个可指派的网络号191.255网络地址为191.255.0.0 可指派的网络号：2^(16-2)-2 可分配的 ip 地址共有：2^16-2个 C 类 1 2 3 4 5 6 7 8 192 ~223 网络号.网络号.网络号.主机 最小网络号也是第一个可指派的网络号192.0.0网络地址为192.0.0.0 最大网络号也是最后一个可指派的的网络号223.255.255网络地址为223.255.255.0 2^(24-3) -2 2^8 -2 个 公网上使用ABC三类地址\nD 类 1 224 ~ 组播地址 E 类 保留给科学家使用\n有人提出是否可以从主机号部分借用一部分作为子网号\n所以就有了一个划分子网的工具：子网掩码\n从1985 年起 在 IP 地址中 又 增加了一个“子网号字段”，使两级的 IP 地址变为三级的 IP 地址\nCIDR 无类域间路由选择\n消除了传统的 A 类、B 类和 C 类地址以及划分子网的概念，因而可以更加有效地分配 IPv4 的地址空间\n即在 IP 地址后面加上一个斜线“/”，然后写上网络前缀所占的比特数\n1 192.168.1.0/22 子网掩码概念\n子网掩码可以表明分类 IP 地址的主机号部分被借用了几个比特做为子网号\n如何划分子网 从 主机号 借用若干个为 作为子网号 subnet-id，而主机号，也就相应减少了若干个位\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 网络地址：网络号 + 子网号 + 主机号（全为0） 广播地址：网络号 + 子网号 + 主机号 （全为1） 子网掩码：网络号（全为1） + 子网号（全为1） + 主机号（全为0） IP 地址总数：根据主机号的位数进行确定 可分配 IP 地址数：IP 地址总数 - 2（去除主机号全为0的网络地址和主机号全为1的广播地址） 可分配 IP 地址范围：就是子网地址 + 1 ~ 广播地址 - 1 A 类地址 网络号8位主机号24位\t地址范围是1.0.0.0~126.0.0.0 B 类地址 网络号16位主机号16位\t地址范围是128.0.0.0~191.255.0.0 C 类地址 网络号24位主机号8位\t地址范围是192.0.0.0~223.255.255.0 划分子网是从主机号中借位进行划分的 子网划分方式有两种\t①定长子网划分\t②可变长子网划分 直接交付和间接交付 如果 目的网络地址和源 网络地址相同，就是在 同一个网络中，属于直接交付\n如果 目的网络地址和源 网络地址不相同，就 不在同一个网络中，属于间接交付， 通常是一个路由器帮忙转发\n类型 1 2 3 直连网络 静态路由（人工配置） 动态路由（路由选择协议） 如何判断是不是同一个网段 创建 vlan1：ip 地址：192.168.1.1 子网掩码：255.255.255.0\n创建 vlan2：ip 地址：192.168.2.1 子网掩码：255.255.255.0\n那么他们是不是在同一个网段呢\n​\t详细计算\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 将 ip 地址 192.168.1.1 转为二进制 11000000 10101000 00000001 00000001 将子网掩码 255.255.255.0 转为二进制 11111111.11111111.11111111.00000000 然后将两者与运算 11000000 10101000 00000001 00000001 11111111.11111111.11111111.00000000 得到 11000000 10101000 00000001 00000000 转成网络号是 192.168.1.0 将 ip 地址 192.168.2.1 转为二进制 11000000 10101000 00000010 00000001 将子网掩码 255.255.255.0 转为二进制 11111111.11111111.11111111.00000000 然后将两者与运算 11000000 10101000 00000010 00000001 11111111.11111111.11111111.00000000 得到 11000000 10101000 00000010 00000000 转成网络号是 192.168.2.0 不是一个网段 传输层 概念 IP 层是实现点到点的连接\n传输层是提供【端到端】的连接，即实现不同进程之间的通信\n在传输层主要依赖 TCP 和 UDP 协议，TCP 是一种可靠的、面向连接的通信协议。UDP 是一种不可靠、无连接的通信协议\nTCP TCP 报文结构 1 2 3 4 5 6 7 8 9 10 11 12 源端口号：发送数据进程的端口号，范围0~65525 目标端口号：接收数据进程的端口号，范围0~65525 序列号：序列字段的值指的是本报文段所发送的数据的第一个字节的序号 确认号：期望收到对方的下一个报文段的数据的第一个字节的序号 URG：紧急比特，当 URG = 1 时，表明紧急指针字段有效，它告诉系统此报文中有紧急数据应尽快传送（相当于高优先级的数据） ACK：确认比特，只有当 ACK = 1 时确认号字段才有效。当 ACK = 0 时，确认号无效 PSH：推送比特，接收方 TCP 收到推送比特置 1 的报文段，就尽快地交付给接收应用进程，而不再等到整个缓存都填满了后再向上交付 RST：复位比特，当 RST = 1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新尽力运输连接 SYN：同步比特，同步比特 SYN 置为 1，就表示这是一个连接请求或连接接受报文 FIN：终止比特，用来释放一个连接。当 FIN = 1 时，表明此报文段的发送端的数据已经发送完毕，并要求释放运输连接 三次握手 四次挥手 TCP 流量控制 TCP 拥塞控制 1 TCP 进行拥塞控制的算法有四种，即慢开始、拥塞避免、快重传和快恢复 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 （1）慢开始算法 在 TCP 刚刚连好并开始发送 TCP 报文段时，先令拥塞窗口 cwnd = 1，使用慢开始算法后，每经过一个传输轮次（即往返时延 RTT），拥塞窗口 cwnd 就会加倍，即 cwnd 的大小指数式增长。这样，慢开始一直把拥塞窗口 cwnd 增大到一个规定的慢开始门限 ssthresh（阈值），然后改用拥塞避免算法 （2）拥塞避免算法 拥塞避免算法的做法如下：发送端的拥塞窗口 cwnd 没经过 一个往返时延 RTT 就增加一个 MSS 的大小，而不是加倍，使 cwnd 加法增大 · 当 cwnd \u0026lt; ssthresh 时，使用慢开始算法 · 当 cwnd \u0026gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法 · 当 cwnd = ssthresh 时，既可以使用慢开始算法，又可以使用拥塞避免算法（通常做法） 网络拥塞的处理 网络出现拥塞时，无论是在慢开始阶段还是在拥塞避免阶段，把慢开始门限 ssthresh 设置为出现拥塞时发送方的 cwnd 值的一半（但不能小于2）。然后把拥塞窗口 cwnd 重新设置为 1，执行慢开始算法 （3）快重传 在 TCP 可靠传输机制中，快重传技术使用了冗余 ACK 来检测丢包的发生，在某些情况下可更早地重传丢失的报文段。当发送方连续收到三个重复的 ACK 报文时，直接重传对方尚未收到的报文段，而不必等待那个报文段设置的重传计时器超时 （4）快恢复 发送端收到连续三个冗余 ACK （即重复确认）时，执行“乘法减小”算法，把慢开始门限 ssthresh 设置为出现拥塞时发送方 cwnd 的一半，慢开始算法将拥塞窗口 cwnd 设置为 1，但是它设置为 ssthresh / 2 的值开始，由于跳过了 cwnd 从 1 起始的慢开始过程，所以称为快恢复 UDP UDP 报文结构 1 2 3 4 源端口号：通常包含发送数据报的应用程序所使用的 UDP 端口。接收端的应用程序利用这个字段的值作为发送响应的目的地址。这个字段是可选的，所以发送端的应用程序不一定会把自己的端口号写入该字段中。如果不写入端口号，则把这个字段设置为0。这样，接收端的应用程序就不能发送响应了 目标端口号：接收端计算机上 UDP 软件使用的端口 长度：表示 UDP 数据报长文，包含 UDP 报文头和 UDP 数据长度 校验和：检验数据在传输过程中是否被损坏 TCP 和 UDP 的区别 UDP TCP 是否连接 无连接 面向连接 是否可靠 不可靠传输，不使用流量控制和拥塞控制 可靠传输，使用流量控制和拥塞控制 连接对象个数 支持一对一，一对多，多对一和多对多交互通信 只能是一对一通信 传输方式 面向报文 面向字节流 首部开销 首部开销小，仅 8 字节 首部最小 20 字节，最大 60 字节 适用场景 适用于实时应用（IP 电话、视频会议、直播等） 适用于要求可靠传输的应用，例如文件传输 端口 TCP 端口是指就是为 TCP 协议通信提供服务的端口。在 TCP 传输控制协议中，建立端对端的连接是靠 IP 地址和 TCP 的端口号的共同作用。UDP 端口是指就是为 UDP 协议通信提供服务的端口\n端口号的范围是从 1~65535，一般分为 3 类端口：熟知端口号，登记端口号，客户端口号或短暂端口号\n熟知端口号：数值一般为0~1023，每个端口号应用于特定熟知的应用协议\n登记端口号：数值为 1024~49151，为没有熟知端口号的应用程序使用的，使用这个范围的端口号必须在 IANA 互联网数字分配机构登记，以防止重复\n客户端口号或短暂端口号：数值为 49151~65535，留给客户进程选择暂时使用\n常见端口列表\n应用层 网络应用模型 客户/服务器模型 服务器：系统启动后，便不断运行，被动等待并接受来自客户机的请求 客户机：请求计算服务的主机 P2P 模型 1 2 3 在 P2P 模型中，任意一对计算机称为对等方（Peer），直接相互通信 在对等网络中上的每台计算机具有相同的功能，没有主从之分，没有专用服务器，也没有专用工作站，任何一台计算机既可以作为服务器，又可以作为工作站 1 在 P2P 中，随着用户不断加入，服务需求的不断增加，系统的整体资源和服务能力得以同步扩充和提高。新用户的加入可以提供服务和资源，更好地满足了网络中用户的需求，促进分布式体系的实现 DNS 域名系统：便于把具有特定含义的主机名转换为便于机器处理的 IP 地址\n分类 包括顶级域名，二级域名，三级域名等\n1 2 3 4 5 6 以 tieba.baidu.com为例 正确的域名划分为 .com 顶级域名/一级域 baidu.com\t二级域名 tieba.baidu.com\t三级域名 detail.tieba.baidu.com\t四级域名 1 2 3 4 递归查询和迭代查询的区别： 递归查询是一种 DNS 服务器的查询模式，在该模式下 DNS 服务器接收到客户机请求，必须使用一个准确的查询结果回复客户机。如果 DNS 服务器本地没存储查询 DNS 信息，那么该服务器会询问其他服务器，并将返回的查询结果提交给客户机 迭代查询 DNS 服务器是另外一种查询模式，DNS 服务器会向客户机提供其他能够解析查询请求的 DNS 服务器，当客户机发送查询请求时，DNS 服务器并不直接回复查询结果，而是告诉客户机另一台 DNS 服务器地址，客户机再向这台 DNS 服务器提交请求，依此循环直到返回查询的结果 几个重要的协议 1 2 3 4 5 6 7 8 9 1、远程登录协议（Telnet） 2、文件传输协议（FTP） 3、超文本传输协议（HTTP） 4、域名服务协议（DNS） 5、简单邮件传输协议（SMTP） 6、邮局协议（POP3） 其中，从网络上下载文件时使用的是 FTP 协议，上网浏览网页时使用的是 HTTP 协议 在网络上访问一台主机时，通常不直接输入 IP 地址，而是输入域名，用的时 DNS 服务协议，它会将域名解析为 IP 地址 通过 FoxMail 发送电子邮件时，使用 SMTP 协议，接收电子邮件时使用 POP3 协议 万维网 概述 概念：万维网 是 超大规模，联机形式的 资料空间，是 海量网络站点和网页集合 定位资源：使用 统一资源定位符 URL 可以唯一标识一个资源，这个资源可以是文本，视频，音频，图片 URL 形式：\u0026lt;协议\u0026gt;://\u0026lt;主机地址\u0026gt;:\u0026lt;端口号\u0026gt;/\u0026lt;路径\u0026gt; 1 2 3 4 协议：http，ftp 主机地址：IP 地址， 域名 端口号：16 位端口号，0~65535 URL 不区分大小写字母 获取资源：用户点击超链接获取资源， 服务器通过 HTTP 协议 将资源传输给用户 万维网工作方式：客户端/服务器 方式，客户端就是网页浏览器 IE，火狐等，服务器是部署 HTTP 服务器程序，如 Tomcat，IIS HTTP 定义了 浏览器 向 服务器 请求资源的方式，以及 服务器 如何将资源 发送给浏览器，具体流程如下\n1 2 3 4 5 6 7 8 9 （1）用户操作：用户 在浏览器上 输入 URL，或点击超链接 （2）分析 URL：浏览器 分析 URL 链接 （3）请求 IP 地址：浏览器向 DNS 服务器请求域名对应的 IP 地址 （4）解析 IP 地址：DNS 服务器将域名解析成 IP 地址 （5）建立 TCP 连接：客户端与服务器端建立 TCP 连接 （6）浏览器申请资源：浏览器向服务器发出申请资源命令 （7）服务器响应：服务器响应浏览器的资源申请 （8）释放 TCP 连接：客户端服务器双方释放 TCP 连接 （9）浏览器显示资源：浏览器显示从服务器中获取到的文本，图片，视频等资源 请求报文 请求报文的格式由 请求行+请求头+请求体 构成\n请求行：\n请求方法 + 请求 URL + Http 协议版本\n请求方法：常见的 HTTP 请求方法有 GET，POST 还有 DELETE、HEAD、OPTIONS、PUT、TRACE 等方法\n请求行示例：\n1 POST /s?ie=utf-8 HTTP/1.1 请求头：\n常见的请求头\n1 2 3 4 5 6 7 8 9 10 11 12 13 User-Agent: 浏览器类型 Accept: 客户端可识别的响应内容类型列表 Accept-Language: 客户端可接收的自然语言 Accept-Encoding: 客户端可接收的编码压缩格式 Accept-Charest:可接受的应答字符集 Host: 请求的主机名 onnection: 连接方式（close 或 keepalive） Cookie: 存储与客户端扩展字段，向同一域名的服务器端发送属于该域的 cookie content-type: 响应类型 Host: baidu.com Cookie: name=study content-type: application/x-www-form-urlencode User-Agent: chorm 83 请求体：\n1 2 get 方式请求体位空 post 方式的请求体可以不为空（JSON） 响应报文：\n响应报文的格式也是由响应行+响应头+空行+响应体构成\n响应行：报文协议版本 + 状态码 以及状态描述\n1 HTTP/1.1 200 OK 常见 HTTP 状态码\n分类 分类描述 1** 信息，服务器收到请求，需要请求者继续执行操作 2** 成功，操作被成功接收并处理 3** 重定向，需要进一步操作以完成请求 4** 客户端错误，请求包含语法错误或无法完成请求 5** 服务器错误，服务器在处理请求过程中发生了错误 1 2 3 4 200 - 请求成功 301 - 资源 被永久转移到其他 URL 404 - 请求的资源不存在 500 - 内部服务器错误 HTTPS 1 2 3 4 https 和 http 的区别 （1）https 的端口是443，http 的端口是80，且两者的连接方式不同 （2）http 传输是明文的，而 https 是用 ssl 进行加密的，https 的安全性更高 （3）https 是需要申请证书的，http 不用 计网知识点补充 HTTP/1.1\tHTTP/2\tHTTP/3 的区别 HTTP/1.1 HTTP/1/1 是互联网第一个真正意义的 HTTP 标准版本\n核心是 一次一份\n1 2 3 当获取响应后，才可以发送下一个 HTTP 请求 在 TCP 连接建立之后，我们获取 html 文件，依据 html 文件获取 css、js 等文件 这些过程都是一次一次请求的，当其中一个文件请求失败，后续的文件也就拿不到了 这就是 HTTP 队头阻塞 HTTP1.1为了解决 队头阻塞问题，使用了 管线化 技术，即一个连接中可以发送多个请求，但是 响应的时候也必须按照发送的顺序接收 ，浏览器基本不用\n开发者为了减少请求次数，也开发出了很多黑科技，比如 精灵图 ，base64 直接传字符串\nHTTP/2 核心是 多路复用\n单个 TCP 连接就可以进行交错发送请求和响应\n1 2 3 把原本 HTTP 报文的首部和实体拆为两个部分 - 首部帧，数据帧 有一个流标识符来进行组合，实现了交错发送请求和响应，不会响应错乱 帧类型也可以设置优先级 HTTP/1 对实体进行了压缩，而 HTTP/2 对首部也进行了压缩，使用了 HPACK 算法\n服务器推送\n当浏览器进行请求时，服务器可以不用像以往一样解析 HTML 后再一个一个响应，而是把浏览器后续所需要的文件全发过来。但是存在安全隐患，如果只是点错了网页，就会被大量推送文件，非常臃肿\nHTTP/3 HTTP/2 只解决了 HTTP/1 的队头阻塞，但是 TCP 层面的 队头阻塞依然存在，数据再传输层发生了 丢包，仍然是继续等待\n核心是 整合\nHTTP/3 把 TCP 和 TLS 的握手过程整合在了一起，减少来回开销\nQUIC 协议 整合了 TCP 和 TLS\n所以 HTTP/3 默认使用了加密的，所以可以说是 TCP2.0 但不是 UDP2.0\n应用层过来的数据会被 QUIC 封装成 帧，和 HTTP/2 的帧很像，也是有流标识符\n而 HTTP/3 应用层 中并没有使用帧，而是直接移到了 QUIC 中，从源头解决了 队头阻塞\nQUIC 帧 后续被合成 QUIC 数据包，加入连接 ID，即使网络 IP 发生变化，也可以使用 连接ID 重新连接，避免握手\nQUIC 帧的内容也是被加密的，最后被 UDP 分装从数据段\n操作系统 操作系统定义 控制和管理整个计算机系统的硬件和软件资源 合理地组织调度计算机的 工作 和 资源分配 提供给用户和其他软件方便的 接口 和 环境 计算机系统中最基本的 系统软件 一句话：操作系统是架在用户和底层硬件之间的桥梁\n常见的操作系统 Windows MacOs Linux 安卓 操作系统功能 处理器：用于分配和控制处理器 存储器：负责内存的分配与回收 I/O设备：负责 I/O 设备的分配与操纵 文件管理：负责文件的存取，共享和保护 操作系统的特征 并发 两个或 多个事件 在 同一时间间隔内 发生。这些事件宏观上是同时发生，微观上是交替发生\n操作系统的并发性 指计算机系统中 同时存在着多个运行的程序\n并行 两个或 多个事件 在 同一时刻 发生\n共享 资源共享，指系统中的 资源可供内存中多个并发执行的进程共同使用\n两种共享方式 互斥共享方式和同时共享方式\n互斥共享方式 互斥共享是指当 资源被一个进程 A 占用 时，其他 想使用该资源的进程 B 就 只能等待 ，只用进程 A 使用完该资源后，进程 B 才能够使用该资源，这种共享方式就叫做互斥式共享，把这种资源叫做 临界资源或独占资源。如打印机就属于临界资源\n同时共享方式 某一资源在一段时间内 可由多个进程“同时”访问， 这种“同时”是宏观上的，在微观上，这些进程可能使交替 对该资源进行访问，磁盘设备就是这类资源\n虚拟 把一个物理上的实体变为若干个逻辑上的对应物，物理实体是实际存在的，而逻辑上对应物是用户感受到的\n虚拟分为 时分复用技术 和 空分复用技术\n时分复用技术 微观上处理机在各个微小的时间段内 交替着为各个进程服务\n如：一个单核 CPU 可以执行多个程序，给用户一种多核的 “假象”\n空分复用技术 空分复用是指 多个程序或用户同时使用一个资源的不同部分\n如：电脑磁盘分为 C 盘，D 盘，E 盘等，实际上只是虚拟逻辑上的分区，实际电脑硬盘还是一个\n异步 在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性\n最基本的特征：并发和共享，两者互为存在条件\n操作系统的发展阶段和分类 手工操作阶段 输入/输出速度慢 处理机处理速度快，处理机利用率低\n单道批处理 引入 脱机输入/输出技术 （用磁带完成），并监督程序负责控制作业的输入、输出\n优点：资源利用率有所提升\n缺点：内存中仅有一道程序运行，只有该程序运行结束之后才能调入下一道程序\n多道批处理 每次往内存中 输入多道程序，操作系统正式诞生，并引用了中断技术，**由操作系统负责管理这些程序的运行。**各个程序 并发执行\n优点：多道程序并发执行\n缺点：用户响应时间长\n分时操作系统 计算机 以时间片为单位轮流为各个用户/作业服务，各个用户 可通过终端与计算机进行交互\n优点：用户请求可以被即时响应，并且用户对计算机的操作相互独立\n缺点：不能有限处理一些紧急任务，循环地为每个用户/作业服务一个时间片，不区分任务的紧急性\n分时操作系统典型的例子就是 Unix 和 Linux 操作系统\n实时操作系统 优点：能够有限相应一些紧急任务\n在 实时操作系统 的控制下，计算机系统接收到外部信号后及时进行处理，并且要在 严格的时限内处理完事件\n硬实时系统 必须在 绝对严格 的规定时间内完成处理 如：导弹控制系统，自动驾驶系统 软实时系统 有一个截止时间，但 并不严格 如：12306 火车订票系统 操作系统的结构设计 传统操作系统结构 无结构操作系统 模块化结构 OS 分层式结构 OS 客户/服务器模式 由客户机、服务器、网络系统组成\n四步骤：客户发送请求信息，服务器接收消息，服务器回送消息，客户机接收消息\n面向对象的程序设计 像 Java、C++ 等高级语言就是面向对象编程，在操作系统中也用到很多面向对象的设计思想。比如文件就可以看作一个类，类的变量可以是文件的类型、大小或创建者\n微内核 OS 结构 为提高操作系统的正确性、灵活性、易维护性、可扩充性，现代操作系统结构大多采用基于客户/服务器模式为内核结构，将操作系统分为 微内核和多个服务器\n补充概念 特权命令 多为特权命令是指有特权权限的指令，由于这类指令的权限最大，如果使用不当，将导致整个系统崩溃。比如：清内存、置时钟、分配系统资源、修改虚存的段表和页表，修改用户的访问权限等\n系统调用 系统调用是操作系统提供给 **应用程序使用的接口，**可以理解为一种可供程序 **调用的特殊函数，**应用程序可以发出系统调用请求来 获得操作系统的服务\n用户可以利用读系统 调用 read，用户也可以利用写系统调用 write\n中断和异常 原语 由若干条指令组成，来完成一定功能的过程，执行必须过程连续，不允许被中断\n处理机状态 内核态：CPU 可以 访问【内存】所有数据，包括外围设备，例如硬盘，网卡 CPU 也可以将自己从一个程序切换到另一个程序\n用户态：只能受限的访问内存，且不允许范文外围设备，占用 CPU 的能力被剥夺，CPU资源可以被其他程序获取\n内核态和用户态的区别就是 权限不同，内核态处于权限0，权限较高，用户态处于权限3，权限较低\n用户态切换到内核态的方式\n系统调用 进程调用：exit，fork 文件系统访问：chmod、chown 设备调用：read、write 信息读取：读取设备信息 通信：mma、pipe等 中断 异常 ","date":"2024-08-29T20:13:09+08:00","image":"https://akaxedx.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/saber_hu3120267142170166617.jpg","permalink":"https://akaxedx.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/","title":"计算机基础"},{"content":"https://www.itbaima.cn/document/dncxjecdv4wciqcp\n直接阅读这个\n","date":"2024-08-25T05:53:40+08:00","image":"https://akaxedx.github.io/p/java-se/698503_hu14773505816458707756.jpg","permalink":"https://akaxedx.github.io/p/java-se/","title":"Java SE"}]